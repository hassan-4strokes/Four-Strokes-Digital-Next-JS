(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_e38fa7._.js", {

"[project]/node_modules/next/navigation.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    searchParams.forEach((value, key)=>{
        if (typeof query[key] === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(query[key])) {
            ;
            query[key].push(value);
        } else {
            query[key] = [
                query[key],
                value
            ];
        }
    });
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(urlQuery) {
    const result = new URLSearchParams();
    Object.entries(urlQuery).forEach((param)=>{
        let [key, value] = param;
        if (Array.isArray(value)) {
            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));
        } else {
            result.set(key, stringifyUrlQueryParam(value));
        }
    });
    return result;
}
function assign(target) {
    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        searchParamsList[_key - 1] = arguments[_key];
    }
    searchParamsList.forEach((searchParams)=>{
        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));
        searchParams.forEach((value, key)=>target.append(key, value));
    });
    return target;
} //# sourceMappingURL=querystring.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __turbopack_require__("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_require__("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? "[" + hostname + "]" : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && "?" + query || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return "" + protocol + host + pathname + search + hash;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn("Unknown key passed via urlObject into url.format: " + key);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}}),
"[project]/node_modules/next/dist/client/request-idle-callback.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    cancelIdleCallback: null,
    requestIdleCallback: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    cancelIdleCallback: function() {
        return cancelIdleCallback;
    },
    requestIdleCallback: function() {
        return requestIdleCallback;
    }
});
const requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
    let start = Date.now();
    return self.setTimeout(function() {
        cb({
            didTimeout: false,
            timeRemaining: function() {
                return Math.max(0, 50 - (Date.now() - start));
            }
        });
    }, 1);
};
const cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {
    return clearTimeout(id);
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=request-idle-callback.js.map
}}),
"[project]/node_modules/next/dist/client/use-intersection.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useIntersection", {
    enumerable: true,
    get: function() {
        return useIntersection;
    }
});
const _react = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _requestidlecallback = __turbopack_require__("[project]/node_modules/next/dist/client/request-idle-callback.js [app-client] (ecmascript)");
const hasIntersectionObserver = typeof IntersectionObserver === 'function';
const observers = new Map();
const idList = [];
function createObserver(options) {
    const id = {
        root: options.root || null,
        margin: options.rootMargin || ''
    };
    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);
    let instance;
    if (existing) {
        instance = observers.get(existing);
        if (instance) {
            return instance;
        }
    }
    const elements = new Map();
    const observer = new IntersectionObserver((entries)=>{
        entries.forEach((entry)=>{
            const callback = elements.get(entry.target);
            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;
            if (callback && isVisible) {
                callback(isVisible);
            }
        });
    }, options);
    instance = {
        id,
        observer,
        elements
    };
    idList.push(id);
    observers.set(id, instance);
    return instance;
}
function observe(element, callback, options) {
    const { id, observer, elements } = createObserver(options);
    elements.set(element, callback);
    observer.observe(element);
    return function unobserve() {
        elements.delete(element);
        observer.unobserve(element);
        // Destroy observer when there's nothing left to watch:
        if (elements.size === 0) {
            observer.disconnect();
            observers.delete(id);
            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);
            if (index > -1) {
                idList.splice(index, 1);
            }
        }
    };
}
function useIntersection(param) {
    let { rootRef, rootMargin, disabled } = param;
    const isDisabled = disabled || !hasIntersectionObserver;
    const [visible, setVisible] = (0, _react.useState)(false);
    const elementRef = (0, _react.useRef)(null);
    const setElement = (0, _react.useCallback)((element)=>{
        elementRef.current = element;
    }, []);
    (0, _react.useEffect)(()=>{
        if (hasIntersectionObserver) {
            if (isDisabled || visible) return;
            const element = elementRef.current;
            if (element && element.tagName) {
                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {
                    root: rootRef == null ? void 0 : rootRef.current,
                    rootMargin
                });
                return unobserve;
            }
        } else {
            if (!visible) {
                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));
                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled,
        rootMargin,
        rootRef,
        visible,
        elementRef.current
    ]);
    const resetVisible = (0, _react.useCallback)(()=>{
        setVisible(false);
    }, []);
    return [
        setElement,
        visible,
        resetVisible
    ];
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-intersection.js.map
}}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(()=>{});
    const cleanupB = (0, _react.useRef)(()=>{});
    return (0, _react.useMemo)(()=>{
        if (!refA || !refB) {
            return refA || refB;
        }
        return (current)=>{
            if (current === null) {
                cleanupA.current();
                cleanupB.current();
            } else {
                cleanupA.current = applyRef(refA, current);
                cleanupB.current = applyRef(refB, current);
            }
        };
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ':' + port : '');
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? "?" + urlParts.slice(1).join('?') : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        var _App_prototype;
        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {
            const message = '"' + getDisplayName(App) + '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';
            throw new Error(message);
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw new Error(message);
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn("" + getDisplayName(App) + " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps");
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = "Cannot find module for page: " + page;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = "Cannot find the middleware module";
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/client/app-dir/link.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _interop_require_default = __turbopack_require__("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _formaturl = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _useintersection = __turbopack_require__("[project]/node_modules/next/dist/client/use-intersection.js [app-client] (ecmascript)");
const _routerreducertypes = __turbopack_require__("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)");
const _usemergedref = __turbopack_require__("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
const _utils = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _addbasepath = __turbopack_require__("[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)");
const _warnonce = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function prefetch(router, href, options) {
    if (typeof window === 'undefined') {
        return;
    }
    const doPrefetch = async ()=>{
        // note that `appRouter.prefetch()` is currently sync,
        // so we have to wrap this call in an async function to be able to catch() errors below.
        return router.prefetch(href, options);
    };
    // Prefetch the page if asked (only in the client)
    // We need to handle a prefetch error here since we may be
    // loading with priority which can reject but we don't
    // want to force navigation since this is only a prefetch
    doPrefetch().catch((err)=>{
        if (("TURBOPACK compile-time value", "development") !== 'production') {
            // rethrow to show invalid URL errors
            throw err;
        }
    });
}
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, router, href, as, replace, shallow, scroll) {
    const { nodeName } = e.currentTarget;
    // anchors inside an svg have a lowercase nodeName
    const isAnchorNodeName = nodeName.toUpperCase() === 'A';
    if (isAnchorNodeName && isModifiedEvent(e)) {
        // ignore click for browser’s default behavior
        return;
    }
    e.preventDefault();
    const navigate = ()=>{
        // If the router is an NextRouter instance it will have `beforePopState`
        const routerScroll = scroll != null ? scroll : true;
        if ('beforePopState' in router) {
            router[replace ? 'replace' : 'push'](href, as, {
                shallow,
                scroll: routerScroll
            });
        } else {
            router[replace ? 'replace' : 'push'](as || href, {
                scroll: routerScroll
            });
        }
    };
    _react.default.startTransition(navigate);
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
/**
 * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation between routes.
 *
 * It is the primary way to navigate between routes in Next.js.
 *
 * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)
 */ const Link = /*#__PURE__*/ _react.default.forwardRef(function LinkComponent(props, forwardedRef) {
    let children;
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const prefetchEnabled = prefetchProp !== false;
    /**
     * The possible states for prefetch are:
     * - null: this is the default "auto" mode, where we will prefetch partially if the link is in the viewport
     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially
     * - false: we will not prefetch if in the viewport at all
     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;
    if ("TURBOPACK compile-time truthy", 1) {
        function createPropError(args) {
            return new Error("Failed prop type: The prop `" + args.key + "` expects a " + args.expected + " in `<Link>`, but got `" + args.actual + "` instead." + (typeof window !== 'undefined' ? "\nOpen your browser's console to view the Component stack trace." : ''));
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch' || key === 'legacyBehavior') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (props.locale) {
            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');
        }
        if (!asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw new Error("Dynamic href `" + href + "` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href");
                }
            }
        }
    }
    const { href, as } = _react.default.useMemo({
        "Link.LinkComponent.useMemo": ()=>{
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref
            };
        }
    }["Link.LinkComponent.useMemo"], [
        hrefProp,
        asProp
    ]);
    const previousHref = _react.default.useRef(href);
    const previousAs = _react.default.useRef(as);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (onClick) {
                console.warn('"onClick" was passed to <Link> with `href` of `' + hrefProp + '` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link');
            }
            if (onMouseEnterProp) {
                console.warn('"onMouseEnter" was passed to <Link> with `href` of `' + hrefProp + '` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw new Error("No children were passed to <Link> with `href` of `" + hrefProp + "` but one child is required https://nextjs.org/docs/messages/link-no-children");
                }
                throw new Error("Multiple children were passed to <Link> with `href` of `" + hrefProp + "` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children" + (typeof window !== 'undefined' ? " \nOpen your browser's console to view the Component stack trace." : ''));
            }
        } else {
            "TURBOPACK unreachable";
        }
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ((children == null ? void 0 : children.type) === 'a') {
                throw new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor');
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({
        rootMargin: '200px'
    });
    const setIntersectionWithResetRef = _react.default.useCallback({
        "Link.LinkComponent.useCallback[setIntersectionWithResetRef]": (el)=>{
            // Before the link getting observed, check if visible state need to be reset
            if (previousAs.current !== as || previousHref.current !== href) {
                resetVisible();
                previousAs.current = as;
                previousHref.current = href;
            }
            setIntersectionRef(el);
        }
    }["Link.LinkComponent.useCallback[setIntersectionWithResetRef]"], [
        as,
        href,
        resetVisible,
        setIntersectionRef
    ]);
    const setRef = (0, _usemergedref.useMergedRef)(setIntersectionWithResetRef, childRef);
    // Prefetch the URL if we haven't already and it's visible.
    _react.default.useEffect({
        "Link.LinkComponent.useEffect": ()=>{
            // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            "TURBOPACK unreachable";
        }
    }["Link.LinkComponent.useEffect"], [
        as,
        href,
        isVisible,
        prefetchEnabled,
        router,
        appPrefetchKind
    ]);
    const childProps = {
        ref: setRef,
        onClick (e) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (!e) {
                    throw new Error('Component rendered inside next/link has to pass click event to "onClick" prop.');
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, router, href, as, replace, shallow, scroll);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            "TURBOPACK unreachable";
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled) {
                return;
            }
            prefetch(router, href, {
                kind: appPrefetchKind
            });
        }
    };
    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
    // defined, we specify the current 'href', so that repetition is not needed by the user.
    // If the url is absolute, we can bypass the logic to prepend the basePath.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
    }
    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
        ...restProps,
        ...childProps,
        children: children
    });
});
const _default = Link;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map
}}),
"[project]/node_modules/@editorjs/editorjs/dist/editorjs.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>Aa)
});
(function() {
    "use strict";
    try {
        if (typeof document < "u") {
            var e = document.createElement("style");
            e.appendChild(document.createTextNode(".ce-hint--align-start{text-align:left}.ce-hint--align-center{text-align:center}.ce-hint__description{opacity:.6;margin-top:3px}")), document.head.appendChild(e);
        }
    } catch (t1) {
        console.error("vite-plugin-css-injected-by-js", t1);
    }
})();
var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ke(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Xn(n) {
    if (n.__esModule) return n;
    var e = n.default;
    if (typeof e == "function") {
        var t1 = function o() {
            return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
        };
        t1.prototype = e.prototype;
    } else t1 = {};
    return Object.defineProperty(t1, "__esModule", {
        value: !0
    }), Object.keys(n).forEach(function(o) {
        var i = Object.getOwnPropertyDescriptor(n, o);
        Object.defineProperty(t1, o, i.get ? i : {
            enumerable: !0,
            get: function() {
                return n[o];
            }
        });
    }), t1;
}
function ot() {}
Object.assign(ot, {
    default: ot,
    register: ot,
    revert: function() {},
    __esModule: !0
});
Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(n) {
    const e = (this.document || this.ownerDocument).querySelectorAll(n);
    let t1 = e.length;
    for(; --t1 >= 0 && e.item(t1) !== this;);
    return t1 > -1;
});
Element.prototype.closest || (Element.prototype.closest = function(n) {
    let e = this;
    if (!document.documentElement.contains(e)) return null;
    do {
        if (e.matches(n)) return e;
        e = e.parentElement || e.parentNode;
    }while (e !== null)
    return null;
});
Element.prototype.prepend || (Element.prototype.prepend = function(e) {
    const t1 = document.createDocumentFragment();
    Array.isArray(e) || (e = [
        e
    ]), e.forEach((o)=>{
        const i = o instanceof Node;
        t1.appendChild(i ? o : document.createTextNode(o));
    }), this.insertBefore(t1, this.firstChild);
});
Element.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(n) {
    n = arguments.length === 0 ? !0 : !!n;
    const e = this.parentNode, t1 = window.getComputedStyle(e, null), o = parseInt(t1.getPropertyValue("border-top-width")), i = parseInt(t1.getPropertyValue("border-left-width")), s = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, a = this.offsetLeft - e.offsetLeft < e.scrollLeft, l = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, c = s && !r;
    (s || r) && n && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (a || l) && n && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (s || r || a || l) && !n && this.scrollIntoView(c);
});
window.requestIdleCallback = window.requestIdleCallback || function(n) {
    const e = Date.now();
    return setTimeout(function() {
        n({
            didTimeout: !1,
            timeRemaining: function() {
                return Math.max(0, 50 - (Date.now() - e));
            }
        });
    }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(n) {
    clearTimeout(n);
};
let Vn = (n = 21)=>crypto.getRandomValues(new Uint8Array(n)).reduce((e, t1)=>(t1 &= 63, t1 < 36 ? e += t1.toString(36) : t1 < 62 ? e += (t1 - 26).toString(36).toUpperCase() : t1 > 62 ? e += "-" : e += "_", e), "");
var Lo = /* @__PURE__ */ ((n)=>(n.VERBOSE = "VERBOSE", n.INFO = "INFO", n.WARN = "WARN", n.ERROR = "ERROR", n))(Lo || {});
const y = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    DOWN: 40,
    RIGHT: 39,
    DELETE: 46,
    META: 91,
    SLASH: 191
}, qn = {
    LEFT: 0,
    WHEEL: 1,
    RIGHT: 2,
    BACKWARD: 3,
    FORWARD: 4
};
function Ie(n, e, t1 = "log", o, i = "color: inherit") {
    if (!("console" in window) || !window.console[t1]) return;
    const s = [
        "info",
        "log",
        "warn",
        "error"
    ].includes(t1), r = [];
    switch(Ie.logLevel){
        case "ERROR":
            if (t1 !== "error") return;
            break;
        case "WARN":
            if (![
                "error",
                "warn"
            ].includes(t1)) return;
            break;
        case "INFO":
            if (!s || n) return;
            break;
    }
    o && r.push(o);
    const a = "Editor.js 2.31.0-rc.7", l = `line-height: 1em;
            color: #006FEA;
            display: inline-block;
            font-size: 11px;
            line-height: 1em;
            background-color: #fff;
            padding: 4px 9px;
            border-radius: 30px;
            border: 1px solid rgba(56, 138, 229, 0.16);
            margin: 4px 5px 4px 0;`;
    n && (s ? (r.unshift(l, i), e = `%c${a}%c ${e}`) : e = `( ${a} )${e}`);
    try {
        s ? o ? console[t1](`${e} %o`, ...r) : console[t1](e, ...r) : console[t1](e);
    } catch  {}
}
Ie.logLevel = "VERBOSE";
function Zn(n) {
    Ie.logLevel = n;
}
const S = Ie.bind(window, !1), X = Ie.bind(window, !0);
function le(n) {
    return Object.prototype.toString.call(n).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function A(n) {
    return le(n) === "function" || le(n) === "asyncfunction";
}
function D(n) {
    return le(n) === "object";
}
function te(n) {
    return le(n) === "string";
}
function Gn(n) {
    return le(n) === "boolean";
}
function yo(n) {
    return le(n) === "number";
}
function wo(n) {
    return le(n) === "undefined";
}
function V(n) {
    return n ? Object.keys(n).length === 0 && n.constructor === Object : !0;
}
function Po(n) {
    return n > 47 && n < 58 || // number keys
    n === 32 || n === 13 || // Space bar & return key(s)
    n === 229 || // processing key input for certain languages — Chinese, Japanese, etc.
    n > 64 && n < 91 || // letter keys
    n > 95 && n < 112 || // Numpad keys
    n > 185 && n < 193 || // ;=,-./` (in order)
    n > 218 && n < 223;
}
async function Qn(n, e = ()=>{}, t1 = ()=>{}) {
    async function o(i, s, r) {
        try {
            await i.function(i.data), await s(wo(i.data) ? {} : i.data);
        } catch  {
            r(wo(i.data) ? {} : i.data);
        }
    }
    return n.reduce(async (i, s)=>(await i, o(s, e, t1)), Promise.resolve());
}
function No(n) {
    return Array.prototype.slice.call(n);
}
function Fe(n, e) {
    return function() {
        const t1 = this, o = arguments;
        window.setTimeout(()=>n.apply(t1, o), e);
    };
}
function Jn(n) {
    return n.name.split(".").pop();
}
function ei(n) {
    return /^[-\w]+\/([-+\w]+|\*)$/.test(n);
}
function Eo(n, e, t1) {
    let o;
    return (...i)=>{
        const s = this, r = ()=>{
            o = null, t1 || n.apply(s, i);
        }, a = t1 && !o;
        window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);
    };
}
function dt(n, e, t1 = void 0) {
    let o, i, s, r = null, a = 0;
    t1 || (t1 = {});
    const l = function() {
        a = t1.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r || (o = i = null);
    };
    return function() {
        const c = Date.now();
        !a && t1.leading === !1 && (a = c);
        const u = e - (c - a);
        return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r || (o = i = null)) : !r && t1.trailing !== !1 && (r = setTimeout(l, u)), s;
    };
}
function ti() {
    const n = {
        win: !1,
        mac: !1,
        x11: !1,
        linux: !1
    }, e = Object.keys(n).find((t1)=>window.navigator.appVersion.toLowerCase().indexOf(t1) !== -1);
    return e && (n[e] = !0), n;
}
function je(n) {
    return n[0].toUpperCase() + n.slice(1);
}
function ut(n, ...e) {
    if (!e.length) return n;
    const t1 = e.shift();
    if (D(n) && D(t1)) for(const o in t1)D(t1[o]) ? (n[o] || Object.assign(n, {
        [o]: {}
    }), ut(n[o], t1[o])) : Object.assign(n, {
        [o]: t1[o]
    });
    return ut(n, ...e);
}
function vt(n) {
    const e = ti();
    return n = n.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, " + "), e.mac ? n = n.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : n = n.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), n;
}
function oi(n) {
    try {
        return new URL(n).href;
    } catch  {}
    return n.substring(0, 2) === "//" ? window.location.protocol + n : window.location.origin + n;
}
function ni() {
    return Vn(10);
}
function ii(n) {
    window.open(n, "_blank");
}
function si(n = "") {
    return `${n}${Math.floor(Math.random() * 1e8).toString(16)}`;
}
function ht(n, e, t1) {
    const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t1}» instead.`;
    n && X(o, "warn");
}
function me(n, e, t1) {
    const o = t1.value ? "value" : "get", i = t1[o], s = `#${e}Cache`;
    if (t1[o] = function(...r) {
        return this[s] === void 0 && (this[s] = i.apply(this, ...r)), this[s];
    }, o === "get" && t1.set) {
        const r = t1.set;
        t1.set = function(a) {
            delete n[s], r.apply(this, a);
        };
    }
    return t1;
}
const Ro = 650;
function be() {
    return window.matchMedia(`(max-width: ${Ro}px)`).matches;
}
const pt = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function ri(n, e) {
    const t1 = Array.isArray(n) || D(n), o = Array.isArray(e) || D(e);
    return t1 || o ? JSON.stringify(n) === JSON.stringify(e) : n === e;
}
class d {
    /**
   * Check if passed tag has no closed tag
   *
   * @param {HTMLElement} tag - element to check
   * @returns {boolean}
   */ static isSingleTag(e) {
        return e.tagName && [
            "AREA",
            "BASE",
            "BR",
            "COL",
            "COMMAND",
            "EMBED",
            "HR",
            "IMG",
            "INPUT",
            "KEYGEN",
            "LINK",
            "META",
            "PARAM",
            "SOURCE",
            "TRACK",
            "WBR"
        ].includes(e.tagName);
    }
    /**
   * Check if element is BR or WBR
   *
   * @param {HTMLElement} element - element to check
   * @returns {boolean}
   */ static isLineBreakTag(e) {
        return e && e.tagName && [
            "BR",
            "WBR"
        ].includes(e.tagName);
    }
    /**
   * Helper for making Elements with class name and attributes
   *
   * @param  {string} tagName - new Element tag name
   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)
   * @param  {object} [attributes] - any attributes
   * @returns {HTMLElement}
   */ static make(e, t1 = null, o = {}) {
        const i = document.createElement(e);
        if (Array.isArray(t1)) {
            const s = t1.filter((r)=>r !== void 0);
            i.classList.add(...s);
        } else t1 && i.classList.add(t1);
        for(const s in o)Object.prototype.hasOwnProperty.call(o, s) && (i[s] = o[s]);
        return i;
    }
    /**
   * Creates Text Node with the passed content
   *
   * @param {string} content - text content
   * @returns {Text}
   */ static text(e) {
        return document.createTextNode(e);
    }
    /**
   * Append one or several elements to the parent
   *
   * @param  {Element|DocumentFragment} parent - where to append
   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list
   */ static append(e, t1) {
        Array.isArray(t1) ? t1.forEach((o)=>e.appendChild(o)) : e.appendChild(t1);
    }
    /**
   * Append element or a couple to the beginning of the parent elements
   *
   * @param {Element} parent - where to append
   * @param {Element|Element[]} elements - element or elements list
   */ static prepend(e, t1) {
        Array.isArray(t1) ? (t1 = t1.reverse(), t1.forEach((o)=>e.prepend(o))) : e.prepend(t1);
    }
    /**
   * Swap two elements in parent
   *
   * @param {HTMLElement} el1 - from
   * @param {HTMLElement} el2 - to
   * @deprecated
   */ static swap(e, t1) {
        const o = document.createElement("div"), i = e.parentNode;
        i.insertBefore(o, e), i.insertBefore(e, t1), i.insertBefore(t1, o), i.removeChild(o);
    }
    /**
   * Selector Decorator
   *
   * Returns first match
   *
   * @param {Element} el - element we searching inside. Default - DOM Document
   * @param {string} selector - searching string
   * @returns {Element}
   */ static find(e = document, t1) {
        return e.querySelector(t1);
    }
    /**
   * Get Element by Id
   *
   * @param {string} id - id to find
   * @returns {HTMLElement | null}
   */ static get(e) {
        return document.getElementById(e);
    }
    /**
   * Selector Decorator.
   *
   * Returns all matches
   *
   * @param {Element|Document} el - element we searching inside. Default - DOM Document
   * @param {string} selector - searching string
   * @returns {NodeList}
   */ static findAll(e = document, t1) {
        return e.querySelectorAll(t1);
    }
    /**
   * Returns CSS selector for all text inputs
   */ static get allInputsSelector() {
        return "[contenteditable=true], textarea, input:not([type]), " + [
            "text",
            "password",
            "email",
            "number",
            "search",
            "tel",
            "url"
        ].map((t1)=>`input[type="${t1}"]`).join(", ");
    }
    /**
   * Find all contenteditable, textarea and editable input elements passed holder contains
   *
   * @param holder - element where to find inputs
   */ static findAllInputs(e) {
        return No(e.querySelectorAll(d.allInputsSelector)).reduce((t1, o)=>d.isNativeInput(o) || d.containsOnlyInlineElements(o) ? [
                ...t1,
                o
            ] : [
                ...t1,
                ...d.getDeepestBlockElements(o)
            ], []);
    }
    /**
   * Search for deepest node which is Leaf.
   * Leaf is the vertex that doesn't have any child nodes
   *
   * @description Method recursively goes throw the all Node until it finds the Leaf
   * @param {Node} node - root Node. From this vertex we start Deep-first search
   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}
   * @param {boolean} [atLast] - find last text node
   * @returns - it can be text Node or Element Node, so that caret will able to work with it
   *            Can return null if node is Document or DocumentFragment, or node is not attached to the DOM
   */ static getDeepestNode(e, t1 = !1) {
        const o = t1 ? "lastChild" : "firstChild", i = t1 ? "previousSibling" : "nextSibling";
        if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {
            let s = e[o];
            if (d.isSingleTag(s) && !d.isNativeInput(s) && !d.isLineBreakTag(s)) if (s[i]) s = s[i];
            else if (s.parentNode[i]) s = s.parentNode[i];
            else return s.parentNode;
            return this.getDeepestNode(s, t1);
        }
        return e;
    }
    /**
   * Check if object is DOM node
   *
   * @param {*} node - object to check
   * @returns {boolean}
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isElement(e) {
        return yo(e) ? !1 : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;
    }
    /**
   * Check if object is DocumentFragment node
   *
   * @param {object} node - object to check
   * @returns {boolean}
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isFragment(e) {
        return yo(e) ? !1 : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
    }
    /**
   * Check if passed element is contenteditable
   *
   * @param {HTMLElement} element - html element to check
   * @returns {boolean}
   */ static isContentEditable(e) {
        return e.contentEditable === "true";
    }
    /**
   * Checks target if it is native input
   *
   * @param {*} target - HTML element or string
   * @returns {boolean}
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isNativeInput(e) {
        const t1 = [
            "INPUT",
            "TEXTAREA"
        ];
        return e && e.tagName ? t1.includes(e.tagName) : !1;
    }
    /**
   * Checks if we can set caret
   *
   * @param {HTMLElement} target - target to check
   * @returns {boolean}
   */ static canSetCaret(e) {
        let t1 = !0;
        if (d.isNativeInput(e)) switch(e.type){
            case "file":
            case "checkbox":
            case "radio":
            case "hidden":
            case "submit":
            case "button":
            case "image":
            case "reset":
                t1 = !1;
                break;
        }
        else t1 = d.isContentEditable(e);
        return t1;
    }
    /**
   * Checks node if it is empty
   *
   * @description Method checks simple Node without any childs for emptiness
   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method
   * @param {Node} node - node to check
   * @param {string} [ignoreChars] - char or substring to treat as empty
   * @returns {boolean} true if it is empty
   */ static isNodeEmpty(e, t1) {
        let o;
        return this.isSingleTag(e) && !this.isLineBreakTag(e) ? !1 : (this.isElement(e) && this.isNativeInput(e) ? o = e.value : o = e.textContent.replace("​", ""), t1 && (o = o.replace(new RegExp(t1, "g"), "")), o.length === 0);
    }
    /**
   * checks node if it is doesn't have any child nodes
   *
   * @param {Node} node - node to check
   * @returns {boolean}
   */ static isLeaf(e) {
        return e ? e.childNodes.length === 0 : !1;
    }
    /**
   * breadth-first search (BFS)
   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}
   *
   * @description Pushes to stack all DOM leafs and checks for emptiness
   * @param {Node} node - node to check
   * @param {string} [ignoreChars] - char or substring to treat as empty
   * @returns {boolean}
   */ static isEmpty(e, t1) {
        const o = [
            e
        ];
        for(; o.length > 0;)if (e = o.shift(), !!e) {
            if (this.isLeaf(e) && !this.isNodeEmpty(e, t1)) return !1;
            e.childNodes && o.push(...Array.from(e.childNodes));
        }
        return !0;
    }
    /**
   * Check if string contains html elements
   *
   * @param {string} str - string to check
   * @returns {boolean}
   */ static isHTMLString(e) {
        const t1 = d.make("div");
        return t1.innerHTML = e, t1.childElementCount > 0;
    }
    /**
   * Return length of node`s text content
   *
   * @param {Node} node - node with content
   * @returns {number}
   */ static getContentLength(e) {
        return d.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;
    }
    /**
   * Return array of names of block html elements
   *
   * @returns {string[]}
   */ static get blockElements() {
        return [
            "address",
            "article",
            "aside",
            "blockquote",
            "canvas",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "hr",
            "li",
            "main",
            "nav",
            "noscript",
            "ol",
            "output",
            "p",
            "pre",
            "ruby",
            "section",
            "table",
            "tbody",
            "thead",
            "tr",
            "tfoot",
            "ul",
            "video"
        ];
    }
    /**
   * Check if passed content includes only inline elements
   *
   * @param {string|HTMLElement} data - element or html string
   * @returns {boolean}
   */ static containsOnlyInlineElements(e) {
        let t1;
        te(e) ? (t1 = document.createElement("div"), t1.innerHTML = e) : t1 = e;
        const o = (i)=>!d.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);
        return Array.from(t1.children).every(o);
    }
    /**
   * Find and return all block elements in the passed parent (including subtree)
   *
   * @param {HTMLElement} parent - root element
   * @returns {HTMLElement[]}
   */ static getDeepestBlockElements(e) {
        return d.containsOnlyInlineElements(e) ? [
            e
        ] : Array.from(e.children).reduce((t1, o)=>[
                ...t1,
                ...d.getDeepestBlockElements(o)
            ], []);
    }
    /**
   * Helper for get holder from {string} or return HTMLElement
   *
   * @param {string | HTMLElement} element - holder's id or holder's HTML Element
   * @returns {HTMLElement}
   */ static getHolder(e) {
        return te(e) ? document.getElementById(e) : e;
    }
    /**
   * Returns true if element is anchor (is A tag)
   *
   * @param {Element} element - element to check
   * @returns {boolean}
   */ static isAnchor(e) {
        return e.tagName.toLowerCase() === "a";
    }
    /**
   * Return element's offset related to the document
   *
   * @todo handle case when editor initialized in scrollable popup
   * @param el - element to compute offset
   */ static offset(e) {
        const t1 = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, s = t1.top + i, r = t1.left + o;
        return {
            top: s,
            left: r,
            bottom: s + t1.height,
            right: r + t1.width
        };
    }
}
function ai(n) {
    return !/[^\t\n\r ]/.test(n);
}
function li(n) {
    const e = window.getComputedStyle(n), t1 = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t1 * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t1 * 0.8, l = (o - t1) / 2;
    return r + s + i + l + a;
}
function Do(n) {
    n.dataset.empty = d.isEmpty(n) ? "true" : "false";
}
const ci = {
    blockTunes: {
        toggler: {
            "Click to tune": "",
            "or drag to move": ""
        }
    },
    inlineToolbar: {
        converter: {
            "Convert to": ""
        }
    },
    toolbar: {
        toolbox: {
            Add: ""
        }
    },
    popover: {
        Filter: "",
        "Nothing found": "",
        "Convert to": ""
    }
}, di = {
    Text: "",
    Link: "",
    Bold: "",
    Italic: ""
}, ui = {
    link: {
        "Add a link": ""
    },
    stub: {
        "The block can not be displayed correctly.": ""
    }
}, hi = {
    delete: {
        Delete: "",
        "Click to delete": ""
    },
    moveUp: {
        "Move up": ""
    },
    moveDown: {
        "Move down": ""
    }
}, Fo = {
    ui: ci,
    toolNames: di,
    tools: ui,
    blockTunes: hi
}, jo = class he {
    /**
   * Type-safe translation for internal UI texts:
   * Perform translation of the string by namespace and a key
   *
   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')
   * @param internalNamespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */ static ui(e, t1) {
        return he._t(e, t1);
    }
    /**
   * Translate for external strings that is not presented in default dictionary.
   * For example, for user-specified tool names
   *
   * @param namespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */ static t(e, t1) {
        return he._t(e, t1);
    }
    /**
   * Adjust module for using external dictionary
   *
   * @param dictionary - new messages list to override default
   */ static setDictionary(e) {
        he.currentDictionary = e;
    }
    /**
   * Perform translation both for internal and external namespaces
   * If there is no translation found, returns passed key as a translated message
   *
   * @param namespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */ static _t(e, t1) {
        const o = he.getNamespace(e);
        return !o || !o[t1] ? t1 : o[t1];
    }
    /**
   * Find messages section by namespace path
   *
   * @param namespace - path to section
   */ static getNamespace(e) {
        return e.split(".").reduce((o, i)=>!o || !Object.keys(o).length ? {} : o[i], he.currentDictionary);
    }
};
jo.currentDictionary = Fo;
let z = jo;
class Ho extends Error {
}
class Oe {
    constructor(){
        this.subscribers = {};
    }
    /**
   * Subscribe any event on callback
   *
   * @param eventName - event name
   * @param callback - subscriber
   */ on(e, t1) {
        e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t1);
    }
    /**
   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.
   *
   * @param eventName - event name
   * @param callback - subscriber
   */ once(e, t1) {
        e in this.subscribers || (this.subscribers[e] = []);
        const o = (i)=>{
            const s = t1(i), r = this.subscribers[e].indexOf(o);
            return r !== -1 && this.subscribers[e].splice(r, 1), s;
        };
        this.subscribers[e].push(o);
    }
    /**
   * Emit callbacks with passed data
   *
   * @param eventName - event name
   * @param data - subscribers get this data when they were fired
   */ emit(e, t1) {
        V(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i)=>{
            const s = i(o);
            return s !== void 0 ? s : o;
        }, t1);
    }
    /**
   * Unsubscribe callback from event
   *
   * @param eventName - event name
   * @param callback - event handler
   */ off(e, t1) {
        if (this.subscribers[e] === void 0) {
            console.warn(`EventDispatcher .off(): there is no subscribers for event "${e.toString()}". Probably, .off() called before .on()`);
            return;
        }
        for(let o = 0; o < this.subscribers[e].length; o++)if (this.subscribers[e][o] === t1) {
            delete this.subscribers[e][o];
            break;
        }
    }
    /**
   * Destroyer
   * clears subscribers list
   */ destroy() {
        this.subscribers = {};
    }
}
function J(n) {
    Object.setPrototypeOf(this, {
        /**
     * Block id
     *
     * @returns {string}
     */ get id () {
            return n.id;
        },
        /**
     * Tool name
     *
     * @returns {string}
     */ get name () {
            return n.name;
        },
        /**
     * Tool config passed on Editor's initialization
     *
     * @returns {ToolConfig}
     */ get config () {
            return n.config;
        },
        /**
     * .ce-block element, that wraps plugin contents
     *
     * @returns {HTMLElement}
     */ get holder () {
            return n.holder;
        },
        /**
     * True if Block content is empty
     *
     * @returns {boolean}
     */ get isEmpty () {
            return n.isEmpty;
        },
        /**
     * True if Block is selected with Cross-Block selection
     *
     * @returns {boolean}
     */ get selected () {
            return n.selected;
        },
        /**
     * Set Block's stretch state
     *
     * @param {boolean} state — state to set
     */ set stretched (t){
            n.stretched = t;
        },
        /**
     * True if Block is stretched
     *
     * @returns {boolean}
     */ get stretched () {
            return n.stretched;
        },
        /**
     * True if Block has inputs to be focused
     */ get focusable () {
            return n.focusable;
        },
        /**
     * Call Tool method with errors handler under-the-hood
     *
     * @param {string} methodName - method to call
     * @param {object} param - object with parameters
     * @returns {unknown}
     */ call (t1, o) {
            return n.call(t1, o);
        },
        /**
     * Save Block content
     *
     * @returns {Promise<void|SavedData>}
     */ save () {
            return n.save();
        },
        /**
     * Validate Block data
     *
     * @param {BlockToolData} data - data to validate
     * @returns {Promise<boolean>}
     */ validate (t1) {
            return n.validate(t1);
        },
        /**
     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
     * Can be useful for block changes invisible for editor core.
     */ dispatchChange () {
            n.dispatchChange();
        },
        /**
     * Tool could specify several entries to be displayed at the Toolbox (for example, "Heading 1", "Heading 2", "Heading 3")
     * This method returns the entry that is related to the Block (depended on the Block data)
     */ getActiveToolboxEntry () {
            return n.getActiveToolboxEntry();
        }
    });
}
class _e {
    constructor(){
        this.allListeners = [];
    }
    /**
   * Assigns event listener on element and returns unique identifier
   *
   * @param {EventTarget} element - DOM element that needs to be listened
   * @param {string} eventType - event type
   * @param {Function} handler - method that will be fired on event
   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
   */ on(e, t1, o, i = !1) {
        const s = si("l"), r = {
            id: s,
            element: e,
            eventType: t1,
            handler: o,
            options: i
        };
        if (!this.findOne(e, t1, o)) return this.allListeners.push(r), e.addEventListener(t1, o, i), s;
    }
    /**
   * Removes event listener from element
   *
   * @param {EventTarget} element - DOM element that we removing listener
   * @param {string} eventType - event type
   * @param {Function} handler - remove handler, if element listens several handlers on the same event type
   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
   */ off(e, t1, o, i) {
        const s = this.findAll(e, t1, o);
        s.forEach((r, a)=>{
            const l = this.allListeners.indexOf(s[a]);
            l > -1 && (this.allListeners.splice(l, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));
        });
    }
    /**
   * Removes listener by id
   *
   * @param {string} id - listener identifier
   */ offById(e) {
        const t1 = this.findById(e);
        t1 && t1.element.removeEventListener(t1.eventType, t1.handler, t1.options);
    }
    /**
   * Finds and returns first listener by passed params
   *
   * @param {EventTarget} element - event target
   * @param {string} [eventType] - event type
   * @param {Function} [handler] - event handler
   * @returns {ListenerData|null}
   */ findOne(e, t1, o) {
        const i = this.findAll(e, t1, o);
        return i.length > 0 ? i[0] : null;
    }
    /**
   * Return all stored listeners by passed params
   *
   * @param {EventTarget} element - event target
   * @param {string} eventType - event type
   * @param {Function} handler - event handler
   * @returns {ListenerData[]}
   */ findAll(e, t1, o) {
        let i;
        const s = e ? this.findByEventTarget(e) : [];
        return e && t1 && o ? i = s.filter((r)=>r.eventType === t1 && r.handler === o) : e && t1 ? i = s.filter((r)=>r.eventType === t1) : i = s, i;
    }
    /**
   * Removes all listeners
   */ removeAll() {
        this.allListeners.map((e)=>{
            e.element.removeEventListener(e.eventType, e.handler, e.options);
        }), this.allListeners = [];
    }
    /**
   * Module cleanup on destruction
   */ destroy() {
        this.removeAll();
    }
    /**
   * Search method: looks for listener by passed element
   *
   * @param {EventTarget} element - searching element
   * @returns {Array} listeners that found on element
   */ findByEventTarget(e) {
        return this.allListeners.filter((t1)=>{
            if (t1.element === e) return t1;
        });
    }
    /**
   * Search method: looks for listener by passed event type
   *
   * @param {string} eventType - event type
   * @returns {ListenerData[]} listeners that found on element
   */ findByType(e) {
        return this.allListeners.filter((t1)=>{
            if (t1.eventType === e) return t1;
        });
    }
    /**
   * Search method: looks for listener by passed handler
   *
   * @param {Function} handler - event handler
   * @returns {ListenerData[]} listeners that found on element
   */ findByHandler(e) {
        return this.allListeners.filter((t1)=>{
            if (t1.handler === e) return t1;
        });
    }
    /**
   * Returns listener data found by id
   *
   * @param {string} id - listener identifier
   * @returns {ListenerData}
   */ findById(e) {
        return this.allListeners.find((t1)=>t1.id === e);
    }
}
class E {
    /**
   * @class
   * @param options - Module options
   * @param options.config - Module config
   * @param options.eventsDispatcher - Common event bus
   */ constructor({ config: e, eventsDispatcher: t1 }){
        if (this.nodes = {}, this.listeners = new _e(), this.readOnlyMutableListeners = {
            /**
       * Assigns event listener on DOM element and pushes into special array that might be removed
       *
       * @param {EventTarget} element - DOM Element
       * @param {string} eventType - Event name
       * @param {Function} handler - Event handler
       * @param {boolean|AddEventListenerOptions} options - Listening options
       */ on: (o, i, s, r = !1)=>{
                this.mutableListenerIds.push(this.listeners.on(o, i, s, r));
            },
            /**
       * Clears all mutable listeners
       */ clearAll: ()=>{
                for (const o of this.mutableListenerIds)this.listeners.offById(o);
                this.mutableListenerIds = [];
            }
        }, this.mutableListenerIds = [], new.target === E) throw new TypeError("Constructors for abstract class Module are not allowed.");
        this.config = e, this.eventsDispatcher = t1;
    }
    /**
   * Editor modules setter
   *
   * @param {EditorModules} Editor - Editor's Modules
   */ set state(e) {
        this.Editor = e;
    }
    /**
   * Remove memorized nodes
   */ removeAllNodes() {
        for(const e in this.nodes){
            const t1 = this.nodes[e];
            t1 instanceof HTMLElement && t1.remove();
        }
    }
    /**
   * Returns true if current direction is RTL (Right-To-Left)
   */ get isRtl() {
        return this.config.i18n.direction === "rtl";
    }
}
class b {
    constructor(){
        this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = !1, this.commandBackground = "backColor", this.commandRemoveFormat = "removeFormat";
    }
    /**
   * Editor styles
   *
   * @returns {{editorWrapper: string, editorZone: string}}
   */ static get CSS() {
        return {
            editorWrapper: "codex-editor",
            editorZone: "codex-editor__redactor"
        };
    }
    /**
   * Returns selected anchor
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}
   *
   * @returns {Node|null}
   */ static get anchorNode() {
        const e = window.getSelection();
        return e ? e.anchorNode : null;
    }
    /**
   * Returns selected anchor element
   *
   * @returns {Element|null}
   */ static get anchorElement() {
        const e = window.getSelection();
        if (!e) return null;
        const t1 = e.anchorNode;
        return t1 ? d.isElement(t1) ? t1 : t1.parentElement : null;
    }
    /**
   * Returns selection offset according to the anchor node
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}
   *
   * @returns {number|null}
   */ static get anchorOffset() {
        const e = window.getSelection();
        return e ? e.anchorOffset : null;
    }
    /**
   * Is current selection range collapsed
   *
   * @returns {boolean|null}
   */ static get isCollapsed() {
        const e = window.getSelection();
        return e ? e.isCollapsed : null;
    }
    /**
   * Check current selection if it is at Editor's zone
   *
   * @returns {boolean}
   */ static get isAtEditor() {
        return this.isSelectionAtEditor(b.get());
    }
    /**
   * Check if passed selection is at Editor's zone
   *
   * @param selection - Selection object to check
   */ static isSelectionAtEditor(e) {
        if (!e) return !1;
        let t1 = e.anchorNode || e.focusNode;
        t1 && t1.nodeType === Node.TEXT_NODE && (t1 = t1.parentNode);
        let o = null;
        return t1 && t1 instanceof Element && (o = t1.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;
    }
    /**
   * Check if passed range at Editor zone
   *
   * @param range - range to check
   */ static isRangeAtEditor(e) {
        if (!e) return;
        let t1 = e.startContainer;
        t1 && t1.nodeType === Node.TEXT_NODE && (t1 = t1.parentNode);
        let o = null;
        return t1 && t1 instanceof Element && (o = t1.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;
    }
    /**
   * Methods return boolean that true if selection exists on the page
   */ static get isSelectionExists() {
        return !!b.get().anchorNode;
    }
    /**
   * Return first range
   *
   * @returns {Range|null}
   */ static get range() {
        return this.getRangeFromSelection(this.get());
    }
    /**
   * Returns range from passed Selection object
   *
   * @param selection - Selection object to get Range from
   */ static getRangeFromSelection(e) {
        return e && e.rangeCount ? e.getRangeAt(0) : null;
    }
    /**
   * Calculates position and size of selected text
   *
   * @returns {DOMRect | ClientRect}
   */ static get rect() {
        let e = document.selection, t1, o = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        if (e && e.type !== "Control") return e = e, t1 = e.createRange(), o.x = t1.boundingLeft, o.y = t1.boundingTop, o.width = t1.boundingWidth, o.height = t1.boundingHeight, o;
        if (!window.getSelection) return S("Method window.getSelection is not supported", "warn"), o;
        if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount)) return S("Method SelectionUtils.rangeCount is not supported", "warn"), o;
        if (e.rangeCount === 0) return o;
        if (t1 = e.getRangeAt(0).cloneRange(), t1.getBoundingClientRect && (o = t1.getBoundingClientRect()), o.x === 0 && o.y === 0) {
            const i = document.createElement("span");
            if (i.getBoundingClientRect) {
                i.appendChild(document.createTextNode("​")), t1.insertNode(i), o = i.getBoundingClientRect();
                const s = i.parentNode;
                s.removeChild(i), s.normalize();
            }
        }
        return o;
    }
    /**
   * Returns selected text as String
   *
   * @returns {string}
   */ static get text() {
        return window.getSelection ? window.getSelection().toString() : "";
    }
    /**
   * Returns window SelectionUtils
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}
   *
   * @returns {Selection}
   */ static get() {
        return window.getSelection();
    }
    /**
   * Set focus to contenteditable or native input element
   *
   * @param element - element where to set focus
   * @param offset - offset of cursor
   */ static setCursor(e, t1 = 0) {
        const o = document.createRange(), i = window.getSelection();
        return d.isNativeInput(e) ? d.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t1, e.getBoundingClientRect()) : void 0 : (o.setStart(e, t1), o.setEnd(e, t1), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());
    }
    /**
   * Check if current range exists and belongs to container
   *
   * @param container - where range should be
   */ static isRangeInsideContainer(e) {
        const t1 = b.range;
        return t1 === null ? !1 : e.contains(t1.startContainer);
    }
    /**
   * Adds fake cursor to the current range
   */ static addFakeCursor() {
        const e = b.range;
        if (e === null) return;
        const t1 = d.make("span", "codex-editor__fake-cursor");
        t1.dataset.mutationFree = "true", e.collapse(), e.insertNode(t1);
    }
    /**
   * Check if passed element contains a fake cursor
   *
   * @param el - where to check
   */ static isFakeCursorInsideContainer(e) {
        return d.find(e, ".codex-editor__fake-cursor") !== null;
    }
    /**
   * Removes fake cursor from a container
   *
   * @param container - container to look for
   */ static removeFakeCursor(e = document.body) {
        const t1 = d.find(e, ".codex-editor__fake-cursor");
        t1 && t1.remove();
    }
    /**
   * Removes fake background
   */ removeFakeBackground() {
        this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = !1, document.execCommand(this.commandRemoveFormat));
    }
    /**
   * Sets fake background
   */ setFakeBackground() {
        document.execCommand(this.commandBackground, !1, "#a8d6ff"), this.isFakeBackgroundEnabled = !0;
    }
    /**
   * Save SelectionUtils's range
   */ save() {
        this.savedSelectionRange = b.range;
    }
    /**
   * Restore saved SelectionUtils's range
   */ restore() {
        if (!this.savedSelectionRange) return;
        const e = window.getSelection();
        e.removeAllRanges(), e.addRange(this.savedSelectionRange);
    }
    /**
   * Clears saved selection
   */ clearSaved() {
        this.savedSelectionRange = null;
    }
    /**
   * Collapse current selection
   */ collapseToEnd() {
        const e = window.getSelection(), t1 = document.createRange();
        t1.selectNodeContents(e.focusNode), t1.collapse(!1), e.removeAllRanges(), e.addRange(t1);
    }
    /**
   * Looks ahead to find passed tag from current selection
   *
   * @param  {string} tagName       - tag to found
   * @param  {string} [className]   - tag's class name
   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.
   * @returns {HTMLElement|null}
   */ findParentTag(e, t1, o = 10) {
        const i = window.getSelection();
        let s = null;
        return !i || !i.anchorNode || !i.focusNode ? null : ([
            /** the Node in which the selection begins */ i.anchorNode,
            /** the Node in which the selection ends */ i.focusNode
        ].forEach((a)=>{
            let l = o;
            for(; l > 0 && a.parentNode && !(a.tagName === e && (s = a, t1 && a.classList && !a.classList.contains(t1) && (s = null), s));)a = a.parentNode, l--;
        }), s);
    }
    /**
   * Expands selection range to the passed parent node
   *
   * @param {HTMLElement} element - element which contents should be selected
   */ expandToTag(e) {
        const t1 = window.getSelection();
        t1.removeAllRanges();
        const o = document.createRange();
        o.selectNodeContents(e), t1.addRange(o);
    }
}
function pi(n, e) {
    const { type: t1, target: o, addedNodes: i, removedNodes: s } = n;
    return n.type === "attributes" && n.attributeName === "data-empty" ? !1 : !!(e.contains(o) || t1 === "childList" && (Array.from(i).some((l)=>l === e) || Array.from(s).some((l)=>l === e)));
}
const ft = "redactor dom changed", $o = "block changed", zo = "fake cursor is about to be toggled", Uo = "fake cursor have been set", Te = "editor mobile layout toggled";
function gt(n, e) {
    if (!n.conversionConfig) return !1;
    const t1 = n.conversionConfig[e];
    return A(t1) || te(t1);
}
function He(n, e) {
    return gt(n.tool, e);
}
function Wo(n, e) {
    return Object.entries(n).some(([t1, o])=>e[t1] && ri(e[t1], o));
}
async function Yo(n, e) {
    const o = (await n.save()).data, i = e.find((s)=>s.name === n.name);
    return i !== void 0 && !gt(i, "export") ? [] : e.reduce((s, r)=>{
        if (!gt(r, "import") || r.toolbox === void 0) return s;
        const a = r.toolbox.filter((l)=>{
            if (V(l) || l.icon === void 0) return !1;
            if (l.data !== void 0) {
                if (Wo(l.data, o)) return !1;
            } else if (r.name === n.name) return !1;
            return !0;
        });
        return s.push({
            ...r,
            toolbox: a
        }), s;
    }, []);
}
function xo(n, e) {
    return n.mergeable ? n.name === e.name ? !0 : He(e, "export") && He(n, "import") : !1;
}
function fi(n, e) {
    const t1 = e == null ? void 0 : e.export;
    return A(t1) ? t1(n) : te(t1) ? n[t1] : (t1 !== void 0 && S("Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export."), "");
}
function Bo(n, e, t1) {
    const o = e == null ? void 0 : e.import;
    return A(o) ? o(n, t1) : te(o) ? {
        [o]: n
    } : (o !== void 0 && S("Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data."), {});
}
var _ = /* @__PURE__ */ ((n)=>(n.Default = "default", n.Separator = "separator", n.Html = "html", n))(_ || {}), ee = /* @__PURE__ */ ((n)=>(n.APPEND_CALLBACK = "appendCallback", n.RENDERED = "rendered", n.MOVED = "moved", n.UPDATED = "updated", n.REMOVED = "removed", n.ON_PASTE = "onPaste", n))(ee || {});
class R extends Oe {
    /**
   * @param options - block constructor options
   * @param [options.id] - block's id. Will be generated if omitted.
   * @param options.data - Tool's initial data
   * @param options.tool — block's tool
   * @param options.api - Editor API module for pass it to the Block Tunes
   * @param options.readOnly - Read-Only flag
   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when "virtual" Block is created. See BlocksAPI@composeBlockData.
   */ constructor({ id: e = ni(), data: t1, tool: o, readOnly: i, tunesData: s }, r){
        super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = ()=>{
            this.dropInputsCache(), this.updateCurrentInput();
        }, this.didMutated = (a = void 0)=>{
            const l = a === void 0, c = a instanceof InputEvent;
            !l && !c && this.detectToolRootChange(a);
            let u;
            l || c ? u = !0 : u = !(a.length > 0 && a.every((p)=>{
                const { addedNodes: g, removedNodes: f, target: v } = p;
                return [
                    ...Array.from(g),
                    ...Array.from(f),
                    v
                ].some((T)=>(d.isElement(T) || (T = T.parentElement), T && T.closest('[data-mutation-free="true"]') !== null));
            })), u && (this.dropInputsCache(), this.updateCurrentInput(), this.toggleInputsEmptyMark(), this.call("updated"), this.emit("didMutated", this));
        }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.editorEventBus = r || null, this.blockAPI = new J(this), this.tool = o, this.toolInstance = o.create(t1, this.blockAPI, i), this.tunes = o.tunes, this.composeTunes(s), this.holder = this.compose(), window.requestIdleCallback(()=>{
            this.watchBlockMutations(), this.addInputEvents(), this.toggleInputsEmptyMark();
        });
    }
    /**
   * CSS classes for the Block
   *
   * @returns {{wrapper: string, content: string}}
   */ static get CSS() {
        return {
            wrapper: "ce-block",
            wrapperStretched: "ce-block--stretched",
            content: "ce-block__content",
            selected: "ce-block--selected",
            dropTarget: "ce-block--drop-target"
        };
    }
    /**
   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML
   */ get inputs() {
        if (this.cachedInputs.length !== 0) return this.cachedInputs;
        const e = d.findAllInputs(this.holder);
        return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;
    }
    /**
   * Return current Tool`s input
   * If Block doesn't contain inputs, return undefined
   */ get currentInput() {
        return this.inputs[this.inputIndex];
    }
    /**
   * Set input index to the passed element
   *
   * @param element - HTML Element to set as current input
   */ set currentInput(e) {
        const t1 = this.inputs.findIndex((o)=>o === e || o.contains(e));
        t1 !== -1 && (this.inputIndex = t1);
    }
    /**
   * Return first Tool`s input
   * If Block doesn't contain inputs, return undefined
   */ get firstInput() {
        return this.inputs[0];
    }
    /**
   * Return first Tool`s input
   * If Block doesn't contain inputs, return undefined
   */ get lastInput() {
        const e = this.inputs;
        return e[e.length - 1];
    }
    /**
   * Return next Tool`s input or undefined if it doesn't exist
   * If Block doesn't contain inputs, return undefined
   */ get nextInput() {
        return this.inputs[this.inputIndex + 1];
    }
    /**
   * Return previous Tool`s input or undefined if it doesn't exist
   * If Block doesn't contain inputs, return undefined
   */ get previousInput() {
        return this.inputs[this.inputIndex - 1];
    }
    /**
   * Get Block's JSON data
   *
   * @returns {object}
   */ get data() {
        return this.save().then((e)=>e && !V(e.data) ? e.data : {});
    }
    /**
   * Returns tool's sanitizer config
   *
   * @returns {object}
   */ get sanitize() {
        return this.tool.sanitizeConfig;
    }
    /**
   * is block mergeable
   * We plugin have merge function then we call it mergeable
   *
   * @returns {boolean}
   */ get mergeable() {
        return A(this.toolInstance.merge);
    }
    /**
   * If Block contains inputs, it is focusable
   */ get focusable() {
        return this.inputs.length !== 0;
    }
    /**
   * Check block for emptiness
   *
   * @returns {boolean}
   */ get isEmpty() {
        const e = d.isEmpty(this.pluginsContent, "/"), t1 = !this.hasMedia;
        return e && t1;
    }
    /**
   * Check if block has a media content such as images, iframe and other
   *
   * @returns {boolean}
   */ get hasMedia() {
        const e = [
            "img",
            "iframe",
            "video",
            "audio",
            "source",
            "input",
            "textarea",
            "twitterwidget"
        ];
        return !!this.holder.querySelector(e.join(","));
    }
    /**
   * Set selected state
   * We don't need to mark Block as Selected when it is empty
   *
   * @param {boolean} state - 'true' to select, 'false' to remove selection
   */ set selected(e) {
        var i, s;
        this.holder.classList.toggle(R.CSS.selected, e);
        const t1 = e === !0 && b.isRangeInsideContainer(this.holder), o = e === !1 && b.isFakeCursorInsideContainer(this.holder);
        (t1 || o) && ((i = this.editorEventBus) == null || i.emit(zo, {
            state: e
        }), t1 ? b.addFakeCursor() : b.removeFakeCursor(this.holder), (s = this.editorEventBus) == null || s.emit(Uo, {
            state: e
        }));
    }
    /**
   * Returns True if it is Selected
   *
   * @returns {boolean}
   */ get selected() {
        return this.holder.classList.contains(R.CSS.selected);
    }
    /**
   * Set stretched state
   *
   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state
   */ set stretched(e) {
        this.holder.classList.toggle(R.CSS.wrapperStretched, e);
    }
    /**
   * Return Block's stretched state
   *
   * @returns {boolean}
   */ get stretched() {
        return this.holder.classList.contains(R.CSS.wrapperStretched);
    }
    /**
   * Toggle drop target state
   *
   * @param {boolean} state - 'true' if block is drop target, false otherwise
   */ set dropTarget(e) {
        this.holder.classList.toggle(R.CSS.dropTarget, e);
    }
    /**
   * Returns Plugins content
   *
   * @returns {HTMLElement}
   */ get pluginsContent() {
        return this.toolRenderedElement;
    }
    /**
   * Calls Tool's method
   *
   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function
   *
   * @param {string} methodName - method to call
   * @param {object} params - method argument
   */ call(e, t1) {
        if (A(this.toolInstance[e])) {
            e === "appendCallback" && S("`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead", "warn");
            try {
                this.toolInstance[e].call(this.toolInstance, t1);
            } catch (o) {
                S(`Error during '${e}' call: ${o.message}`, "error");
            }
        }
    }
    /**
   * Call plugins merge method
   *
   * @param {BlockToolData} data - data to merge
   */ async mergeWith(e) {
        await this.toolInstance.merge(e);
    }
    /**
   * Extracts data from Block
   * Groups Tool's save processing time
   *
   * @returns {object}
   */ async save() {
        const e = await this.toolInstance.save(this.pluginsContent), t1 = this.unavailableTunesData;
        [
            ...this.tunesInstances.entries(),
            ...this.defaultTunesInstances.entries()
        ].forEach(([s, r])=>{
            if (A(r.save)) try {
                t1[s] = r.save();
            } catch (a) {
                S(`Tune ${r.constructor.name} save method throws an Error %o`, "warn", a);
            }
        });
        const o = window.performance.now();
        let i;
        return Promise.resolve(e).then((s)=>(i = window.performance.now(), {
                id: this.id,
                tool: this.name,
                data: s,
                tunes: t1,
                time: i - o
            })).catch((s)=>{
            S(`Saving process for ${this.name} tool failed due to the ${s}`, "log", "red");
        });
    }
    /**
   * Uses Tool's validation method to check the correctness of output data
   * Tool's validation method is optional
   *
   * @description Method returns true|false whether data passed the validation or not
   * @param {BlockToolData} data - data to validate
   * @returns {Promise<boolean>} valid
   */ async validate(e) {
        let t1 = !0;
        return this.toolInstance.validate instanceof Function && (t1 = await this.toolInstance.validate(e)), t1;
    }
    /**
   * Returns data to render in Block Tunes menu.
   * Splits block tunes into 2 groups: block specific tunes and common tunes
   */ getTunes() {
        const e = [], t1 = [], o = typeof this.toolInstance.renderSettings == "function" ? this.toolInstance.renderSettings() : [];
        return d.isElement(o) ? e.push({
            type: _.Html,
            element: o
        }) : Array.isArray(o) ? e.push(...o) : e.push(o), [
            ...this.tunesInstances.values(),
            ...this.defaultTunesInstances.values()
        ].map((s)=>s.render()).forEach((s)=>{
            d.isElement(s) ? t1.push({
                type: _.Html,
                element: s
            }) : Array.isArray(s) ? t1.push(...s) : t1.push(s);
        }), {
            toolTunes: e,
            commonTunes: t1
        };
    }
    /**
   * Update current input index with selection anchor node
   */ updateCurrentInput() {
        this.currentInput = d.isNativeInput(document.activeElement) || !b.anchorNode ? document.activeElement : b.anchorNode;
    }
    /**
   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
   * Can be useful for block changes invisible for editor core.
   */ dispatchChange() {
        this.didMutated();
    }
    /**
   * Call Tool instance destroy method
   */ destroy() {
        this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), A(this.toolInstance.destroy) && this.toolInstance.destroy();
    }
    /**
   * Tool could specify several entries to be displayed at the Toolbox (for example, "Heading 1", "Heading 2", "Heading 3")
   * This method returns the entry that is related to the Block (depended on the Block data)
   */ async getActiveToolboxEntry() {
        const e = this.tool.toolbox;
        if (e.length === 1) return Promise.resolve(this.tool.toolbox[0]);
        const t1 = await this.data, o = e;
        return o == null ? void 0 : o.find((i)=>Wo(i.data, t1));
    }
    /**
   * Exports Block data as string using conversion config
   */ async exportDataAsString() {
        const e = await this.data;
        return fi(e, this.tool.conversionConfig);
    }
    /**
   * Make default Block wrappers and put Tool`s content there
   *
   * @returns {HTMLDivElement}
   */ compose() {
        const e = d.make("div", R.CSS.wrapper), t1 = d.make("div", R.CSS.content), o = this.toolInstance.render();
        e.setAttribute("data-cy", "block-wrapper"), e.dataset.id = this.id, this.toolRenderedElement = o, t1.appendChild(this.toolRenderedElement);
        let i = t1;
        return [
            ...this.tunesInstances.values(),
            ...this.defaultTunesInstances.values()
        ].forEach((s)=>{
            if (A(s.wrap)) try {
                i = s.wrap(i);
            } catch (r) {
                S(`Tune ${s.constructor.name} wrap method throws an Error %o`, "warn", r);
            }
        }), e.appendChild(i), e;
    }
    /**
   * Instantiate Block Tunes
   *
   * @param tunesData - current Block tunes data
   * @private
   */ composeTunes(e) {
        Array.from(this.tunes.values()).forEach((t1)=>{
            (t1.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t1.name, t1.create(e[t1.name], this.blockAPI));
        }), Object.entries(e).forEach(([t1, o])=>{
            this.tunesInstances.has(t1) || (this.unavailableTunesData[t1] = o);
        });
    }
    /**
   * Adds focus event listeners to all inputs and contenteditable
   */ addInputEvents() {
        this.inputs.forEach((e)=>{
            e.addEventListener("focus", this.handleFocus), d.isNativeInput(e) && e.addEventListener("input", this.didMutated);
        });
    }
    /**
   * removes focus event listeners from all inputs and contenteditable
   */ removeInputEvents() {
        this.inputs.forEach((e)=>{
            e.removeEventListener("focus", this.handleFocus), d.isNativeInput(e) && e.removeEventListener("input", this.didMutated);
        });
    }
    /**
   * Listen common editor Dom Changed event and detect mutations related to the  Block
   */ watchBlockMutations() {
        var e;
        this.redactorDomChangedCallback = (t1)=>{
            const { mutations: o } = t1;
            o.some((s)=>pi(s, this.toolRenderedElement)) && this.didMutated(o);
        }, (e = this.editorEventBus) == null || e.on(ft, this.redactorDomChangedCallback);
    }
    /**
   * Remove redactor dom change event listener
   */ unwatchBlockMutations() {
        var e;
        (e = this.editorEventBus) == null || e.off(ft, this.redactorDomChangedCallback);
    }
    /**
   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL
   * We need to detect such changes and update a link to tools main element with the new one
   *
   * @param mutations - records of block content mutations
   */ detectToolRootChange(e) {
        e.forEach((t1)=>{
            if (Array.from(t1.removedNodes).includes(this.toolRenderedElement)) {
                const i = t1.addedNodes[t1.addedNodes.length - 1];
                this.toolRenderedElement = i;
            }
        });
    }
    /**
   * Clears inputs cached value
   */ dropInputsCache() {
        this.cachedInputs = [];
    }
    /**
   * Mark inputs with 'data-empty' attribute with the empty state
   */ toggleInputsEmptyMark() {
        this.inputs.forEach(Do);
    }
}
class gi extends E {
    constructor(){
        super(...arguments), this.insert = (e = this.config.defaultBlock, t1 = {}, o = {}, i, s, r, a)=>{
            const l = this.Editor.BlockManager.insert({
                id: a,
                tool: e,
                data: t1,
                index: i,
                needToFocus: s,
                replace: r
            });
            return new J(l);
        }, this.composeBlockData = async (e)=>{
            const t1 = this.Editor.Tools.blockTools.get(e);
            return new R({
                tool: t1,
                api: this.Editor.API,
                readOnly: !0,
                data: {},
                tunesData: {}
            }).data;
        }, this.update = async (e, t1, o)=>{
            const { BlockManager: i } = this.Editor, s = i.getBlockById(e);
            if (s === void 0) throw new Error(`Block with id "${e}" not found`);
            const r = await i.update(s, t1, o);
            return new J(r);
        }, this.convert = async (e, t1, o)=>{
            var h, p;
            const { BlockManager: i, Tools: s } = this.Editor, r = i.getBlockById(e);
            if (!r) throw new Error(`Block with id "${e}" not found`);
            const a = s.blockTools.get(r.name), l = s.blockTools.get(t1);
            if (!l) throw new Error(`Block Tool with type "${t1}" not found`);
            const c = ((h = a == null ? void 0 : a.conversionConfig) == null ? void 0 : h.export) !== void 0, u = ((p = l.conversionConfig) == null ? void 0 : p.import) !== void 0;
            if (c && u) {
                const g = await i.convert(r, t1, o);
                return new J(g);
            } else {
                const g = [
                    c ? !1 : je(r.name),
                    u ? !1 : je(t1)
                ].filter(Boolean).join(" and ");
                throw new Error(`Conversion from "${r.name}" to "${t1}" is not possible. ${g} tool(s) should provide a "conversionConfig"`);
            }
        }, this.insertMany = (e, t1 = this.Editor.BlockManager.blocks.length - 1)=>{
            this.validateIndex(t1);
            const o = e.map(({ id: i, type: s, data: r })=>this.Editor.BlockManager.composeBlock({
                    id: i,
                    tool: s || this.config.defaultBlock,
                    data: r
                }));
            return this.Editor.BlockManager.insertMany(o, t1), o.map((i)=>new J(i));
        };
    }
    /**
   * Available methods
   *
   * @returns {Blocks}
   */ get methods() {
        return {
            clear: ()=>this.clear(),
            render: (e)=>this.render(e),
            renderFromHTML: (e)=>this.renderFromHTML(e),
            delete: (e)=>this.delete(e),
            swap: (e, t1)=>this.swap(e, t1),
            move: (e, t1)=>this.move(e, t1),
            getBlockByIndex: (e)=>this.getBlockByIndex(e),
            getById: (e)=>this.getById(e),
            getCurrentBlockIndex: ()=>this.getCurrentBlockIndex(),
            getBlockIndex: (e)=>this.getBlockIndex(e),
            getBlocksCount: ()=>this.getBlocksCount(),
            getBlockByElement: (e)=>this.getBlockByElement(e),
            stretchBlock: (e, t1 = !0)=>this.stretchBlock(e, t1),
            insertNewBlock: ()=>this.insertNewBlock(),
            insert: this.insert,
            insertMany: this.insertMany,
            update: this.update,
            composeBlockData: this.composeBlockData,
            convert: this.convert
        };
    }
    /**
   * Returns Blocks count
   *
   * @returns {number}
   */ getBlocksCount() {
        return this.Editor.BlockManager.blocks.length;
    }
    /**
   * Returns current block index
   *
   * @returns {number}
   */ getCurrentBlockIndex() {
        return this.Editor.BlockManager.currentBlockIndex;
    }
    /**
   * Returns the index of Block by id;
   *
   * @param id - block id
   */ getBlockIndex(e) {
        const t1 = this.Editor.BlockManager.getBlockById(e);
        if (!t1) {
            X("There is no block with id `" + e + "`", "warn");
            return;
        }
        return this.Editor.BlockManager.getBlockIndex(t1);
    }
    /**
   * Returns BlockAPI object by Block index
   *
   * @param {number} index - index to get
   */ getBlockByIndex(e) {
        const t1 = this.Editor.BlockManager.getBlockByIndex(e);
        if (t1 === void 0) {
            X("There is no block at index `" + e + "`", "warn");
            return;
        }
        return new J(t1);
    }
    /**
   * Returns BlockAPI object by Block id
   *
   * @param id - id of block to get
   */ getById(e) {
        const t1 = this.Editor.BlockManager.getBlockById(e);
        return t1 === void 0 ? (X("There is no block with id `" + e + "`", "warn"), null) : new J(t1);
    }
    /**
   * Get Block API object by any child html element
   *
   * @param element - html element to get Block by
   */ getBlockByElement(e) {
        const t1 = this.Editor.BlockManager.getBlock(e);
        if (t1 === void 0) {
            X("There is no block corresponding to element `" + e + "`", "warn");
            return;
        }
        return new J(t1);
    }
    /**
   * Call Block Manager method that swap Blocks
   *
   * @param {number} fromIndex - position of first Block
   * @param {number} toIndex - position of second Block
   * @deprecated — use 'move' instead
   */ swap(e, t1) {
        S("`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead", "info"), this.Editor.BlockManager.swap(e, t1);
    }
    /**
   * Move block from one index to another
   *
   * @param {number} toIndex - index to move to
   * @param {number} fromIndex - index to move from
   */ move(e, t1) {
        this.Editor.BlockManager.move(e, t1);
    }
    /**
   * Deletes Block
   *
   * @param {number} blockIndex - index of Block to delete
   */ delete(e = this.Editor.BlockManager.currentBlockIndex) {
        try {
            const t1 = this.Editor.BlockManager.getBlockByIndex(e);
            this.Editor.BlockManager.removeBlock(t1);
        } catch (t1) {
            X(t1, "warn");
            return;
        }
        this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();
    }
    /**
   * Clear Editor's area
   */ async clear() {
        await this.Editor.BlockManager.clear(!0), this.Editor.InlineToolbar.close();
    }
    /**
   * Fills Editor with Blocks data
   *
   * @param {OutputData} data — Saved Editor data
   */ async render(e) {
        if (e === void 0 || e.blocks === void 0) throw new Error("Incorrect data passed to the render() method");
        this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e.blocks), this.Editor.ModificationsObserver.enable();
    }
    /**
   * Render passed HTML string
   *
   * @param {string} data - HTML string to render
   * @returns {Promise<void>}
   */ renderFromHTML(e) {
        return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, !0);
    }
    /**
   * Stretch Block's content
   *
   * @param {number} index - index of Block to stretch
   * @param {boolean} status - true to enable, false to disable
   * @deprecated Use BlockAPI interface to stretch Blocks
   */ stretchBlock(e, t1 = !0) {
        ht(!0, "blocks.stretchBlock()", "BlockAPI");
        const o = this.Editor.BlockManager.getBlockByIndex(e);
        o && (o.stretched = t1);
    }
    /**
   * Insert new Block
   * After set caret to this Block
   *
   * @todo remove in 3.0.0
   * @deprecated with insert() method
   */ insertNewBlock() {
        S("Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.", "warn"), this.insert();
    }
    /**
   * Validated block index and throws an error if it's invalid
   *
   * @param index - index to validate
   */ validateIndex(e) {
        if (typeof e != "number") throw new Error("Index should be a number");
        if (e < 0) throw new Error("Index should be greater than or equal to 0");
        if (e === null) throw new Error("Index should be greater than or equal to 0");
    }
}
function mi(n, e) {
    return typeof n == "number" ? e.BlockManager.getBlockByIndex(n) : typeof n == "string" ? e.BlockManager.getBlockById(n) : e.BlockManager.getBlockById(n.id);
}
class bi extends E {
    constructor(){
        super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t1 = 0)=>this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t1), !0) : !1, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t1 = 0)=>this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t1), !0) : !1, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t1 = 0)=>this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t1), !0) : !1, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t1 = 0)=>this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t1), !0) : !1, this.setToBlock = (e, t1 = this.Editor.Caret.positions.DEFAULT, o = 0)=>{
            const i = mi(e, this.Editor);
            return i === void 0 ? !1 : (this.Editor.Caret.setToBlock(i, t1, o), !0);
        }, this.focus = (e = !1)=>e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);
    }
    /**
   * Available methods
   *
   * @returns {Caret}
   */ get methods() {
        return {
            setToFirstBlock: this.setToFirstBlock,
            setToLastBlock: this.setToLastBlock,
            setToPreviousBlock: this.setToPreviousBlock,
            setToNextBlock: this.setToNextBlock,
            setToBlock: this.setToBlock,
            focus: this.focus
        };
    }
}
class vi extends E {
    /**
   * Available methods
   *
   * @returns {Events}
   */ get methods() {
        return {
            emit: (e, t1)=>this.emit(e, t1),
            off: (e, t1)=>this.off(e, t1),
            on: (e, t1)=>this.on(e, t1)
        };
    }
    /**
   * Subscribe on Events
   *
   * @param {string} eventName - event name to subscribe
   * @param {Function} callback - event handler
   */ on(e, t1) {
        this.eventsDispatcher.on(e, t1);
    }
    /**
   * Emit event with data
   *
   * @param {string} eventName - event to emit
   * @param {object} data - event's data
   */ emit(e, t1) {
        this.eventsDispatcher.emit(e, t1);
    }
    /**
   * Unsubscribe from Event
   *
   * @param {string} eventName - event to unsubscribe
   * @param {Function} callback - event handler
   */ off(e, t1) {
        this.eventsDispatcher.off(e, t1);
    }
}
class kt extends E {
    /**
   * Return namespace section for tool or block tune
   *
   * @param toolName - tool name
   * @param isTune - is tool a block tune
   */ static getNamespace(e, t1) {
        return t1 ? `blockTunes.${e}` : `tools.${e}`;
    }
    /**
   * Return I18n API methods with global dictionary access
   */ get methods() {
        return {
            t: ()=>{
                X("I18n.t() method can be accessed only from Tools", "warn");
            }
        };
    }
    /**
   * Return I18n API methods with tool namespaced dictionary
   *
   * @param toolName - tool name
   * @param isTune - is tool a block tune
   */ getMethodsForTool(e, t1) {
        return Object.assign(this.methods, {
            t: (o)=>z.t(kt.getNamespace(e, t1), o)
        });
    }
}
class ki extends E {
    /**
   * Editor.js Core API modules
   */ get methods() {
        return {
            blocks: this.Editor.BlocksAPI.methods,
            caret: this.Editor.CaretAPI.methods,
            tools: this.Editor.ToolsAPI.methods,
            events: this.Editor.EventsAPI.methods,
            listeners: this.Editor.ListenersAPI.methods,
            notifier: this.Editor.NotifierAPI.methods,
            sanitizer: this.Editor.SanitizerAPI.methods,
            saver: this.Editor.SaverAPI.methods,
            selection: this.Editor.SelectionAPI.methods,
            styles: this.Editor.StylesAPI.classes,
            toolbar: this.Editor.ToolbarAPI.methods,
            inlineToolbar: this.Editor.InlineToolbarAPI.methods,
            tooltip: this.Editor.TooltipAPI.methods,
            i18n: this.Editor.I18nAPI.methods,
            readOnly: this.Editor.ReadOnlyAPI.methods,
            ui: this.Editor.UiAPI.methods
        };
    }
    /**
   * Returns Editor.js Core API methods for passed tool
   *
   * @param toolName - tool name
   * @param isTune - is tool a block tune
   */ getMethodsForTool(e, t1) {
        return Object.assign(this.methods, {
            i18n: this.Editor.I18nAPI.getMethodsForTool(e, t1)
        });
    }
}
class yi extends E {
    /**
   * Available methods
   *
   * @returns {InlineToolbar}
   */ get methods() {
        return {
            close: ()=>this.close(),
            open: ()=>this.open()
        };
    }
    /**
   * Open Inline Toolbar
   */ open() {
        this.Editor.InlineToolbar.tryToShow();
    }
    /**
   * Close Inline Toolbar
   */ close() {
        this.Editor.InlineToolbar.close();
    }
}
class wi extends E {
    /**
   * Available methods
   *
   * @returns {Listeners}
   */ get methods() {
        return {
            on: (e, t1, o, i)=>this.on(e, t1, o, i),
            off: (e, t1, o, i)=>this.off(e, t1, o, i),
            offById: (e)=>this.offById(e)
        };
    }
    /**
   * Ads a DOM event listener. Return it's id.
   *
   * @param {HTMLElement} element - Element to set handler to
   * @param {string} eventType - event type
   * @param {() => void} handler - event handler
   * @param {boolean} useCapture - capture event or not
   */ on(e, t1, o, i) {
        return this.listeners.on(e, t1, o, i);
    }
    /**
   * Removes DOM listener from element
   *
   * @param {Element} element - Element to remove handler from
   * @param eventType - event type
   * @param handler - event handler
   * @param {boolean} useCapture - capture event or not
   */ off(e, t1, o, i) {
        this.listeners.off(e, t1, o, i);
    }
    /**
   * Removes DOM listener by the listener id
   *
   * @param id - id of the listener to remove
   */ offById(e) {
        this.listeners.offById(e);
    }
}
var Ko = {
    exports: {}
};
(function(n, e) {
    (function(t1, o) {
        n.exports = o();
    })(window, function() {
        return function(t1) {
            var o = {};
            function i(s) {
                if (o[s]) return o[s].exports;
                var r = o[s] = {
                    i: s,
                    l: !1,
                    exports: {}
                };
                return t1[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;
            }
            return i.m = t1, i.c = o, i.d = function(s, r, a) {
                i.o(s, r) || Object.defineProperty(s, r, {
                    enumerable: !0,
                    get: a
                });
            }, i.r = function(s) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(s, "__esModule", {
                    value: !0
                });
            }, i.t = function(s, r) {
                if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == "object" && s && s.__esModule) return s;
                var a = /* @__PURE__ */ Object.create(null);
                if (i.r(a), Object.defineProperty(a, "default", {
                    enumerable: !0,
                    value: s
                }), 2 & r && typeof s != "string") for(var l in s)i.d(a, l, (function(c) {
                    return s[c];
                }).bind(null, l));
                return a;
            }, i.n = function(s) {
                var r = s && s.__esModule ? function() {
                    return s.default;
                } : function() {
                    return s;
                };
                return i.d(r, "a", r), r;
            }, i.o = function(s, r) {
                return Object.prototype.hasOwnProperty.call(s, r);
            }, i.p = "/", i(i.s = 0);
        }([
            function(t1, o, i) {
                i(1), /*!
       * Codex JavaScript Notification module
       * https://github.com/codex-team/js-notifier
       */ t1.exports = function() {
                    var s = i(6), r = "cdx-notify--bounce-in", a = null;
                    return {
                        show: function(l) {
                            if (l.message) {
                                (function() {
                                    if (a) return !0;
                                    a = s.getWrapper(), document.body.appendChild(a);
                                })();
                                var c = null, u = l.time || 8e3;
                                switch(l.type){
                                    case "confirm":
                                        c = s.confirm(l);
                                        break;
                                    case "prompt":
                                        c = s.prompt(l);
                                        break;
                                    default:
                                        c = s.alert(l), window.setTimeout(function() {
                                            c.remove();
                                        }, u);
                                }
                                a.appendChild(c), c.classList.add(r);
                            }
                        }
                    };
                }();
            },
            function(t1, o, i) {
                var s = i(2);
                typeof s == "string" && (s = [
                    [
                        t1.i,
                        s,
                        ""
                    ]
                ]);
                var r = {
                    hmr: !0,
                    transform: void 0,
                    insertInto: void 0
                };
                i(4)(s, r), s.locals && (t1.exports = s.locals);
            },
            function(t1, o, i) {
                (t1.exports = i(3)(!1)).push([
                    t1.i,
                    `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`,
                    ""
                ]);
            },
            function(t1, o) {
                t1.exports = function(i) {
                    var s = [];
                    return s.toString = function() {
                        return this.map(function(r) {
                            var a = function(l, c) {
                                var u = l[1] || "", h = l[3];
                                if (!h) return u;
                                if (c && typeof btoa == "function") {
                                    var p = (f = h, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(f)))) + " */"), g = h.sources.map(function(v) {
                                        return "/*# sourceURL=" + h.sourceRoot + v + " */";
                                    });
                                    return [
                                        u
                                    ].concat(g).concat([
                                        p
                                    ]).join(`
`);
                                }
                                var f;
                                return [
                                    u
                                ].join(`
`);
                            }(r, i);
                            return r[2] ? "@media " + r[2] + "{" + a + "}" : a;
                        }).join("");
                    }, s.i = function(r, a) {
                        typeof r == "string" && (r = [
                            [
                                null,
                                r,
                                ""
                            ]
                        ]);
                        for(var l = {}, c = 0; c < this.length; c++){
                            var u = this[c][0];
                            typeof u == "number" && (l[u] = !0);
                        }
                        for(c = 0; c < r.length; c++){
                            var h = r[c];
                            typeof h[0] == "number" && l[h[0]] || (a && !h[2] ? h[2] = a : a && (h[2] = "(" + h[2] + ") and (" + a + ")"), s.push(h));
                        }
                    }, s;
                };
            },
            function(t1, o, i) {
                var s, r, a = {}, l = (s = function() {
                    return window && document && document.all && !window.atob;
                }, function() {
                    return r === void 0 && (r = s.apply(this, arguments)), r;
                }), c = function(k) {
                    var m = {};
                    return function(w) {
                        if (typeof w == "function") return w();
                        if (m[w] === void 0) {
                            var x = (function(I) {
                                return document.querySelector(I);
                            }).call(this, w);
                            if (window.HTMLIFrameElement && x instanceof window.HTMLIFrameElement) try {
                                x = x.contentDocument.head;
                            } catch  {
                                x = null;
                            }
                            m[w] = x;
                        }
                        return m[w];
                    };
                }(), u = null, h = 0, p = [], g = i(5);
                function f(k, m) {
                    for(var w = 0; w < k.length; w++){
                        var x = k[w], I = a[x.id];
                        if (I) {
                            I.refs++;
                            for(var C = 0; C < I.parts.length; C++)I.parts[C](x.parts[C]);
                            for(; C < x.parts.length; C++)I.parts.push(F(x.parts[C], m));
                        } else {
                            var N = [];
                            for(C = 0; C < x.parts.length; C++)N.push(F(x.parts[C], m));
                            a[x.id] = {
                                id: x.id,
                                refs: 1,
                                parts: N
                            };
                        }
                    }
                }
                function v(k, m) {
                    for(var w = [], x = {}, I = 0; I < k.length; I++){
                        var C = k[I], N = m.base ? C[0] + m.base : C[0], B = {
                            css: C[1],
                            media: C[2],
                            sourceMap: C[3]
                        };
                        x[N] ? x[N].parts.push(B) : w.push(x[N] = {
                            id: N,
                            parts: [
                                B
                            ]
                        });
                    }
                    return w;
                }
                function O(k, m) {
                    var w = c(k.insertInto);
                    if (!w) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
                    var x = p[p.length - 1];
                    if (k.insertAt === "top") x ? x.nextSibling ? w.insertBefore(m, x.nextSibling) : w.appendChild(m) : w.insertBefore(m, w.firstChild), p.push(m);
                    else if (k.insertAt === "bottom") w.appendChild(m);
                    else {
                        if (typeof k.insertAt != "object" || !k.insertAt.before) throw new Error(`[Style Loader]

 Invalid value for parameter 'insertAt' ('options.insertAt') found.
 Must be 'top', 'bottom', or Object.
 (https://github.com/webpack-contrib/style-loader#insertat)
`);
                        var I = c(k.insertInto + " " + k.insertAt.before);
                        w.insertBefore(m, I);
                    }
                }
                function T(k) {
                    if (k.parentNode === null) return !1;
                    k.parentNode.removeChild(k);
                    var m = p.indexOf(k);
                    m >= 0 && p.splice(m, 1);
                }
                function M(k) {
                    var m = document.createElement("style");
                    return k.attrs.type === void 0 && (k.attrs.type = "text/css"), q(m, k.attrs), O(k, m), m;
                }
                function q(k, m) {
                    Object.keys(m).forEach(function(w) {
                        k.setAttribute(w, m[w]);
                    });
                }
                function F(k, m) {
                    var w, x, I, C;
                    if (m.transform && k.css) {
                        if (!(C = m.transform(k.css))) return function() {};
                        k.css = C;
                    }
                    if (m.singleton) {
                        var N = h++;
                        w = u || (u = M(m)), x = ie.bind(null, w, N, !1), I = ie.bind(null, w, N, !0);
                    } else k.sourceMap && typeof URL == "function" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob == "function" && typeof btoa == "function" ? (w = function(B) {
                        var W = document.createElement("link");
                        return B.attrs.type === void 0 && (B.attrs.type = "text/css"), B.attrs.rel = "stylesheet", q(W, B.attrs), O(B, W), W;
                    }(m), x = (function(B, W, ve) {
                        var se = ve.css, tt = ve.sourceMap, Yn = W.convertToAbsoluteUrls === void 0 && tt;
                        (W.convertToAbsoluteUrls || Yn) && (se = g(se)), tt && (se += `
/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(tt)))) + " */");
                        var Kn = new Blob([
                            se
                        ], {
                            type: "text/css"
                        }), ko = B.href;
                        B.href = URL.createObjectURL(Kn), ko && URL.revokeObjectURL(ko);
                    }).bind(null, w, m), I = function() {
                        T(w), w.href && URL.revokeObjectURL(w.href);
                    }) : (w = M(m), x = (function(B, W) {
                        var ve = W.css, se = W.media;
                        if (se && B.setAttribute("media", se), B.styleSheet) B.styleSheet.cssText = ve;
                        else {
                            for(; B.firstChild;)B.removeChild(B.firstChild);
                            B.appendChild(document.createTextNode(ve));
                        }
                    }).bind(null, w), I = function() {
                        T(w);
                    });
                    return x(k), function(B) {
                        if (B) {
                            if (B.css === k.css && B.media === k.media && B.sourceMap === k.sourceMap) return;
                            x(k = B);
                        } else I();
                    };
                }
                t1.exports = function(k, m) {
                    if (typeof DEBUG < "u" && DEBUG && typeof document != "object") throw new Error("The style-loader cannot be used in a non-browser environment");
                    (m = m || {}).attrs = typeof m.attrs == "object" ? m.attrs : {}, m.singleton || typeof m.singleton == "boolean" || (m.singleton = l()), m.insertInto || (m.insertInto = "head"), m.insertAt || (m.insertAt = "bottom");
                    var w = v(k, m);
                    return f(w, m), function(x) {
                        for(var I = [], C = 0; C < w.length; C++){
                            var N = w[C];
                            (B = a[N.id]).refs--, I.push(B);
                        }
                        for(x && f(v(x, m), m), C = 0; C < I.length; C++){
                            var B;
                            if ((B = I[C]).refs === 0) {
                                for(var W = 0; W < B.parts.length; W++)B.parts[W]();
                                delete a[B.id];
                            }
                        }
                    };
                };
                var H, Q = (H = [], function(k, m) {
                    return H[k] = m, H.filter(Boolean).join(`
`);
                });
                function ie(k, m, w, x) {
                    var I = w ? "" : x.css;
                    if (k.styleSheet) k.styleSheet.cssText = Q(m, I);
                    else {
                        var C = document.createTextNode(I), N = k.childNodes;
                        N[m] && k.removeChild(N[m]), N.length ? k.insertBefore(C, N[m]) : k.appendChild(C);
                    }
                }
            },
            function(t1, o) {
                t1.exports = function(i) {
                    var s = typeof window < "u" && window.location;
                    if (!s) throw new Error("fixUrls requires window.location");
                    if (!i || typeof i != "string") return i;
                    var r = s.protocol + "//" + s.host, a = r + s.pathname.replace(/\/[^\/]*$/, "/");
                    return i.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(l, c) {
                        var u, h = c.trim().replace(/^"(.*)"$/, function(p, g) {
                            return g;
                        }).replace(/^'(.*)'$/, function(p, g) {
                            return g;
                        });
                        return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(h) ? l : (u = h.indexOf("//") === 0 ? h : h.indexOf("/") === 0 ? r + h : a + h.replace(/^\.\//, ""), "url(" + JSON.stringify(u) + ")");
                    });
                };
            },
            function(t1, o, i) {
                var s, r, a, l, c, u, h, p, g;
                t1.exports = (s = "cdx-notifies", r = "cdx-notify", a = "cdx-notify__cross", l = "cdx-notify__button--confirm", c = "cdx-notify__button--cancel", u = "cdx-notify__input", h = "cdx-notify__button", p = "cdx-notify__btns-wrapper", {
                    alert: g = function(f) {
                        var v = document.createElement("DIV"), O = document.createElement("DIV"), T = f.message, M = f.style;
                        return v.classList.add(r), M && v.classList.add(r + "--" + M), v.innerHTML = T, O.classList.add(a), O.addEventListener("click", v.remove.bind(v)), v.appendChild(O), v;
                    },
                    confirm: function(f) {
                        var v = g(f), O = document.createElement("div"), T = document.createElement("button"), M = document.createElement("button"), q = v.querySelector("." + a), F = f.cancelHandler, H = f.okHandler;
                        return O.classList.add(p), T.innerHTML = f.okText || "Confirm", M.innerHTML = f.cancelText || "Cancel", T.classList.add(h), M.classList.add(h), T.classList.add(l), M.classList.add(c), F && typeof F == "function" && (M.addEventListener("click", F), q.addEventListener("click", F)), H && typeof H == "function" && T.addEventListener("click", H), T.addEventListener("click", v.remove.bind(v)), M.addEventListener("click", v.remove.bind(v)), O.appendChild(T), O.appendChild(M), v.appendChild(O), v;
                    },
                    prompt: function(f) {
                        var v = g(f), O = document.createElement("div"), T = document.createElement("button"), M = document.createElement("input"), q = v.querySelector("." + a), F = f.cancelHandler, H = f.okHandler;
                        return O.classList.add(p), T.innerHTML = f.okText || "Ok", T.classList.add(h), T.classList.add(l), M.classList.add(u), f.placeholder && M.setAttribute("placeholder", f.placeholder), f.default && (M.value = f.default), f.inputType && (M.type = f.inputType), F && typeof F == "function" && q.addEventListener("click", F), H && typeof H == "function" && T.addEventListener("click", function() {
                            H(M.value);
                        }), T.addEventListener("click", v.remove.bind(v)), O.appendChild(M), O.appendChild(T), v.appendChild(O), v;
                    },
                    getWrapper: function() {
                        var f = document.createElement("DIV");
                        return f.classList.add(s), f;
                    }
                });
            }
        ]);
    });
})(Ko);
var Ei = Ko.exports;
const xi = /* @__PURE__ */ Ke(Ei);
class Bi {
    /**
   * Show web notification
   *
   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options
   */ show(e) {
        xi.show(e);
    }
}
class Ci extends E {
    /**
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */ constructor({ config: e, eventsDispatcher: t1 }){
        super({
            config: e,
            eventsDispatcher: t1
        }), this.notifier = new Bi();
    }
    /**
   * Available methods
   */ get methods() {
        return {
            show: (e)=>this.show(e)
        };
    }
    /**
   * Show notification
   *
   * @param {NotifierOptions} options - message option
   */ show(e) {
        return this.notifier.show(e);
    }
}
class Ti extends E {
    /**
   * Available methods
   */ get methods() {
        const e = ()=>this.isEnabled;
        return {
            toggle: (t1)=>this.toggle(t1),
            get isEnabled () {
                return e();
            }
        };
    }
    /**
   * Set or toggle read-only state
   *
   * @param {boolean|undefined} state - set or toggle state
   * @returns {boolean} current value
   */ toggle(e) {
        return this.Editor.ReadOnly.toggle(e);
    }
    /**
   * Returns current read-only state
   */ get isEnabled() {
        return this.Editor.ReadOnly.isEnabled;
    }
}
var Xo = {
    exports: {}
};
(function(n, e) {
    (function(t1, o) {
        n.exports = o();
    })(Ce, function() {
        function t1(h) {
            var p = h.tags, g = Object.keys(p), f = g.map(function(v) {
                return typeof p[v];
            }).every(function(v) {
                return v === "object" || v === "boolean" || v === "function";
            });
            if (!f) throw new Error("The configuration was invalid");
            this.config = h;
        }
        var o = [
            "P",
            "LI",
            "TD",
            "TH",
            "DIV",
            "H1",
            "H2",
            "H3",
            "H4",
            "H5",
            "H6",
            "PRE"
        ];
        function i(h) {
            return o.indexOf(h.nodeName) !== -1;
        }
        var s = [
            "A",
            "B",
            "STRONG",
            "I",
            "EM",
            "SUB",
            "SUP",
            "U",
            "STRIKE"
        ];
        function r(h) {
            return s.indexOf(h.nodeName) !== -1;
        }
        t1.prototype.clean = function(h) {
            const p = document.implementation.createHTMLDocument(), g = p.createElement("div");
            return g.innerHTML = h, this._sanitize(p, g), g.innerHTML;
        }, t1.prototype._sanitize = function(h, p) {
            var g = a(h, p), f = g.firstChild();
            if (f) do {
                if (f.nodeType === Node.TEXT_NODE) if (f.data.trim() === "" && (f.previousElementSibling && i(f.previousElementSibling) || f.nextElementSibling && i(f.nextElementSibling))) {
                    p.removeChild(f), this._sanitize(h, p);
                    break;
                } else continue;
                if (f.nodeType === Node.COMMENT_NODE) {
                    p.removeChild(f), this._sanitize(h, p);
                    break;
                }
                var v = r(f), O;
                v && (O = Array.prototype.some.call(f.childNodes, i));
                var T = !!p.parentNode, M = i(p) && i(f) && T, q = f.nodeName.toLowerCase(), F = l(this.config, q, f), H = v && O;
                if (H || c(f, F) || !this.config.keepNestedBlockElements && M) {
                    if (!(f.nodeName === "SCRIPT" || f.nodeName === "STYLE")) for(; f.childNodes.length > 0;)p.insertBefore(f.childNodes[0], f);
                    p.removeChild(f), this._sanitize(h, p);
                    break;
                }
                for(var Q = 0; Q < f.attributes.length; Q += 1){
                    var ie = f.attributes[Q];
                    u(ie, F, f) && (f.removeAttribute(ie.name), Q = Q - 1);
                }
                this._sanitize(h, f);
            }while (f = g.nextSibling())
        };
        function a(h, p) {
            return h.createTreeWalker(p, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null, !1);
        }
        function l(h, p, g) {
            return typeof h.tags[p] == "function" ? h.tags[p](g) : h.tags[p];
        }
        function c(h, p) {
            return typeof p > "u" ? !0 : typeof p == "boolean" ? !p : !1;
        }
        function u(h, p, g) {
            var f = h.name.toLowerCase();
            return p === !0 ? !1 : typeof p[f] == "function" ? !p[f](h.value, g) : typeof p[f] > "u" || p[f] === !1 ? !0 : typeof p[f] == "string" ? p[f] !== h.value : !1;
        }
        return t1;
    });
})(Xo);
var Si = Xo.exports;
const Ii = /* @__PURE__ */ Ke(Si);
function yt(n, e) {
    return n.map((t1)=>{
        const o = A(e) ? e(t1.tool) : e;
        return V(o) || (t1.data = wt(t1.data, o)), t1;
    });
}
function Z(n, e = {}) {
    const t1 = {
        tags: e
    };
    return new Ii(t1).clean(n);
}
function wt(n, e) {
    return Array.isArray(n) ? Oi(n, e) : D(n) ? _i(n, e) : te(n) ? Mi(n, e) : n;
}
function Oi(n, e) {
    return n.map((t1)=>wt(t1, e));
}
function _i(n, e) {
    const t1 = {};
    for(const o in n){
        if (!Object.prototype.hasOwnProperty.call(n, o)) continue;
        const i = n[o], s = Ai(e[o]) ? e[o] : e;
        t1[o] = wt(i, s);
    }
    return t1;
}
function Mi(n, e) {
    return D(e) ? Z(n, e) : e === !1 ? Z(n, {}) : n;
}
function Ai(n) {
    return D(n) || Gn(n) || A(n);
}
class Li extends E {
    /**
   * Available methods
   *
   * @returns {SanitizerConfig}
   */ get methods() {
        return {
            clean: (e, t1)=>this.clean(e, t1)
        };
    }
    /**
   * Perform sanitizing of a string
   *
   * @param {string} taintString - what to sanitize
   * @param {SanitizerConfig} config - sanitizer config
   * @returns {string}
   */ clean(e, t1) {
        return Z(e, t1);
    }
}
class Pi extends E {
    /**
   * Available methods
   *
   * @returns {Saver}
   */ get methods() {
        return {
            save: ()=>this.save()
        };
    }
    /**
   * Return Editor's data
   *
   * @returns {OutputData}
   */ save() {
        const e = "Editor's content can not be saved in read-only mode";
        return this.Editor.ReadOnly.isEnabled ? (X(e, "warn"), Promise.reject(new Error(e))) : this.Editor.Saver.save();
    }
}
class Ni extends E {
    constructor(){
        super(...arguments), this.selectionUtils = new b();
    }
    /**
   * Available methods
   *
   * @returns {SelectionAPIInterface}
   */ get methods() {
        return {
            findParentTag: (e, t1)=>this.findParentTag(e, t1),
            expandToTag: (e)=>this.expandToTag(e),
            save: ()=>this.selectionUtils.save(),
            restore: ()=>this.selectionUtils.restore(),
            setFakeBackground: ()=>this.selectionUtils.setFakeBackground(),
            removeFakeBackground: ()=>this.selectionUtils.removeFakeBackground()
        };
    }
    /**
   * Looks ahead from selection and find passed tag with class name
   *
   * @param {string} tagName - tag to find
   * @param {string} className - tag's class name
   * @returns {HTMLElement|null}
   */ findParentTag(e, t1) {
        return this.selectionUtils.findParentTag(e, t1);
    }
    /**
   * Expand selection to passed tag
   *
   * @param {HTMLElement} node - tag that should contain selection
   */ expandToTag(e) {
        this.selectionUtils.expandToTag(e);
    }
}
class Ri extends E {
    /**
   * Available methods
   */ get methods() {
        return {
            getBlockTools: ()=>Array.from(this.Editor.Tools.blockTools.values())
        };
    }
}
class Di extends E {
    /**
   * Exported classes
   */ get classes() {
        return {
            /**
       * Base Block styles
       */ block: "cdx-block",
            /**
       * Inline Tools styles
       */ inlineToolButton: "ce-inline-tool",
            inlineToolButtonActive: "ce-inline-tool--active",
            /**
       * UI elements
       */ input: "cdx-input",
            loader: "cdx-loader",
            button: "cdx-button",
            /**
       * Settings styles
       */ settingsButton: "cdx-settings-button",
            settingsButtonActive: "cdx-settings-button--active"
        };
    }
}
class Fi extends E {
    /**
   * Available methods
   *
   * @returns {Toolbar}
   */ get methods() {
        return {
            close: ()=>this.close(),
            open: ()=>this.open(),
            toggleBlockSettings: (e)=>this.toggleBlockSettings(e),
            toggleToolbox: (e)=>this.toggleToolbox(e)
        };
    }
    /**
   * Open toolbar
   */ open() {
        this.Editor.Toolbar.moveAndOpen();
    }
    /**
   * Close toolbar and all included elements
   */ close() {
        this.Editor.Toolbar.close();
    }
    /**
   * Toggles Block Setting of the current block
   *
   * @param {boolean} openingState —  opening state of Block Setting
   */ toggleBlockSettings(e) {
        if (this.Editor.BlockManager.currentBlockIndex === -1) {
            X("Could't toggle the Toolbar because there is no block selected ", "warn");
            return;
        }
        e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();
    }
    /**
   * Open toolbox
   *
   * @param {boolean} openingState - Opening state of toolbox
   */ toggleToolbox(e) {
        if (this.Editor.BlockManager.currentBlockIndex === -1) {
            X("Could't toggle the Toolbox because there is no block selected ", "warn");
            return;
        }
        e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();
    }
}
var Vo = {
    exports: {}
};
/*!
 * CodeX.Tooltips
 * 
 * @version 1.0.5
 * 
 * @licence MIT
 * @author CodeX <https://codex.so>
 * 
 * 
 */ (function(n, e) {
    (function(t1, o) {
        n.exports = o();
    })(window, function() {
        return function(t1) {
            var o = {};
            function i(s) {
                if (o[s]) return o[s].exports;
                var r = o[s] = {
                    i: s,
                    l: !1,
                    exports: {}
                };
                return t1[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;
            }
            return i.m = t1, i.c = o, i.d = function(s, r, a) {
                i.o(s, r) || Object.defineProperty(s, r, {
                    enumerable: !0,
                    get: a
                });
            }, i.r = function(s) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(s, "__esModule", {
                    value: !0
                });
            }, i.t = function(s, r) {
                if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == "object" && s && s.__esModule) return s;
                var a = /* @__PURE__ */ Object.create(null);
                if (i.r(a), Object.defineProperty(a, "default", {
                    enumerable: !0,
                    value: s
                }), 2 & r && typeof s != "string") for(var l in s)i.d(a, l, (function(c) {
                    return s[c];
                }).bind(null, l));
                return a;
            }, i.n = function(s) {
                var r = s && s.__esModule ? function() {
                    return s.default;
                } : function() {
                    return s;
                };
                return i.d(r, "a", r), r;
            }, i.o = function(s, r) {
                return Object.prototype.hasOwnProperty.call(s, r);
            }, i.p = "", i(i.s = 0);
        }([
            function(t1, o, i) {
                t1.exports = i(1);
            },
            function(t1, o, i) {
                i.r(o), i.d(o, "default", function() {
                    return s;
                });
                class s {
                    constructor(){
                        this.nodes = {
                            wrapper: null,
                            content: null
                        }, this.showed = !1, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = ()=>{
                            this.showed && this.hide(!0);
                        }, this.loadStyles(), this.prepare(), window.addEventListener("scroll", this.handleWindowScroll, {
                            passive: !0
                        });
                    }
                    get CSS() {
                        return {
                            tooltip: "ct",
                            tooltipContent: "ct__content",
                            tooltipShown: "ct--shown",
                            placement: {
                                left: "ct--left",
                                bottom: "ct--bottom",
                                right: "ct--right",
                                top: "ct--top"
                            }
                        };
                    }
                    show(a, l, c) {
                        this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);
                        const u = Object.assign({
                            placement: "bottom",
                            marginTop: 0,
                            marginLeft: 0,
                            marginRight: 0,
                            marginBottom: 0,
                            delay: 70,
                            hidingDelay: 0
                        }, c);
                        if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = "", typeof l == "string") this.nodes.content.appendChild(document.createTextNode(l));
                        else {
                            if (!(l instanceof Node)) throw Error("[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But " + typeof l + " given.");
                            this.nodes.content.appendChild(l);
                        }
                        switch(this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement){
                            case "top":
                                this.placeTop(a, u);
                                break;
                            case "left":
                                this.placeLeft(a, u);
                                break;
                            case "right":
                                this.placeRight(a, u);
                                break;
                            case "bottom":
                            default:
                                this.placeBottom(a, u);
                        }
                        u && u.delay ? this.showingTimeout = setTimeout(()=>{
                            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0;
                        }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0);
                    }
                    hide(a = !1) {
                        if (this.hidingDelay && !a) return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(()=>{
                            this.hide(!0);
                        }, this.hidingDelay));
                        this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = !1, this.showingTimeout && clearTimeout(this.showingTimeout);
                    }
                    onHover(a, l, c) {
                        a.addEventListener("mouseenter", ()=>{
                            this.show(a, l, c);
                        }), a.addEventListener("mouseleave", ()=>{
                            this.hide();
                        });
                    }
                    destroy() {
                        this.nodes.wrapper.remove(), window.removeEventListener("scroll", this.handleWindowScroll);
                    }
                    prepare() {
                        this.nodes.wrapper = this.make("div", this.CSS.tooltip), this.nodes.content = this.make("div", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);
                    }
                    loadStyles() {
                        const a = "codex-tooltips-style";
                        if (document.getElementById(a)) return;
                        const l = i(2), c = this.make("style", null, {
                            textContent: l.toString(),
                            id: a
                        });
                        this.prepend(document.head, c);
                    }
                    placeBottom(a, l) {
                        const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.bottom + window.pageYOffset + this.offsetTop + l.marginTop;
                        this.applyPlacement("bottom", u, h);
                    }
                    placeTop(a, l) {
                        const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;
                        this.applyPlacement("top", u, h);
                    }
                    placeLeft(a, l) {
                        const c = a.getBoundingClientRect(), u = c.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l.marginLeft, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
                        this.applyPlacement("left", u, h);
                    }
                    placeRight(a, l) {
                        const c = a.getBoundingClientRect(), u = c.right + this.offsetRight + l.marginRight, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
                        this.applyPlacement("right", u, h);
                    }
                    applyPlacement(a, l, c) {
                        this.nodes.wrapper.classList.add(this.CSS.placement[a]), this.nodes.wrapper.style.left = l + "px", this.nodes.wrapper.style.top = c + "px";
                    }
                    make(a, l = null, c = {}) {
                        const u = document.createElement(a);
                        Array.isArray(l) ? u.classList.add(...l) : l && u.classList.add(l);
                        for(const h in c)c.hasOwnProperty(h) && (u[h] = c[h]);
                        return u;
                    }
                    append(a, l) {
                        Array.isArray(l) ? l.forEach((c)=>a.appendChild(c)) : a.appendChild(l);
                    }
                    prepend(a, l) {
                        Array.isArray(l) ? (l = l.reverse()).forEach((c)=>a.prepend(c)) : a.prepend(l);
                    }
                }
            },
            function(t1, o) {
                t1.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:"";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url("")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:"";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;
            }
        ]).default;
    });
})(Vo);
var ji = Vo.exports;
const Hi = /* @__PURE__ */ Ke(ji);
let U = null;
function Et() {
    U || (U = new Hi());
}
function $i(n, e, t1) {
    Et(), U == null || U.show(n, e, t1);
}
function $e(n = !1) {
    Et(), U == null || U.hide(n);
}
function ze(n, e, t1) {
    Et(), U == null || U.onHover(n, e, t1);
}
function zi() {
    U == null || U.destroy(), U = null;
}
class Ui extends E {
    /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */ constructor({ config: e, eventsDispatcher: t1 }){
        super({
            config: e,
            eventsDispatcher: t1
        });
    }
    /**
   * Available methods
   */ get methods() {
        return {
            show: (e, t1, o)=>this.show(e, t1, o),
            hide: ()=>this.hide(),
            onHover: (e, t1, o)=>this.onHover(e, t1, o)
        };
    }
    /**
   * Method show tooltip on element with passed HTML content
   *
   * @param {HTMLElement} element - element on which tooltip should be shown
   * @param {TooltipContent} content - tooltip content
   * @param {TooltipOptions} options - tooltip options
   */ show(e, t1, o) {
        $i(e, t1, o);
    }
    /**
   * Method hides tooltip on HTML page
   */ hide() {
        $e();
    }
    /**
   * Decorator for showing Tooltip by mouseenter/mouseleave
   *
   * @param {HTMLElement} element - element on which tooltip should be shown
   * @param {TooltipContent} content - tooltip content
   * @param {TooltipOptions} options - tooltip options
   */ onHover(e, t1, o) {
        ze(e, t1, o);
    }
}
class Wi extends E {
    /**
   * Available methods / getters
   */ get methods() {
        return {
            nodes: this.editorNodes
        };
    }
    /**
   * Exported classes
   */ get editorNodes() {
        return {
            /**
       * Top-level editor instance wrapper
       */ wrapper: this.Editor.UI.nodes.wrapper,
            /**
       * Element that holds all the Blocks
       */ redactor: this.Editor.UI.nodes.redactor
        };
    }
}
function qo(n, e) {
    const t1 = {};
    return Object.entries(n).forEach(([o, i])=>{
        if (D(i)) {
            const s = e ? `${e}.${o}` : o;
            Object.values(i).every((a)=>te(a)) ? t1[o] = s : t1[o] = qo(i, s);
            return;
        }
        t1[o] = i;
    }), t1;
}
const K = qo(Fo);
function Yi(n, e) {
    const t1 = {};
    return Object.keys(n).forEach((o)=>{
        const i = e[o];
        i !== void 0 ? t1[i] = n[o] : t1[o] = n[o];
    }), t1;
}
const Zo = class Ee {
    /**
   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items
   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process
   */ constructor(e, t1){
        this.cursor = -1, this.items = [], this.items = e || [], this.focusedCssClass = t1;
    }
    /**
   * Returns Focused button Node
   *
   * @returns {HTMLElement}
   */ get currentItem() {
        return this.cursor === -1 ? null : this.items[this.cursor];
    }
    /**
   * Sets cursor to specified position
   *
   * @param cursorPosition - new cursor position
   */ setCursor(e) {
        e < this.items.length && e >= -1 && (this.dropCursor(), this.cursor = e, this.items[this.cursor].classList.add(this.focusedCssClass));
    }
    /**
   * Sets items. Can be used when iterable items changed dynamically
   *
   * @param {HTMLElement[]} nodeList - nodes to iterate
   */ setItems(e) {
        this.items = e;
    }
    /**
   * Sets cursor next to the current
   */ next() {
        this.cursor = this.leafNodesAndReturnIndex(Ee.directions.RIGHT);
    }
    /**
   * Sets cursor before current
   */ previous() {
        this.cursor = this.leafNodesAndReturnIndex(Ee.directions.LEFT);
    }
    /**
   * Sets cursor to the default position and removes CSS-class from previously focused item
   */ dropCursor() {
        this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);
    }
    /**
   * Leafs nodes inside the target list from active element
   *
   * @param {string} direction - leaf direction. Can be 'left' or 'right'
   * @returns {number} index of focused node
   */ leafNodesAndReturnIndex(e) {
        if (this.items.length === 0) return this.cursor;
        let t1 = this.cursor;
        return t1 === -1 ? t1 = e === Ee.directions.RIGHT ? -1 : 0 : this.items[t1].classList.remove(this.focusedCssClass), e === Ee.directions.RIGHT ? t1 = (t1 + 1) % this.items.length : t1 = (this.items.length + t1 - 1) % this.items.length, d.canSetCaret(this.items[t1]) && Fe(()=>b.setCursor(this.items[t1]), 50)(), this.items[t1].classList.add(this.focusedCssClass), t1;
    }
};
Zo.directions = {
    RIGHT: "right",
    LEFT: "left"
};
let ke = Zo;
class ce {
    /**
   * @param options - different constructing settings
   */ constructor(e){
        this.iterator = null, this.activated = !1, this.flipCallbacks = [], this.onKeyDown = (t1)=>{
            if (this.isEventReadyForHandling(t1)) switch(ce.usedKeys.includes(t1.keyCode) && t1.preventDefault(), t1.keyCode){
                case y.TAB:
                    this.handleTabPress(t1);
                    break;
                case y.LEFT:
                case y.UP:
                    this.flipLeft();
                    break;
                case y.RIGHT:
                case y.DOWN:
                    this.flipRight();
                    break;
                case y.ENTER:
                    this.handleEnterPress(t1);
                    break;
            }
        }, this.iterator = new ke(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || ce.usedKeys;
    }
    /**
   * True if flipper is currently activated
   */ get isActivated() {
        return this.activated;
    }
    /**
   * Array of keys (codes) that is handled by Flipper
   * Used to:
   *  - preventDefault only for this keys, not all keydowns (@see constructor)
   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)
   */ static get usedKeys() {
        return [
            y.TAB,
            y.LEFT,
            y.RIGHT,
            y.ENTER,
            y.UP,
            y.DOWN
        ];
    }
    /**
   * Active tab/arrows handling by flipper
   *
   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically
   * @param cursorPosition - index of the item that should be focused once flipper is activated
   */ activate(e, t1) {
        this.activated = !0, e && this.iterator.setItems(e), t1 !== void 0 && this.iterator.setCursor(t1), document.addEventListener("keydown", this.onKeyDown, !0);
    }
    /**
   * Disable tab/arrows handling by flipper
   */ deactivate() {
        this.activated = !1, this.dropCursor(), document.removeEventListener("keydown", this.onKeyDown);
    }
    /**
   * Focus first item
   */ focusFirst() {
        this.dropCursor(), this.flipRight();
    }
    /**
   * Focuses previous flipper iterator item
   */ flipLeft() {
        this.iterator.previous(), this.flipCallback();
    }
    /**
   * Focuses next flipper iterator item
   */ flipRight() {
        this.iterator.next(), this.flipCallback();
    }
    /**
   * Return true if some button is focused
   */ hasFocus() {
        return !!this.iterator.currentItem;
    }
    /**
   * Registeres function that should be executed on each navigation action
   *
   * @param cb - function to execute
   */ onFlip(e) {
        this.flipCallbacks.push(e);
    }
    /**
   * Unregisteres function that is executed on each navigation action
   *
   * @param cb - function to stop executing
   */ removeOnFlip(e) {
        this.flipCallbacks = this.flipCallbacks.filter((t1)=>t1 !== e);
    }
    /**
   * Drops flipper's iterator cursor
   *
   * @see DomIterator#dropCursor
   */ dropCursor() {
        this.iterator.dropCursor();
    }
    /**
   * This function is fired before handling flipper keycodes
   * The result of this function defines if it is need to be handled or not
   *
   * @param {KeyboardEvent} event - keydown keyboard event
   * @returns {boolean}
   */ isEventReadyForHandling(e) {
        return this.activated && this.allowedKeys.includes(e.keyCode);
    }
    /**
   * When flipper is activated tab press will leaf the items
   *
   * @param {KeyboardEvent} event - tab keydown event
   */ handleTabPress(e) {
        switch(e.shiftKey ? ke.directions.LEFT : ke.directions.RIGHT){
            case ke.directions.RIGHT:
                this.flipRight();
                break;
            case ke.directions.LEFT:
                this.flipLeft();
                break;
        }
    }
    /**
   * Enter press will click current item if flipper is activated
   *
   * @param {KeyboardEvent} event - enter keydown event
   */ handleEnterPress(e) {
        this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), A(this.activateCallback) && this.activateCallback(this.iterator.currentItem));
    }
    /**
   * Fired after flipping in any direction
   */ flipCallback() {
        this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e)=>e());
    }
}
const Ki = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11"/></svg>', Xi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10"/></svg>', Vi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.5 17.5L9.64142 12.6414C9.56331 12.5633 9.56331 12.4367 9.64142 12.3586L14.5 7.5"/></svg>', qi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.58284 17.5L14.4414 12.6414C14.5195 12.5633 14.5195 12.4367 14.4414 12.3586L9.58284 7.5"/></svg>', Zi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15"/></svg>', Gi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>', Qi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/></svg>', Ji = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13.34 10C12.4223 12.7337 11 17 11 17"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.21 7H14.2"/></svg>', Co = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72"/></svg>', es = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 7.29999H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 7.29999H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.30999 12H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 12H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 16.7H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 16.7H14.59"/></svg>', ts = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>', Go = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M11.5 17.5L5 11M5 11V15.5M5 11H9.5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12.5 6.5L19 13M19 13V8.5M19 13H14.5"/></svg>', os = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="10.5" cy="10.5" r="5.5" stroke="currentColor" stroke-width="2"/><line x1="15.4142" x2="19" y1="15" y2="18.5858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', ns = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397"/><line x1="12.1142" x2="11.7" y1="12.2" y2="11.7858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', is = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><line x1="12" x2="12" y1="9" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 15.02V15.01"/></svg>', ss = "__", rs = "--";
function ne(n) {
    return (e, t1)=>[
            [
                n,
                e
            ].filter((i)=>!!i).join(ss),
            t1
        ].filter((i)=>!!i).join(rs);
}
const ye = ne("ce-hint"), we = {
    root: ye(),
    alignedStart: ye(null, "align-left"),
    alignedCenter: ye(null, "align-center"),
    title: ye("title"),
    description: ye("description")
};
class as {
    /**
   * Constructs the hint content instance
   *
   * @param params - hint content parameters
   */ constructor(e){
        this.nodes = {
            root: d.make("div", [
                we.root,
                e.alignment === "center" ? we.alignedCenter : we.alignedStart
            ]),
            title: d.make("div", we.title, {
                textContent: e.title
            })
        }, this.nodes.root.appendChild(this.nodes.title), e.description !== void 0 && (this.nodes.description = d.make("div", we.description, {
            textContent: e.description
        }), this.nodes.root.appendChild(this.nodes.description));
    }
    /**
   * Returns the root element of the hint content
   */ getElement() {
        return this.nodes.root;
    }
}
class xt {
    /**
   * Constructs the instance
   *
   * @param params - instance parameters
   */ constructor(e){
        this.params = e;
    }
    /**
   * Item name if exists
   */ get name() {
        if (this.params !== void 0 && "name" in this.params) return this.params.name;
    }
    /**
   * Destroys the instance
   */ destroy() {
        $e();
    }
    /**
   * Called when children popover is opened (if exists)
   */ onChildrenOpen() {
        var e;
        this.params !== void 0 && "children" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onOpen) == "function" && this.params.children.onOpen();
    }
    /**
   * Called when children popover is closed (if exists)
   */ onChildrenClose() {
        var e;
        this.params !== void 0 && "children" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onClose) == "function" && this.params.children.onClose();
    }
    /**
   * Called on popover item click
   */ handleClick() {
        var e, t1;
        this.params !== void 0 && "onActivate" in this.params && ((t1 = (e = this.params).onActivate) == null || t1.call(e, this.params));
    }
    /**
   * Adds hint to the item element if hint data is provided
   *
   * @param itemElement - popover item root element to add hint to
   * @param hintData - hint data
   */ addHint(e, t1) {
        const o = new as(t1);
        ze(e, o.getElement(), {
            placement: t1.position,
            hidingDelay: 100
        });
    }
    /**
   * Returns item children that are represented as popover items
   */ get children() {
        var e;
        return this.params !== void 0 && "children" in this.params && ((e = this.params.children) == null ? void 0 : e.items) !== void 0 ? this.params.children.items : [];
    }
    /**
   * Returns true if item has any type of children
   */ get hasChildren() {
        return this.children.length > 0;
    }
    /**
   * Returns true if item children should be open instantly after popover is opened and not on item click/hover
   */ get isChildrenOpen() {
        var e;
        return this.params !== void 0 && "children" in this.params && ((e = this.params.children) == null ? void 0 : e.isOpen) === !0;
    }
    /**
   * True if item children items should be navigatable via keyboard
   */ get isChildrenFlippable() {
        var e;
        return !(this.params === void 0 || !("children" in this.params) || ((e = this.params.children) == null ? void 0 : e.isFlippable) === !1);
    }
    /**
   * Returns true if item has children that should be searchable
   */ get isChildrenSearchable() {
        var e;
        return this.params !== void 0 && "children" in this.params && ((e = this.params.children) == null ? void 0 : e.searchable) === !0;
    }
    /**
   * True if popover should close once item is activated
   */ get closeOnActivate() {
        return this.params !== void 0 && "closeOnActivate" in this.params && this.params.closeOnActivate;
    }
    /**
   * True if item is active
   */ get isActive() {
        return this.params === void 0 || !("isActive" in this.params) ? !1 : typeof this.params.isActive == "function" ? this.params.isActive() : this.params.isActive === !0;
    }
}
const Y = ne("ce-popover-item"), L = {
    container: Y(),
    active: Y(null, "active"),
    disabled: Y(null, "disabled"),
    focused: Y(null, "focused"),
    hidden: Y(null, "hidden"),
    confirmationState: Y(null, "confirmation"),
    noHover: Y(null, "no-hover"),
    noFocus: Y(null, "no-focus"),
    title: Y("title"),
    secondaryTitle: Y("secondary-title"),
    icon: Y("icon"),
    iconTool: Y("icon", "tool"),
    iconChevronRight: Y("icon", "chevron-right"),
    wobbleAnimation: ne("wobble")()
};
class re extends xt {
    /**
   * Constructs popover item instance
   *
   * @param params - popover item construction params
   * @param renderParams - popover item render params.
   * The parameters that are not set by user via popover api but rather depend on technical implementation
   */ constructor(e, t1){
        super(e), this.params = e, this.nodes = {
            root: null,
            icon: null
        }, this.confirmationState = null, this.removeSpecialFocusBehavior = ()=>{
            var o;
            (o = this.nodes.root) == null || o.classList.remove(L.noFocus);
        }, this.removeSpecialHoverBehavior = ()=>{
            var o;
            (o = this.nodes.root) == null || o.classList.remove(L.noHover);
        }, this.onErrorAnimationEnd = ()=>{
            var o, i;
            (o = this.nodes.icon) == null || o.classList.remove(L.wobbleAnimation), (i = this.nodes.icon) == null || i.removeEventListener("animationend", this.onErrorAnimationEnd);
        }, this.nodes.root = this.make(e, t1);
    }
    /**
   * True if item is disabled and hence not clickable
   */ get isDisabled() {
        return this.params.isDisabled === !0;
    }
    /**
   * Exposes popover item toggle parameter
   */ get toggle() {
        return this.params.toggle;
    }
    /**
   * Item title
   */ get title() {
        return this.params.title;
    }
    /**
   * True if confirmation state is enabled for popover item
   */ get isConfirmationStateEnabled() {
        return this.confirmationState !== null;
    }
    /**
   * True if item is focused in keyboard navigation process
   */ get isFocused() {
        return this.nodes.root === null ? !1 : this.nodes.root.classList.contains(L.focused);
    }
    /**
   * Returns popover item root element
   */ getElement() {
        return this.nodes.root;
    }
    /**
   * Called on popover item click
   */ handleClick() {
        if (this.isConfirmationStateEnabled && this.confirmationState !== null) {
            this.activateOrEnableConfirmationMode(this.confirmationState);
            return;
        }
        this.activateOrEnableConfirmationMode(this.params);
    }
    /**
   * Toggles item active state
   *
   * @param isActive - true if item should strictly should become active
   */ toggleActive(e) {
        var t1;
        (t1 = this.nodes.root) == null || t1.classList.toggle(L.active, e);
    }
    /**
   * Toggles item hidden state
   *
   * @param isHidden - true if item should be hidden
   */ toggleHidden(e) {
        var t1;
        (t1 = this.nodes.root) == null || t1.classList.toggle(L.hidden, e);
    }
    /**
   * Resets popover item to its original state
   */ reset() {
        this.isConfirmationStateEnabled && this.disableConfirmationMode();
    }
    /**
   * Method called once item becomes focused during keyboard navigation
   */ onFocus() {
        this.disableSpecialHoverAndFocusBehavior();
    }
    /**
   * Constructs HTML element corresponding to popover item params
   *
   * @param params - item construction params
   * @param renderParams - popover item render params
   */ make(e, t1) {
        var s, r;
        const o = (t1 == null ? void 0 : t1.wrapperTag) || "div", i = d.make(o, L.container, {
            type: o === "button" ? "button" : void 0
        });
        return e.name && (i.dataset.itemName = e.name), this.nodes.icon = d.make("div", [
            L.icon,
            L.iconTool
        ], {
            innerHTML: e.icon || Qi
        }), i.appendChild(this.nodes.icon), e.title !== void 0 && i.appendChild(d.make("div", L.title, {
            innerHTML: e.title || ""
        })), e.secondaryLabel && i.appendChild(d.make("div", L.secondaryTitle, {
            textContent: e.secondaryLabel
        })), this.hasChildren && i.appendChild(d.make("div", [
            L.icon,
            L.iconChevronRight
        ], {
            innerHTML: qi
        })), this.isActive && i.classList.add(L.active), e.isDisabled && i.classList.add(L.disabled), e.hint !== void 0 && ((s = t1 == null ? void 0 : t1.hint) == null ? void 0 : s.enabled) !== !1 && this.addHint(i, {
            ...e.hint,
            position: ((r = t1 == null ? void 0 : t1.hint) == null ? void 0 : r.position) || "right"
        }), i;
    }
    /**
   * Activates confirmation mode for the item.
   *
   * @param newState - new popover item params that should be applied
   */ enableConfirmationMode(e) {
        if (this.nodes.root === null) return;
        const t1 = {
            ...this.params,
            ...e,
            confirmation: "confirmation" in e ? e.confirmation : void 0
        }, o = this.make(t1);
        this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(L.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();
    }
    /**
   * Returns item to its original state
   */ disableConfirmationMode() {
        if (this.nodes.root === null) return;
        const e = this.make(this.params);
        this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(L.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();
    }
    /**
   * Enables special focus and hover behavior for item in confirmation state.
   * This is needed to prevent item from being highlighted as hovered/focused just after click.
   */ enableSpecialHoverAndFocusBehavior() {
        var e, t1, o;
        (e = this.nodes.root) == null || e.classList.add(L.noHover), (t1 = this.nodes.root) == null || t1.classList.add(L.noFocus), (o = this.nodes.root) == null || o.addEventListener("mouseleave", this.removeSpecialHoverBehavior, {
            once: !0
        });
    }
    /**
   * Disables special focus and hover behavior
   */ disableSpecialHoverAndFocusBehavior() {
        var e;
        this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), (e = this.nodes.root) == null || e.removeEventListener("mouseleave", this.removeSpecialHoverBehavior);
    }
    /**
   * Executes item's onActivate callback if the item has no confirmation configured
   *
   * @param item - item to activate or bring to confirmation mode
   */ activateOrEnableConfirmationMode(e) {
        var t1;
        if (!("confirmation" in e) || e.confirmation === void 0) try {
            (t1 = e.onActivate) == null || t1.call(e, e), this.disableConfirmationMode();
        } catch  {
            this.animateError();
        }
        else this.enableConfirmationMode(e.confirmation);
    }
    /**
   * Animates item which symbolizes that error occured while executing 'onActivate()' callback
   */ animateError() {
        var e, t1, o;
        (e = this.nodes.icon) != null && e.classList.contains(L.wobbleAnimation) || ((t1 = this.nodes.icon) == null || t1.classList.add(L.wobbleAnimation), (o = this.nodes.icon) == null || o.addEventListener("animationend", this.onErrorAnimationEnd));
    }
}
const nt = ne("ce-popover-item-separator"), it = {
    container: nt(),
    line: nt("line"),
    hidden: nt(null, "hidden")
};
class Qo extends xt {
    /**
   * Constructs the instance
   */ constructor(){
        super(), this.nodes = {
            root: d.make("div", it.container),
            line: d.make("div", it.line)
        }, this.nodes.root.appendChild(this.nodes.line);
    }
    /**
   * Returns popover separator root element
   */ getElement() {
        return this.nodes.root;
    }
    /**
   * Toggles item hidden state
   *
   * @param isHidden - true if item should be hidden
   */ toggleHidden(e) {
        var t1;
        (t1 = this.nodes.root) == null || t1.classList.toggle(it.hidden, e);
    }
}
var G = /* @__PURE__ */ ((n)=>(n.Closed = "closed", n.ClosedOnActivate = "closed-on-activate", n))(G || {});
const $ = ne("ce-popover"), P = {
    popover: $(),
    popoverContainer: $("container"),
    popoverOpenTop: $(null, "open-top"),
    popoverOpenLeft: $(null, "open-left"),
    popoverOpened: $(null, "opened"),
    search: $("search"),
    nothingFoundMessage: $("nothing-found-message"),
    nothingFoundMessageDisplayed: $("nothing-found-message", "displayed"),
    items: $("items"),
    overlay: $("overlay"),
    overlayHidden: $("overlay", "hidden"),
    popoverNested: $(null, "nested"),
    getPopoverNestedClass: (n)=>$(null, `nested-level-${n.toString()}`),
    popoverInline: $(null, "inline"),
    popoverHeader: $("header")
};
var fe = /* @__PURE__ */ ((n)=>(n.NestingLevel = "--nesting-level", n.PopoverHeight = "--popover-height", n.InlinePopoverWidth = "--inline-popover-width", n.TriggerItemLeft = "--trigger-item-left", n.TriggerItemTop = "--trigger-item-top", n))(fe || {});
const To = ne("ce-popover-item-html"), So = {
    root: To(),
    hidden: To(null, "hidden")
};
class Se extends xt {
    /**
   * Constructs the instance
   *
   * @param params – instance parameters
   * @param renderParams – popover item render params.
   * The parameters that are not set by user via popover api but rather depend on technical implementation
   */ constructor(e, t1){
        var o, i;
        super(e), this.nodes = {
            root: d.make("div", So.root)
        }, this.nodes.root.appendChild(e.element), e.name && (this.nodes.root.dataset.itemName = e.name), e.hint !== void 0 && ((o = t1 == null ? void 0 : t1.hint) == null ? void 0 : o.enabled) !== !1 && this.addHint(this.nodes.root, {
            ...e.hint,
            position: ((i = t1 == null ? void 0 : t1.hint) == null ? void 0 : i.position) || "right"
        });
    }
    /**
   * Returns popover item root element
   */ getElement() {
        return this.nodes.root;
    }
    /**
   * Toggles item hidden state
   *
   * @param isHidden - true if item should be hidden
   */ toggleHidden(e) {
        var t1;
        (t1 = this.nodes.root) == null || t1.classList.toggle(So.hidden, e);
    }
    /**
   * Returns list of buttons and inputs inside custom content
   */ getControls() {
        const e = this.nodes.root.querySelectorAll(`button, ${d.allInputsSelector}`);
        return Array.from(e);
    }
}
class Jo extends Oe {
    /**
   * Constructs the instance
   *
   * @param params - popover construction params
   * @param itemsRenderParams - popover item render params.
   * The parameters that are not set by user via popover api but rather depend on technical implementation
   */ constructor(e, t1 = {}){
        super(), this.params = e, this.itemsRenderParams = t1, this.listeners = new _e(), this.messages = {
            nothingFound: "Nothing found",
            search: "Search"
        }, this.items = this.buildItems(e.items), e.messages && (this.messages = {
            ...this.messages,
            ...e.messages
        }), this.nodes = {}, this.nodes.popoverContainer = d.make("div", [
            P.popoverContainer
        ]), this.nodes.nothingFoundMessage = d.make("div", [
            P.nothingFoundMessage
        ], {
            textContent: this.messages.nothingFound
        }), this.nodes.popoverContainer.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make("div", [
            P.items
        ]), this.items.forEach((o)=>{
            const i = o.getElement();
            i !== null && this.nodes.items.appendChild(i);
        }), this.nodes.popoverContainer.appendChild(this.nodes.items), this.listeners.on(this.nodes.popoverContainer, "click", (o)=>this.handleClick(o)), this.nodes.popover = d.make("div", [
            P.popover,
            this.params.class
        ]), this.nodes.popover.appendChild(this.nodes.popoverContainer);
    }
    /**
   * List of default popover items that are searchable and may have confirmation state
   */ get itemsDefault() {
        return this.items.filter((e)=>e instanceof re);
    }
    /**
   * Returns HTML element corresponding to the popover
   */ getElement() {
        return this.nodes.popover;
    }
    /**
   * Open popover
   */ show() {
        this.nodes.popover.classList.add(P.popoverOpened), this.search !== void 0 && this.search.focus();
    }
    /**
   * Closes popover
   */ hide() {
        this.nodes.popover.classList.remove(P.popoverOpened), this.nodes.popover.classList.remove(P.popoverOpenTop), this.itemsDefault.forEach((e)=>e.reset()), this.search !== void 0 && this.search.clear(), this.emit(G.Closed);
    }
    /**
   * Clears memory
   */ destroy() {
        var e;
        this.items.forEach((t1)=>t1.destroy()), this.nodes.popover.remove(), this.listeners.removeAll(), (e = this.search) == null || e.destroy();
    }
    /**
   * Looks for the item by name and imitates click on it
   *
   * @param name - name of the item to activate
   */ activateItemByName(e) {
        const t1 = this.items.find((o)=>o.name === e);
        this.handleItemClick(t1);
    }
    /**
   * Factory method for creating popover items
   *
   * @param items - list of items params
   */ buildItems(e) {
        return e.map((t1)=>{
            switch(t1.type){
                case _.Separator:
                    return new Qo();
                case _.Html:
                    return new Se(t1, this.itemsRenderParams[_.Html]);
                default:
                    return new re(t1, this.itemsRenderParams[_.Default]);
            }
        });
    }
    /**
   * Retrieves popover item that is the target of the specified event
   *
   * @param event - event to retrieve popover item from
   */ getTargetItem(e) {
        return this.items.filter((t1)=>t1 instanceof re || t1 instanceof Se).find((t1)=>{
            const o = t1.getElement();
            return o === null ? !1 : e.composedPath().includes(o);
        });
    }
    /**
   * Handles popover item click
   *
   * @param item - item to handle click of
   */ handleItemClick(e) {
        if (!("isDisabled" in e && e.isDisabled)) {
            if (e.hasChildren) {
                this.showNestedItems(e), "handleClick" in e && typeof e.handleClick == "function" && e.handleClick();
                return;
            }
            this.itemsDefault.filter((t1)=>t1 !== e).forEach((t1)=>t1.reset()), "handleClick" in e && typeof e.handleClick == "function" && e.handleClick(), this.toggleItemActivenessIfNeeded(e), e.closeOnActivate && (this.hide(), this.emit(G.ClosedOnActivate));
        }
    }
    /**
   * Handles clicks inside popover
   *
   * @param event - item to handle click of
   */ handleClick(e) {
        const t1 = this.getTargetItem(e);
        t1 !== void 0 && this.handleItemClick(t1);
    }
    /**
   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.
   *
   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.
   * (All the other items with the same key get inactive, and the item gets active)
   *
   * @param clickedItem - popover item that was clicked
   */ toggleItemActivenessIfNeeded(e) {
        if (e instanceof re && (e.toggle === !0 && e.toggleActive(), typeof e.toggle == "string")) {
            const t1 = this.itemsDefault.filter((o)=>o.toggle === e.toggle);
            if (t1.length === 1) {
                e.toggleActive();
                return;
            }
            t1.forEach((o)=>{
                o.toggleActive(o === e);
            });
        }
    }
}
var Ue = /* @__PURE__ */ ((n)=>(n.Search = "search", n))(Ue || {});
const st = ne("cdx-search-field"), rt = {
    wrapper: st(),
    icon: st("icon"),
    input: st("input")
};
class ls extends Oe {
    /**
   * @param options - available config
   * @param options.items - searchable items list
   * @param options.placeholder - input placeholder
   */ constructor({ items: e, placeholder: t1 }){
        super(), this.listeners = new _e(), this.items = e, this.wrapper = d.make("div", rt.wrapper);
        const o = d.make("div", rt.icon, {
            innerHTML: os
        });
        this.input = d.make("input", rt.input, {
            placeholder: t1,
            /**
       * Used to prevent focusing on the input by Tab key
       * (Popover in the Toolbar lays below the blocks,
       * so Tab in the last block will focus this hidden input if this property is not set)
       */ tabIndex: -1
        }), this.wrapper.appendChild(o), this.wrapper.appendChild(this.input), this.listeners.on(this.input, "input", ()=>{
            this.searchQuery = this.input.value, this.emit(Ue.Search, {
                query: this.searchQuery,
                items: this.foundItems
            });
        });
    }
    /**
   * Returns search field element
   */ getElement() {
        return this.wrapper;
    }
    /**
   * Sets focus to the input
   */ focus() {
        this.input.focus();
    }
    /**
   * Clears search query and results
   */ clear() {
        this.input.value = "", this.searchQuery = "", this.emit(Ue.Search, {
            query: "",
            items: this.foundItems
        });
    }
    /**
   * Clears memory
   */ destroy() {
        this.listeners.removeAll();
    }
    /**
   * Returns list of found items for the current search query
   */ get foundItems() {
        return this.items.filter((e)=>this.checkItem(e));
    }
    /**
   * Contains logic for checking whether passed item conforms the search query
   *
   * @param item - item to be checked
   */ checkItem(e) {
        var i, s;
        const t1 = ((i = e.title) == null ? void 0 : i.toLowerCase()) || "", o = (s = this.searchQuery) == null ? void 0 : s.toLowerCase();
        return o !== void 0 ? t1.includes(o) : !1;
    }
}
var cs = Object.defineProperty, ds = Object.getOwnPropertyDescriptor, us = (n, e, t1, o)=>{
    for(var i = o > 1 ? void 0 : o ? ds(e, t1) : e, s = n.length - 1, r; s >= 0; s--)(r = n[s]) && (i = (o ? r(e, t1, i) : r(i)) || i);
    return o && i && cs(e, t1, i), i;
};
const en = class tn extends Jo {
    /**
   * Construct the instance
   *
   * @param params - popover params
   * @param itemsRenderParams – popover item render params.
   * The parameters that are not set by user via popover api but rather depend on technical implementation
   */ constructor(e, t1){
        super(e, t1), this.nestingLevel = 0, this.nestedPopoverTriggerItem = null, this.previouslyHoveredItem = null, this.scopeElement = document.body, this.hide = ()=>{
            var o;
            super.hide(), this.destroyNestedPopoverIfExists(), (o = this.flipper) == null || o.deactivate(), this.previouslyHoveredItem = null;
        }, this.onFlip = ()=>{
            const o = this.itemsDefault.find((i)=>i.isFocused);
            o == null || o.onFocus();
        }, this.onSearch = (o)=>{
            var a;
            const i = o.query === "", s = o.items.length === 0;
            this.items.forEach((l)=>{
                let c = !1;
                l instanceof re ? c = !o.items.includes(l) : (l instanceof Qo || l instanceof Se) && (c = s || !i), l.toggleHidden(c);
            }), this.toggleNothingFoundMessage(s);
            const r = o.query === "" ? this.flippableElements : o.items.map((l)=>l.getElement());
            (a = this.flipper) != null && a.isActivated && (this.flipper.deactivate(), this.flipper.activate(r));
        }, e.nestingLevel !== void 0 && (this.nestingLevel = e.nestingLevel), this.nestingLevel > 0 && this.nodes.popover.classList.add(P.popoverNested), e.scopeElement !== void 0 && (this.scopeElement = e.scopeElement), this.nodes.popoverContainer !== null && this.listeners.on(this.nodes.popoverContainer, "mouseover", (o)=>this.handleHover(o)), e.searchable && this.addSearch(), e.flippable !== !1 && (this.flipper = new ce({
            items: this.flippableElements,
            focusedItemClass: L.focused,
            allowedKeys: [
                y.TAB,
                y.UP,
                y.DOWN,
                y.ENTER
            ]
        }), this.flipper.onFlip(this.onFlip));
    }
    /**
   * Returns true if some item inside popover is focused
   */ hasFocus() {
        return this.flipper === void 0 ? !1 : this.flipper.hasFocus();
    }
    /**
   * Scroll position inside items container of the popover
   */ get scrollTop() {
        return this.nodes.items === null ? 0 : this.nodes.items.scrollTop;
    }
    /**
   * Returns visible element offset top
   */ get offsetTop() {
        return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetTop;
    }
    /**
   * Open popover
   */ show() {
        var e;
        this.nodes.popover.style.setProperty(fe.PopoverHeight, this.size.height + "px"), this.shouldOpenBottom || this.nodes.popover.classList.add(P.popoverOpenTop), this.shouldOpenRight || this.nodes.popover.classList.add(P.popoverOpenLeft), super.show(), (e = this.flipper) == null || e.activate(this.flippableElements);
    }
    /**
   * Clears memory
   */ destroy() {
        this.hide(), super.destroy();
    }
    /**
   * Handles displaying nested items for the item.
   *
   * @param item – item to show nested popover for
   */ showNestedItems(e) {
        this.nestedPopover !== null && this.nestedPopover !== void 0 || (this.nestedPopoverTriggerItem = e, this.showNestedPopoverForItem(e));
    }
    /**
   * Handles hover events inside popover items container
   *
   * @param event - hover event data
   */ handleHover(e) {
        const t1 = this.getTargetItem(e);
        t1 !== void 0 && this.previouslyHoveredItem !== t1 && (this.destroyNestedPopoverIfExists(), this.previouslyHoveredItem = t1, t1.hasChildren && this.showNestedPopoverForItem(t1));
    }
    /**
   * Sets CSS variable with position of item near which nested popover should be displayed.
   * Is used for correct positioning of the nested popover
   *
   * @param nestedPopoverEl - nested popover element
   * @param item – item near which nested popover should be displayed
   */ setTriggerItemPosition(e, t1) {
        const o = t1.getElement(), i = (o ? o.offsetTop : 0) - this.scrollTop, s = this.offsetTop + i;
        e.style.setProperty(fe.TriggerItemTop, s + "px");
    }
    /**
   * Destroys existing nested popover
   */ destroyNestedPopoverIfExists() {
        var e, t1;
        this.nestedPopover === void 0 || this.nestedPopover === null || (this.nestedPopover.off(G.ClosedOnActivate, this.hide), this.nestedPopover.hide(), this.nestedPopover.destroy(), this.nestedPopover.getElement().remove(), this.nestedPopover = null, (e = this.flipper) == null || e.activate(this.flippableElements), (t1 = this.nestedPopoverTriggerItem) == null || t1.onChildrenClose());
    }
    /**
   * Creates and displays nested popover for specified item.
   * Is used only on desktop
   *
   * @param item - item to display nested popover by
   */ showNestedPopoverForItem(e) {
        var o;
        this.nestedPopover = new tn({
            searchable: e.isChildrenSearchable,
            items: e.children,
            nestingLevel: this.nestingLevel + 1,
            flippable: e.isChildrenFlippable,
            messages: this.messages
        }), e.onChildrenOpen(), this.nestedPopover.on(G.ClosedOnActivate, this.hide);
        const t1 = this.nestedPopover.getElement();
        return this.nodes.popover.appendChild(t1), this.setTriggerItemPosition(t1, e), t1.style.setProperty(fe.NestingLevel, this.nestedPopover.nestingLevel.toString()), this.nestedPopover.show(), (o = this.flipper) == null || o.deactivate(), this.nestedPopover;
    }
    /**
   * Checks if popover should be opened bottom.
   * It should happen when there is enough space below or not enough space above
   */ get shouldOpenBottom() {
        if (this.nodes.popover === void 0 || this.nodes.popover === null) return !1;
        const e = this.nodes.popoverContainer.getBoundingClientRect(), t1 = this.scopeElement.getBoundingClientRect(), o = this.size.height, i = e.top + o, s = e.top - o, r = Math.min(window.innerHeight, t1.bottom);
        return s < t1.top || i <= r;
    }
    /**
   * Checks if popover should be opened left.
   * It should happen when there is enough space in the right or not enough space in the left
   */ get shouldOpenRight() {
        if (this.nodes.popover === void 0 || this.nodes.popover === null) return !1;
        const e = this.nodes.popover.getBoundingClientRect(), t1 = this.scopeElement.getBoundingClientRect(), o = this.size.width, i = e.right + o, s = e.left - o, r = Math.min(window.innerWidth, t1.right);
        return s < t1.left || i <= r;
    }
    get size() {
        var i;
        const e = {
            height: 0,
            width: 0
        };
        if (this.nodes.popover === null) return e;
        const t1 = this.nodes.popover.cloneNode(!0);
        t1.style.visibility = "hidden", t1.style.position = "absolute", t1.style.top = "-1000px", t1.classList.add(P.popoverOpened), (i = t1.querySelector("." + P.popoverNested)) == null || i.remove(), document.body.appendChild(t1);
        const o = t1.querySelector("." + P.popoverContainer);
        return e.height = o.offsetHeight, e.width = o.offsetWidth, t1.remove(), e;
    }
    /**
   * Returns list of elements available for keyboard navigation.
   */ get flippableElements() {
        return this.items.map((t1)=>{
            if (t1 instanceof re) return t1.getElement();
            if (t1 instanceof Se) return t1.getControls();
        }).flat().filter((t1)=>t1 != null);
    }
    /**
   * Adds search to the popover
   */ addSearch() {
        this.search = new ls({
            items: this.itemsDefault,
            placeholder: this.messages.search
        }), this.search.on(Ue.Search, this.onSearch);
        const e = this.search.getElement();
        e.classList.add(P.search), this.nodes.popoverContainer.insertBefore(e, this.nodes.popoverContainer.firstChild);
    }
    /**
   * Toggles nothing found message visibility
   *
   * @param isDisplayed - true if the message should be displayed
   */ toggleNothingFoundMessage(e) {
        this.nodes.nothingFoundMessage.classList.toggle(P.nothingFoundMessageDisplayed, e);
    }
};
us([
    me
], en.prototype, "size", 1);
let Bt = en;
class hs extends Bt {
    /**
   * Constructs the instance
   *
   * @param params - instance parameters
   */ constructor(e){
        const t1 = !be();
        super({
            ...e,
            class: P.popoverInline
        }, {
            [_.Default]: {
                /**
           * We use button instead of div here to fix bug associated with focus loss (which leads to selection change) on click in safari
           *
           * @todo figure out better way to solve the issue
           */ wrapperTag: "button",
                hint: {
                    position: "top",
                    alignment: "center",
                    enabled: t1
                }
            },
            [_.Html]: {
                hint: {
                    position: "top",
                    alignment: "center",
                    enabled: t1
                }
            }
        }), this.items.forEach((o)=>{
            !(o instanceof re) && !(o instanceof Se) || o.hasChildren && o.isChildrenOpen && this.showNestedItems(o);
        });
    }
    /**
   * Returns visible element offset top
   */ get offsetLeft() {
        return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetLeft;
    }
    /**
   * Open popover
   */ show() {
        this.nestingLevel === 0 && this.nodes.popover.style.setProperty(fe.InlinePopoverWidth, this.size.width + "px"), super.show();
    }
    /**
   * Disable hover event handling.
   * Overrides parent's class behavior
   */ handleHover() {}
    /**
   * Sets CSS variable with position of item near which nested popover should be displayed.
   * Is used to position nested popover right below clicked item
   *
   * @param nestedPopoverEl - nested popover element
   * @param item – item near which nested popover should be displayed
   */ setTriggerItemPosition(e, t1) {
        const o = t1.getElement(), i = o ? o.offsetLeft : 0, s = this.offsetLeft + i;
        e.style.setProperty(fe.TriggerItemLeft, s + "px");
    }
    /**
   * Handles displaying nested items for the item.
   * Overriding in order to add toggling behaviour
   *
   * @param item – item to toggle nested popover for
   */ showNestedItems(e) {
        if (this.nestedPopoverTriggerItem === e) {
            this.destroyNestedPopoverIfExists(), this.nestedPopoverTriggerItem = null;
            return;
        }
        super.showNestedItems(e);
    }
    /**
   * Creates and displays nested popover for specified item.
   * Is used only on desktop
   *
   * @param item - item to display nested popover by
   */ showNestedPopoverForItem(e) {
        const t1 = super.showNestedPopoverForItem(e);
        return t1.getElement().classList.add(P.getPopoverNestedClass(t1.nestingLevel)), t1;
    }
    /**
   * Overrides default item click handling.
   * Helps to close nested popover once other item is clicked.
   *
   * @param item - clicked item
   */ handleItemClick(e) {
        var t1;
        e !== this.nestedPopoverTriggerItem && ((t1 = this.nestedPopoverTriggerItem) == null || t1.handleClick(), super.destroyNestedPopoverIfExists()), super.handleItemClick(e);
    }
}
const on = class xe {
    constructor(){
        this.scrollPosition = null;
    }
    /**
   * Locks body element scroll
   */ lock() {
        pt ? this.lockHard() : document.body.classList.add(xe.CSS.scrollLocked);
    }
    /**
   * Unlocks body element scroll
   */ unlock() {
        pt ? this.unlockHard() : document.body.classList.remove(xe.CSS.scrollLocked);
    }
    /**
   * Locks scroll in a hard way (via setting fixed position to body element)
   */ lockHard() {
        this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty("--window-scroll-offset", `${this.scrollPosition}px`), document.body.classList.add(xe.CSS.scrollLockedHard);
    }
    /**
   * Unlocks hard scroll lock
   */ unlockHard() {
        document.body.classList.remove(xe.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;
    }
};
on.CSS = {
    scrollLocked: "ce-scroll-locked",
    scrollLockedHard: "ce-scroll-locked--hard"
};
let ps = on;
const at = ne("ce-popover-header"), lt = {
    root: at(),
    text: at("text"),
    backButton: at("back-button")
};
class fs {
    /**
   * Constructs the instance
   *
   * @param params - popover header params
   */ constructor({ text: e, onBackButtonClick: t1 }){
        this.listeners = new _e(), this.text = e, this.onBackButtonClick = t1, this.nodes = {
            root: d.make("div", [
                lt.root
            ]),
            backButton: d.make("button", [
                lt.backButton
            ]),
            text: d.make("div", [
                lt.text
            ])
        }, this.nodes.backButton.innerHTML = Vi, this.nodes.root.appendChild(this.nodes.backButton), this.listeners.on(this.nodes.backButton, "click", this.onBackButtonClick), this.nodes.text.innerText = this.text, this.nodes.root.appendChild(this.nodes.text);
    }
    /**
   * Returns popover header root html element
   */ getElement() {
        return this.nodes.root;
    }
    /**
   * Destroys the instance
   */ destroy() {
        this.nodes.root.remove(), this.listeners.destroy();
    }
}
class gs {
    constructor(){
        this.history = [];
    }
    /**
   * Push new popover state
   *
   * @param state - new state
   */ push(e) {
        this.history.push(e);
    }
    /**
   * Pop last popover state
   */ pop() {
        return this.history.pop();
    }
    /**
   * Title retrieved from the current state
   */ get currentTitle() {
        return this.history.length === 0 ? "" : this.history[this.history.length - 1].title;
    }
    /**
   * Items list retrieved from the current state
   */ get currentItems() {
        return this.history.length === 0 ? [] : this.history[this.history.length - 1].items;
    }
    /**
   * Returns history to initial popover state
   */ reset() {
        for(; this.history.length > 1;)this.pop();
    }
}
class nn extends Jo {
    /**
   * Construct the instance
   *
   * @param params - popover params
   */ constructor(e){
        super(e, {
            [_.Default]: {
                hint: {
                    enabled: !1
                }
            },
            [_.Html]: {
                hint: {
                    enabled: !1
                }
            }
        }), this.scrollLocker = new ps(), this.history = new gs(), this.isHidden = !0, this.nodes.overlay = d.make("div", [
            P.overlay,
            P.overlayHidden
        ]), this.nodes.popover.insertBefore(this.nodes.overlay, this.nodes.popover.firstChild), this.listeners.on(this.nodes.overlay, "click", ()=>{
            this.hide();
        }), this.history.push({
            items: e.items
        });
    }
    /**
   * Open popover
   */ show() {
        this.nodes.overlay.classList.remove(P.overlayHidden), super.show(), this.scrollLocker.lock(), this.isHidden = !1;
    }
    /**
   * Closes popover
   */ hide() {
        this.isHidden || (super.hide(), this.nodes.overlay.classList.add(P.overlayHidden), this.scrollLocker.unlock(), this.history.reset(), this.isHidden = !0);
    }
    /**
   * Clears memory
   */ destroy() {
        super.destroy(), this.scrollLocker.unlock();
    }
    /**
   * Handles displaying nested items for the item
   *
   * @param item – item to show nested popover for
   */ showNestedItems(e) {
        this.updateItemsAndHeader(e.children, e.title), this.history.push({
            title: e.title,
            items: e.children
        });
    }
    /**
   * Removes rendered popover items and header and displays new ones
   *
   * @param items - new popover items
   * @param title - new popover header text
   */ updateItemsAndHeader(e, t1) {
        if (this.header !== null && this.header !== void 0 && (this.header.destroy(), this.header = null), t1 !== void 0) {
            this.header = new fs({
                text: t1,
                onBackButtonClick: ()=>{
                    this.history.pop(), this.updateItemsAndHeader(this.history.currentItems, this.history.currentTitle);
                }
            });
            const o = this.header.getElement();
            o !== null && this.nodes.popoverContainer.insertBefore(o, this.nodes.popoverContainer.firstChild);
        }
        this.items.forEach((o)=>{
            var i;
            return (i = o.getElement()) == null ? void 0 : i.remove();
        }), this.items = this.buildItems(e), this.items.forEach((o)=>{
            var s;
            const i = o.getElement();
            i !== null && ((s = this.nodes.items) == null || s.appendChild(i));
        });
    }
}
class ms extends E {
    constructor(){
        super(...arguments), this.opened = !1, this.selection = new b(), this.popover = null, this.close = ()=>{
            this.opened && (this.opened = !1, b.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));
        }, this.onPopoverClose = ()=>{
            this.close();
        };
    }
    /**
   * Module Events
   */ get events() {
        return {
            opened: "block-settings-opened",
            closed: "block-settings-closed"
        };
    }
    /**
   * Block Settings CSS
   */ get CSS() {
        return {
            settings: "ce-settings"
        };
    }
    /**
   * Getter for inner popover's flipper instance
   *
   * @todo remove once BlockSettings becomes standalone non-module class
   */ get flipper() {
        var e;
        if (this.popover !== null) return "flipper" in this.popover ? (e = this.popover) == null ? void 0 : e.flipper : void 0;
    }
    /**
   * Panel with block settings with 2 sections:
   *  - Tool's Settings
   *  - Default Settings [Move, Remove, etc]
   */ make() {
        this.nodes.wrapper = d.make("div", [
            this.CSS.settings
        ]), this.nodes.wrapper.setAttribute("data-cy", "block-tunes"), this.eventsDispatcher.on(Te, this.close);
    }
    /**
   * Destroys module
   */ destroy() {
        this.removeAllNodes(), this.listeners.destroy(), this.eventsDispatcher.off(Te, this.close);
    }
    /**
   * Open Block Settings pane
   *
   * @param targetBlock - near which Block we should open BlockSettings
   */ async open(e = this.Editor.BlockManager.currentBlock) {
        var s;
        this.opened = !0, this.selection.save(), this.Editor.BlockSelection.selectBlock(e), this.Editor.BlockSelection.clearCache();
        const { toolTunes: t1, commonTunes: o } = e.getTunes();
        this.eventsDispatcher.emit(this.events.opened);
        const i = be() ? nn : Bt;
        this.popover = new i({
            searchable: !0,
            items: await this.getTunesItems(e, o, t1),
            scopeElement: this.Editor.API.methods.ui.nodes.redactor,
            messages: {
                nothingFound: z.ui(K.ui.popover, "Nothing found"),
                search: z.ui(K.ui.popover, "Filter")
            }
        }), this.popover.on(G.Closed, this.onPopoverClose), (s = this.nodes.wrapper) == null || s.append(this.popover.getElement()), this.popover.show();
    }
    /**
   * Returns root block settings element
   */ getElement() {
        return this.nodes.wrapper;
    }
    /**
   * Returns list of items to be displayed in block tunes menu.
   * Merges tool specific tunes, conversion menu and common tunes in one list in predefined order
   *
   * @param currentBlock –  block we are about to open block tunes for
   * @param commonTunes – common tunes
   * @param toolTunes - tool specific tunes
   */ async getTunesItems(e, t1, o) {
        const i = [];
        o !== void 0 && o.length > 0 && (i.push(...o), i.push({
            type: _.Separator
        }));
        const s = Array.from(this.Editor.Tools.blockTools.values()), a = (await Yo(e, s)).reduce((l, c)=>(c.toolbox.forEach((u)=>{
                l.push({
                    icon: u.icon,
                    title: z.t(K.toolNames, u.title),
                    name: c.name,
                    closeOnActivate: !0,
                    onActivate: async ()=>{
                        const { BlockManager: h, Caret: p, Toolbar: g } = this.Editor, f = await h.convert(e, c.name, u.data);
                        g.close(), p.setToBlock(f, p.positions.END);
                    }
                });
            }), l), []);
        return a.length > 0 && (i.push({
            icon: Go,
            name: "convert-to",
            title: z.ui(K.ui.popover, "Convert to"),
            children: {
                searchable: !0,
                items: a
            }
        }), i.push({
            type: _.Separator
        })), i.push(...t1), i.map((l)=>this.resolveTuneAliases(l));
    }
    /**
   * Resolves aliases in tunes menu items
   *
   * @param item - item with resolved aliases
   */ resolveTuneAliases(e) {
        if (e.type === _.Separator || e.type === _.Html) return e;
        const t1 = Yi(e, {
            label: "title"
        });
        return e.confirmation && (t1.confirmation = this.resolveTuneAliases(e.confirmation)), t1;
    }
}
var sn = {
    exports: {}
};
/*!
 * Library for handling keyboard shortcuts
 * @copyright CodeX (https://codex.so)
 * @license MIT
 * @author CodeX (https://codex.so)
 * @version 1.2.0
 */ (function(n, e) {
    (function(t1, o) {
        n.exports = o();
    })(window, function() {
        return function(t1) {
            var o = {};
            function i(s) {
                if (o[s]) return o[s].exports;
                var r = o[s] = {
                    i: s,
                    l: !1,
                    exports: {}
                };
                return t1[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;
            }
            return i.m = t1, i.c = o, i.d = function(s, r, a) {
                i.o(s, r) || Object.defineProperty(s, r, {
                    enumerable: !0,
                    get: a
                });
            }, i.r = function(s) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(s, "__esModule", {
                    value: !0
                });
            }, i.t = function(s, r) {
                if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == "object" && s && s.__esModule) return s;
                var a = /* @__PURE__ */ Object.create(null);
                if (i.r(a), Object.defineProperty(a, "default", {
                    enumerable: !0,
                    value: s
                }), 2 & r && typeof s != "string") for(var l in s)i.d(a, l, (function(c) {
                    return s[c];
                }).bind(null, l));
                return a;
            }, i.n = function(s) {
                var r = s && s.__esModule ? function() {
                    return s.default;
                } : function() {
                    return s;
                };
                return i.d(r, "a", r), r;
            }, i.o = function(s, r) {
                return Object.prototype.hasOwnProperty.call(s, r);
            }, i.p = "", i(i.s = 0);
        }([
            function(t1, o, i) {
                function s(l, c) {
                    for(var u = 0; u < c.length; u++){
                        var h = c[u];
                        h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(l, h.key, h);
                    }
                }
                function r(l, c, u) {
                    return c && s(l.prototype, c), u && s(l, u), l;
                }
                i.r(o);
                var a = function() {
                    function l(c) {
                        var u = this;
                        (function(h, p) {
                            if (!(h instanceof p)) throw new TypeError("Cannot call a class as a function");
                        })(this, l), this.commands = {}, this.keys = {}, this.name = c.name, this.parseShortcutName(c.name), this.element = c.on, this.callback = c.callback, this.executeShortcut = function(h) {
                            u.execute(h);
                        }, this.element.addEventListener("keydown", this.executeShortcut, !1);
                    }
                    return r(l, null, [
                        {
                            key: "supportedCommands",
                            get: function() {
                                return {
                                    SHIFT: [
                                        "SHIFT"
                                    ],
                                    CMD: [
                                        "CMD",
                                        "CONTROL",
                                        "COMMAND",
                                        "WINDOWS",
                                        "CTRL"
                                    ],
                                    ALT: [
                                        "ALT",
                                        "OPTION"
                                    ]
                                };
                            }
                        },
                        {
                            key: "keyCodes",
                            get: function() {
                                return {
                                    0: 48,
                                    1: 49,
                                    2: 50,
                                    3: 51,
                                    4: 52,
                                    5: 53,
                                    6: 54,
                                    7: 55,
                                    8: 56,
                                    9: 57,
                                    A: 65,
                                    B: 66,
                                    C: 67,
                                    D: 68,
                                    E: 69,
                                    F: 70,
                                    G: 71,
                                    H: 72,
                                    I: 73,
                                    J: 74,
                                    K: 75,
                                    L: 76,
                                    M: 77,
                                    N: 78,
                                    O: 79,
                                    P: 80,
                                    Q: 81,
                                    R: 82,
                                    S: 83,
                                    T: 84,
                                    U: 85,
                                    V: 86,
                                    W: 87,
                                    X: 88,
                                    Y: 89,
                                    Z: 90,
                                    BACKSPACE: 8,
                                    ENTER: 13,
                                    ESCAPE: 27,
                                    LEFT: 37,
                                    UP: 38,
                                    RIGHT: 39,
                                    DOWN: 40,
                                    INSERT: 45,
                                    DELETE: 46,
                                    ".": 190
                                };
                            }
                        }
                    ]), r(l, [
                        {
                            key: "parseShortcutName",
                            value: function(c) {
                                c = c.split("+");
                                for(var u = 0; u < c.length; u++){
                                    c[u] = c[u].toUpperCase();
                                    var h = !1;
                                    for(var p in l.supportedCommands)if (l.supportedCommands[p].includes(c[u])) {
                                        h = this.commands[p] = !0;
                                        break;
                                    }
                                    h || (this.keys[c[u]] = !0);
                                }
                                for(var g in l.supportedCommands)this.commands[g] || (this.commands[g] = !1);
                            }
                        },
                        {
                            key: "execute",
                            value: function(c) {
                                var u, h = {
                                    CMD: c.ctrlKey || c.metaKey,
                                    SHIFT: c.shiftKey,
                                    ALT: c.altKey
                                }, p = !0;
                                for(u in this.commands)this.commands[u] !== h[u] && (p = !1);
                                var g, f = !0;
                                for(g in this.keys)f = f && c.keyCode === l.keyCodes[g];
                                p && f && this.callback(c);
                            }
                        },
                        {
                            key: "remove",
                            value: function() {
                                this.element.removeEventListener("keydown", this.executeShortcut);
                            }
                        }
                    ]), l;
                }();
                o.default = a;
            }
        ]).default;
    });
})(sn);
var bs = sn.exports;
const vs = /* @__PURE__ */ Ke(bs);
class ks {
    constructor(){
        this.registeredShortcuts = /* @__PURE__ */ new Map();
    }
    /**
   * Register shortcut
   *
   * @param shortcut - shortcut options
   */ add(e) {
        if (this.findShortcut(e.on, e.name)) throw Error(`Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`);
        const o = new vs({
            name: e.name,
            on: e.on,
            callback: e.handler
        }), i = this.registeredShortcuts.get(e.on) || [];
        this.registeredShortcuts.set(e.on, [
            ...i,
            o
        ]);
    }
    /**
   * Remove shortcut
   *
   * @param element - Element shortcut is set for
   * @param name - shortcut name
   */ remove(e, t1) {
        const o = this.findShortcut(e, t1);
        if (!o) return;
        o.remove();
        const i = this.registeredShortcuts.get(e);
        this.registeredShortcuts.set(e, i.filter((s)=>s !== o));
    }
    /**
   * Get Shortcut instance if exist
   *
   * @param element - Element shorcut is set for
   * @param shortcut - shortcut name
   * @returns {number} index - shortcut index if exist
   */ findShortcut(e, t1) {
        return (this.registeredShortcuts.get(e) || []).find(({ name: i })=>i === t1);
    }
}
const ge = new ks();
var ys = Object.defineProperty, ws = Object.getOwnPropertyDescriptor, rn = (n, e, t1, o)=>{
    for(var i = o > 1 ? void 0 : o ? ws(e, t1) : e, s = n.length - 1, r; s >= 0; s--)(r = n[s]) && (i = (o ? r(e, t1, i) : r(i)) || i);
    return o && i && ys(e, t1, i), i;
}, Le = /* @__PURE__ */ ((n)=>(n.Opened = "toolbox-opened", n.Closed = "toolbox-closed", n.BlockAdded = "toolbox-block-added", n))(Le || {});
const Ct = class an extends Oe {
    /**
   * Toolbox constructor
   *
   * @param options - available parameters
   * @param options.api - Editor API methods
   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not
   */ constructor({ api: e, tools: t1, i18nLabels: o }){
        super(), this.opened = !1, this.listeners = new _e(), this.popover = null, this.handleMobileLayoutToggle = ()=>{
            this.destroyPopover(), this.initPopover();
        }, this.onPopoverClose = ()=>{
            this.opened = !1, this.emit("toolbox-closed");
        }, this.api = e, this.tools = t1, this.i18nLabels = o, this.enableShortcuts(), this.nodes = {
            toolbox: d.make("div", an.CSS.toolbox)
        }, this.initPopover(), this.nodes.toolbox.setAttribute("data-cy", "toolbox"), this.api.events.on(Te, this.handleMobileLayoutToggle);
    }
    /**
   * Returns True if Toolbox is Empty and nothing to show
   *
   * @returns {boolean}
   */ get isEmpty() {
        return this.toolsToBeDisplayed.length === 0;
    }
    /**
   * CSS styles
   */ static get CSS() {
        return {
            toolbox: "ce-toolbox"
        };
    }
    /**
   * Returns root block settings element
   */ getElement() {
        return this.nodes.toolbox;
    }
    /**
   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button
   */ hasFocus() {
        if (this.popover !== null) return "hasFocus" in this.popover ? this.popover.hasFocus() : void 0;
    }
    /**
   * Destroy Module
   */ destroy() {
        var e;
        super.destroy(), this.nodes && this.nodes.toolbox && this.nodes.toolbox.remove(), this.removeAllShortcuts(), (e = this.popover) == null || e.off(G.Closed, this.onPopoverClose), this.listeners.destroy(), this.api.events.off(Te, this.handleMobileLayoutToggle);
    }
    /**
   * Toolbox Tool's button click handler
   *
   * @param toolName - tool type to be activated
   * @param blockDataOverrides - Block data predefined by the activated Toolbox item
   */ toolButtonActivated(e, t1) {
        this.insertNewBlock(e, t1);
    }
    /**
   * Open Toolbox with Tools
   */ open() {
        var e;
        this.isEmpty || ((e = this.popover) == null || e.show(), this.opened = !0, this.emit("toolbox-opened"));
    }
    /**
   * Close Toolbox
   */ close() {
        var e;
        (e = this.popover) == null || e.hide(), this.opened = !1, this.emit("toolbox-closed");
    }
    /**
   * Close Toolbox
   */ toggle() {
        this.opened ? this.close() : this.open();
    }
    /**
   * Creates toolbox popover and appends it inside wrapper element
   */ initPopover() {
        var t1;
        const e = be() ? nn : Bt;
        this.popover = new e({
            scopeElement: this.api.ui.nodes.redactor,
            searchable: !0,
            messages: {
                nothingFound: this.i18nLabels.nothingFound,
                search: this.i18nLabels.filter
            },
            items: this.toolboxItemsToBeDisplayed
        }), this.popover.on(G.Closed, this.onPopoverClose), (t1 = this.nodes.toolbox) == null || t1.append(this.popover.getElement());
    }
    /**
   * Destroys popover instance and removes it from DOM
   */ destroyPopover() {
        this.popover !== null && (this.popover.hide(), this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover = null), this.nodes.toolbox !== null && (this.nodes.toolbox.innerHTML = "");
    }
    get toolsToBeDisplayed() {
        const e = [];
        return this.tools.forEach((t1)=>{
            t1.toolbox && e.push(t1);
        }), e;
    }
    get toolboxItemsToBeDisplayed() {
        const e = (t1, o, i = !0)=>({
                icon: t1.icon,
                title: z.t(K.toolNames, t1.title || je(o.name)),
                name: o.name,
                onActivate: ()=>{
                    this.toolButtonActivated(o.name, t1.data);
                },
                secondaryLabel: o.shortcut && i ? vt(o.shortcut) : ""
            });
        return this.toolsToBeDisplayed.reduce((t1, o)=>(Array.isArray(o.toolbox) ? o.toolbox.forEach((i, s)=>{
                t1.push(e(i, o, s === 0));
            }) : o.toolbox !== void 0 && t1.push(e(o.toolbox, o)), t1), []);
    }
    /**
   * Iterate all tools and enable theirs shortcuts if specified
   */ enableShortcuts() {
        this.toolsToBeDisplayed.forEach((e)=>{
            const t1 = e.shortcut;
            t1 && this.enableShortcutForTool(e.name, t1);
        });
    }
    /**
   * Enable shortcut Block Tool implemented shortcut
   *
   * @param {string} toolName - Tool name
   * @param {string} shortcut - shortcut according to the ShortcutData Module format
   */ enableShortcutForTool(e, t1) {
        ge.add({
            name: t1,
            on: this.api.ui.nodes.redactor,
            handler: async (o)=>{
                o.preventDefault();
                const i = this.api.blocks.getCurrentBlockIndex(), s = this.api.blocks.getBlockByIndex(i);
                if (s) try {
                    const r = await this.api.blocks.convert(s.id, e);
                    this.api.caret.setToBlock(r, "end");
                    return;
                } catch  {}
                this.insertNewBlock(e);
            }
        });
    }
    /**
   * Removes all added shortcuts
   * Fired when the Read-Only mode is activated
   */ removeAllShortcuts() {
        this.toolsToBeDisplayed.forEach((e)=>{
            const t1 = e.shortcut;
            t1 && ge.remove(this.api.ui.nodes.redactor, t1);
        });
    }
    /**
   * Inserts new block
   * Can be called when button clicked on Toolbox or by ShortcutData
   *
   * @param {string} toolName - Tool name
   * @param blockDataOverrides - predefined Block data
   */ async insertNewBlock(e, t1) {
        const o = this.api.blocks.getCurrentBlockIndex(), i = this.api.blocks.getBlockByIndex(o);
        if (!i) return;
        const s = i.isEmpty ? o : o + 1;
        let r;
        if (t1) {
            const l = await this.api.blocks.composeBlockData(e);
            r = Object.assign(l, t1);
        }
        const a = this.api.blocks.insert(e, r, void 0, s, void 0, i.isEmpty);
        a.call(ee.APPEND_CALLBACK), this.api.caret.setToBlock(s), this.emit("toolbox-block-added", {
            block: a
        }), this.api.toolbar.close();
    }
};
rn([
    me
], Ct.prototype, "toolsToBeDisplayed", 1);
rn([
    me
], Ct.prototype, "toolboxItemsToBeDisplayed", 1);
let Es = Ct;
const ln = "block hovered";
async function xs(n, e) {
    const t1 = navigator.keyboard;
    if (!t1) return e;
    try {
        return (await t1.getLayoutMap()).get(n) || e;
    } catch (o) {
        return console.error(o), e;
    }
}
class Bs extends E {
    /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */ constructor({ config: e, eventsDispatcher: t1 }){
        super({
            config: e,
            eventsDispatcher: t1
        }), this.toolboxInstance = null;
    }
    /**
   * CSS styles
   *
   * @returns {object}
   */ get CSS() {
        return {
            toolbar: "ce-toolbar",
            content: "ce-toolbar__content",
            actions: "ce-toolbar__actions",
            actionsOpened: "ce-toolbar__actions--opened",
            toolbarOpened: "ce-toolbar--opened",
            openedToolboxHolderModifier: "codex-editor--toolbox-opened",
            plusButton: "ce-toolbar__plus",
            plusButtonShortcut: "ce-toolbar__plus-shortcut",
            settingsToggler: "ce-toolbar__settings-btn",
            settingsTogglerHidden: "ce-toolbar__settings-btn--hidden"
        };
    }
    /**
   * Returns the Toolbar opening state
   *
   * @returns {boolean}
   */ get opened() {
        return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);
    }
    /**
   * Public interface for accessing the Toolbox
   */ get toolbox() {
        var e;
        return {
            opened: (e = this.toolboxInstance) == null ? void 0 : e.opened,
            close: ()=>{
                var t1;
                (t1 = this.toolboxInstance) == null || t1.close();
            },
            open: ()=>{
                if (this.toolboxInstance === null) {
                    S("toolbox.open() called before initialization is finished", "warn");
                    return;
                }
                this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();
            },
            toggle: ()=>{
                if (this.toolboxInstance === null) {
                    S("toolbox.toggle() called before initialization is finished", "warn");
                    return;
                }
                this.toolboxInstance.toggle();
            },
            hasFocus: ()=>{
                var t1;
                return (t1 = this.toolboxInstance) == null ? void 0 : t1.hasFocus();
            }
        };
    }
    /**
   * Block actions appearance manipulations
   */ get blockActions() {
        return {
            hide: ()=>{
                this.nodes.actions.classList.remove(this.CSS.actionsOpened);
            },
            show: ()=>{
                this.nodes.actions.classList.add(this.CSS.actionsOpened);
            }
        };
    }
    /**
   * Methods for working with Block Tunes toggler
   */ get blockTunesToggler() {
        return {
            hide: ()=>this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),
            show: ()=>this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)
        };
    }
    /**
   * Toggles read-only mode
   *
   * @param {boolean} readOnlyEnabled - read-only mode
   */ toggleReadOnly(e) {
        e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(()=>{
            this.drawUI(), this.enableModuleBindings();
        }, {
            timeout: 2e3
        });
    }
    /**
   * Move Toolbar to the passed (or current) Block
   *
   * @param block - block to move Toolbar near it
   */ moveAndOpen(e = this.Editor.BlockManager.currentBlock) {
        if (this.toolboxInstance === null) {
            S("Can't open Toolbar since Editor initialization is not finished yet", "warn");
            return;
        }
        if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e) return;
        this.hoveredBlock = e;
        const t1 = e.holder, { isMobile: o } = this.Editor.UI;
        let i;
        const s = 20, r = e.firstInput, a = t1.getBoundingClientRect(), l = r !== void 0 ? r.getBoundingClientRect() : null, c = l !== null ? l.top - a.top : null, u = c !== null ? c > s : void 0;
        if (o) i = t1.offsetTop + t1.offsetHeight;
        else if (r === void 0 || u) {
            const h = parseInt(window.getComputedStyle(e.pluginsContent).paddingTop);
            i = t1.offsetTop + h;
        } else {
            const h = li(r), p = parseInt(window.getComputedStyle(this.nodes.plusButton).height, 10), g = 8;
            i = t1.offsetTop + h - p + g + c;
        }
        this.nodes.wrapper.style.top = `${Math.floor(i)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();
    }
    /**
   * Close the Toolbar
   */ close() {
        var e, t1;
        this.Editor.ReadOnly.isEnabled || ((e = this.nodes.wrapper) == null || e.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t1 = this.toolboxInstance) == null || t1.close(), this.Editor.BlockSettings.close(), this.reset());
    }
    /**
   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion
   */ reset() {
        this.nodes.wrapper.style.top = "unset";
    }
    /**
   * Open Toolbar with Plus Button and Actions
   *
   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.
   *                                     This flag allows to open Toolbar without Actions.
   */ open(e = !0) {
        this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();
    }
    /**
   * Draws Toolbar elements
   */ async make() {
        this.nodes.wrapper = d.make("div", this.CSS.toolbar), [
            "content",
            "actions"
        ].forEach((s)=>{
            this.nodes[s] = d.make("div", this.CSS[s]);
        }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make("div", this.CSS.plusButton, {
            innerHTML: ts
        }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, "click", ()=>{
            $e(!0), this.plusButtonClicked();
        }, !1);
        const e = d.make("div");
        e.appendChild(document.createTextNode(z.ui(K.ui.toolbar.toolbox, "Add"))), e.appendChild(d.make("div", this.CSS.plusButtonShortcut, {
            textContent: "/"
        })), ze(this.nodes.plusButton, e, {
            hidingDelay: 400
        }), this.nodes.settingsToggler = d.make("span", this.CSS.settingsToggler, {
            innerHTML: es
        }), d.append(this.nodes.actions, this.nodes.settingsToggler);
        const t1 = d.make("div"), o = d.text(z.ui(K.ui.blockTunes.toggler, "Click to tune")), i = await xs("Slash", "/");
        t1.appendChild(o), t1.appendChild(d.make("div", this.CSS.plusButtonShortcut, {
            textContent: vt(`CMD + ${i}`)
        })), ze(this.nodes.settingsToggler, t1, {
            hidingDelay: 400
        }), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
    }
    /**
   * Creates the Toolbox instance and return it's rendered element
   */ makeToolbox() {
        return this.toolboxInstance = new Es({
            api: this.Editor.API.methods,
            tools: this.Editor.Tools.blockTools,
            i18nLabels: {
                filter: z.ui(K.ui.popover, "Filter"),
                nothingFound: z.ui(K.ui.popover, "Nothing found")
            }
        }), this.toolboxInstance.on(Le.Opened, ()=>{
            this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);
        }), this.toolboxInstance.on(Le.Closed, ()=>{
            this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);
        }), this.toolboxInstance.on(Le.BlockAdded, ({ block: e })=>{
            const { BlockManager: t1, Caret: o } = this.Editor, i = t1.getBlockById(e.id);
            i.inputs.length === 0 && (i === t1.lastBlock ? (t1.insertAtEnd(), o.setToBlock(t1.lastBlock)) : o.setToBlock(t1.nextBlock));
        }), this.toolboxInstance.getElement();
    }
    /**
   * Handler for Plus Button
   */ plusButtonClicked() {
        var e;
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e = this.toolboxInstance) == null || e.toggle();
    }
    /**
   * Enable bindings
   */ enableModuleBindings() {
        this.readOnlyMutableListeners.on(this.nodes.settingsToggler, "mousedown", (e)=>{
            var t1;
            e.stopPropagation(), this.settingsTogglerClicked(), (t1 = this.toolboxInstance) != null && t1.opened && this.toolboxInstance.close(), $e(!0);
        }, !0), be() || this.eventsDispatcher.on(ln, (e)=>{
            var t1;
            this.Editor.BlockSettings.opened || (t1 = this.toolboxInstance) != null && t1.opened || this.moveAndOpen(e.block);
        });
    }
    /**
   * Disable bindings
   */ disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
    }
    /**
   * Clicks on the Block Settings toggler
   */ settingsTogglerClicked() {
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);
    }
    /**
   * Draws Toolbar UI
   *
   * Toolbar contains BlockSettings and Toolbox.
   * That's why at first we draw its components and then Toolbar itself
   *
   * Steps:
   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on
   *  - Make itself and append dependent nodes to itself
   *
   */ drawUI() {
        this.Editor.BlockSettings.make(), this.make();
    }
    /**
   * Removes all created and saved HTMLElements
   * It is used in Read-Only mode
   */ destroy() {
        this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();
    }
}
var ae = /* @__PURE__ */ ((n)=>(n[n.Block = 0] = "Block", n[n.Inline = 1] = "Inline", n[n.Tune = 2] = "Tune", n))(ae || {}), Pe = /* @__PURE__ */ ((n)=>(n.Shortcut = "shortcut", n.Toolbox = "toolbox", n.EnabledInlineTools = "inlineToolbar", n.EnabledBlockTunes = "tunes", n.Config = "config", n))(Pe || {}), cn = /* @__PURE__ */ ((n)=>(n.Shortcut = "shortcut", n.SanitizeConfig = "sanitize", n))(cn || {}), pe = /* @__PURE__ */ ((n)=>(n.IsEnabledLineBreaks = "enableLineBreaks", n.Toolbox = "toolbox", n.ConversionConfig = "conversionConfig", n.IsReadOnlySupported = "isReadOnlySupported", n.PasteConfig = "pasteConfig", n))(pe || {}), We = /* @__PURE__ */ ((n)=>(n.IsInline = "isInline", n.Title = "title", n.IsReadOnlySupported = "isReadOnlySupported", n))(We || {}), mt = /* @__PURE__ */ ((n)=>(n.IsTune = "isTune", n))(mt || {});
class Tt {
    /**
   * @class
   * @param {ConstructorOptions} options - Constructor options
   */ constructor({ name: e, constructable: t1, config: o, api: i, isDefault: s, isInternal: r = !1, defaultPlaceholder: a }){
        this.api = i, this.name = e, this.constructable = t1, this.config = o, this.isDefault = s, this.isInternal = r, this.defaultPlaceholder = a;
    }
    /**
   * Returns Tool user configuration
   */ get settings() {
        const e = this.config.config || {};
        return this.isDefault && !("placeholder" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;
    }
    /**
   * Calls Tool's reset method
   */ reset() {
        if (A(this.constructable.reset)) return this.constructable.reset();
    }
    /**
   * Calls Tool's prepare method
   */ prepare() {
        if (A(this.constructable.prepare)) return this.constructable.prepare({
            toolName: this.name,
            config: this.settings
        });
    }
    /**
   * Returns shortcut for Tool (internal or specified by user)
   */ get shortcut() {
        const e = this.constructable.shortcut;
        return this.config.shortcut || e;
    }
    /**
   * Returns Tool's sanitizer configuration
   */ get sanitizeConfig() {
        return this.constructable.sanitize || {};
    }
    /**
   * Returns true if Tools is inline
   */ isInline() {
        return this.type === ae.Inline;
    }
    /**
   * Returns true if Tools is block
   */ isBlock() {
        return this.type === ae.Block;
    }
    /**
   * Returns true if Tools is tune
   */ isTune() {
        return this.type === ae.Tune;
    }
}
class Cs extends E {
    /**
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */ constructor({ config: e, eventsDispatcher: t1 }){
        super({
            config: e,
            eventsDispatcher: t1
        }), this.CSS = {
            inlineToolbar: "ce-inline-toolbar"
        }, this.opened = !1, this.popover = null, this.toolbarVerticalMargin = be() ? 20 : 6, this.tools = /* @__PURE__ */ new Map(), window.requestIdleCallback(()=>{
            this.make();
        }, {
            timeout: 2e3
        });
    }
    /**
   *  Moving / appearance
   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   */ /**
   * Shows Inline Toolbar if something is selected
   *
   * @param [needToClose] - pass true to close toolbar if it is not allowed.
   *                                  Avoid to use it just for closing IT, better call .close() clearly.
   */ async tryToShow(e = !1) {
        e && this.close(), this.allowedToShow() && (await this.open(), this.Editor.Toolbar.close());
    }
    /**
   * Hides Inline Toolbar
   */ close() {
        var e, t1;
        if (this.opened) {
            for (const [o, i] of this.tools){
                const s = this.getToolShortcut(o.name);
                s !== void 0 && ge.remove(this.Editor.UI.nodes.redactor, s), A(i.clear) && i.clear();
            }
            this.tools = /* @__PURE__ */ new Map(), this.reset(), this.opened = !1, (e = this.popover) == null || e.hide(), (t1 = this.popover) == null || t1.destroy(), this.popover = null;
        }
    }
    /**
   * Check if node is contained by Inline Toolbar
   *
   * @param {Node} node — node to check
   */ containsNode(e) {
        return this.nodes.wrapper === void 0 ? !1 : this.nodes.wrapper.contains(e);
    }
    /**
   * Removes UI and its components
   */ destroy() {
        var e;
        this.removeAllNodes(), (e = this.popover) == null || e.destroy(), this.popover = null;
    }
    /**
   * Making DOM
   */ make() {
        this.nodes.wrapper = d.make("div", [
            this.CSS.inlineToolbar,
            ...this.isRtl ? [
                this.Editor.UI.CSS.editorRtlFix
            ] : []
        ]), this.nodes.wrapper.setAttribute("data-cy", "inline-toolbar"), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
    }
    /**
   * Shows Inline Toolbar
   */ async open() {
        var t1;
        if (this.opened) return;
        this.opened = !0, this.popover !== null && this.popover.destroy(), this.createToolsInstances();
        const e = await this.getPopoverItems();
        this.popover = new hs({
            items: e,
            scopeElement: this.Editor.API.methods.ui.nodes.redactor,
            messages: {
                nothingFound: z.ui(K.ui.popover, "Nothing found"),
                search: z.ui(K.ui.popover, "Filter")
            }
        }), this.move(this.popover.size.width), (t1 = this.nodes.wrapper) == null || t1.append(this.popover.getElement()), this.popover.show();
    }
    /**
   * Move Toolbar to the selected text
   *
   * @param popoverWidth - width of the toolbar popover
   */ move(e) {
        const t1 = b.rect, o = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), i = {
            x: t1.x - o.x,
            y: t1.y + t1.height - // + window.scrollY
            o.top + this.toolbarVerticalMargin
        };
        i.x + e + o.x > this.Editor.UI.contentRect.right && (i.x = this.Editor.UI.contentRect.right - e - o.x), this.nodes.wrapper.style.left = Math.floor(i.x) + "px", this.nodes.wrapper.style.top = Math.floor(i.y) + "px";
    }
    /**
   * Clear orientation classes and reset position
   */ reset() {
        this.nodes.wrapper.style.left = "0", this.nodes.wrapper.style.top = "0";
    }
    /**
   * Need to show Inline Toolbar or not
   */ allowedToShow() {
        const e = [
            "IMG",
            "INPUT"
        ], t1 = b.get(), o = b.text;
        if (!t1 || !t1.anchorNode || t1.isCollapsed || o.length < 1) return !1;
        const i = d.isElement(t1.anchorNode) ? t1.anchorNode : t1.anchorNode.parentElement;
        if (i === null || t1 !== null && e.includes(i.tagName)) return !1;
        const s = this.Editor.BlockManager.getBlock(t1.anchorNode);
        return !s || this.getTools().some((c)=>s.tool.inlineTools.has(c.name)) === !1 ? !1 : i.closest("[contenteditable]") !== null;
    }
    /**
   *  Working with Tools
   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   */ /**
   * Returns tools that are available for current block
   *
   * Used to check if Inline Toolbar could be shown
   * and to render tools in the Inline Toolbar
   */ getTools() {
        const e = this.Editor.BlockManager.currentBlock;
        return e ? Array.from(e.tool.inlineTools.values()).filter((o)=>!(this.Editor.ReadOnly.isEnabled && o.isReadOnlySupported !== !0)) : [];
    }
    /**
   * Constructs tools instances and saves them to this.tools
   */ createToolsInstances() {
        this.tools = /* @__PURE__ */ new Map(), this.getTools().forEach((t1)=>{
            const o = t1.create();
            this.tools.set(t1, o);
        });
    }
    /**
   * Returns Popover Items for tools segregated by their appearance type: regular items and custom html elements.
   */ async getPopoverItems() {
        const e = [];
        let t1 = 0;
        for (const [o, i] of this.tools){
            const s = await i.render(), r = this.getToolShortcut(o.name);
            if (r !== void 0) try {
                this.enableShortcuts(o.name, r);
            } catch  {}
            const a = r !== void 0 ? vt(r) : void 0, l = z.t(K.toolNames, o.title || je(o.name));
            [
                s
            ].flat().forEach((c)=>{
                var h, p;
                const u = {
                    name: o.name,
                    onActivate: ()=>{
                        this.toolClicked(i);
                    },
                    hint: {
                        title: l,
                        description: a
                    }
                };
                if (d.isElement(c)) {
                    const g = {
                        ...u,
                        element: c,
                        type: _.Html
                    };
                    if (A(i.renderActions)) {
                        const f = i.renderActions();
                        g.children = {
                            isOpen: (h = i.checkState) == null ? void 0 : h.call(i, b.get()),
                            /** Disable keyboard navigation in actions, as it might conflict with enter press handling */ isFlippable: !1,
                            items: [
                                {
                                    type: _.Html,
                                    element: f
                                }
                            ]
                        };
                    } else (p = i.checkState) == null || p.call(i, b.get());
                    e.push(g);
                } else if (c.type === _.Html) e.push({
                    ...u,
                    ...c,
                    type: _.Html
                });
                else if (c.type === _.Separator) e.push({
                    type: _.Separator
                });
                else {
                    const g = {
                        ...u,
                        ...c,
                        type: _.Default
                    };
                    "children" in g && t1 !== 0 && e.push({
                        type: _.Separator
                    }), e.push(g), "children" in g && t1 < this.tools.size - 1 && e.push({
                        type: _.Separator
                    });
                }
            }), t1++;
        }
        return e;
    }
    /**
   * Get shortcut name for tool
   *
   * @param toolName — Tool name
   */ getToolShortcut(e) {
        const { Tools: t1 } = this.Editor, o = t1.inlineTools.get(e), i = t1.internal.inlineTools;
        return Array.from(i.keys()).includes(e) ? this.inlineTools[e][cn.Shortcut] : o == null ? void 0 : o.shortcut;
    }
    /**
   * Enable Tool shortcut with Editor Shortcuts Module
   *
   * @param toolName - tool name
   * @param shortcut - shortcut according to the ShortcutData Module format
   */ enableShortcuts(e, t1) {
        ge.add({
            name: t1,
            handler: (o)=>{
                var s;
                const { currentBlock: i } = this.Editor.BlockManager;
                i && i.tool.enabledInlineTools && (o.preventDefault(), (s = this.popover) == null || s.activateItemByName(e));
            },
            /**
       * We need to bind shortcut to the document to make it work in read-only mode
       */ on: document
        });
    }
    /**
   * Inline Tool button clicks
   *
   * @param tool - Tool's instance
   */ toolClicked(e) {
        var o;
        const t1 = b.range;
        (o = e.surround) == null || o.call(e, t1), this.checkToolsState();
    }
    /**
   * Check Tools` state by selection
   */ checkToolsState() {
        var e;
        (e = this.tools) == null || e.forEach((t1)=>{
            var o;
            (o = t1.checkState) == null || o.call(t1, b.get());
        });
    }
    /**
   * Get inline tools tools
   * Tools that has isInline is true
   */ get inlineTools() {
        const e = {};
        return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t1, o])=>{
            e[t1] = o.create();
        }), e;
    }
}
function dn() {
    const n = window.getSelection();
    if (n === null) return [
        null,
        0
    ];
    let e = n.focusNode, t1 = n.focusOffset;
    return e === null ? [
        null,
        0
    ] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t1] ? (e = e.childNodes[t1], t1 = 0) : (e = e.childNodes[t1 - 1], t1 = e.textContent.length)), [
        e,
        t1
    ]);
}
function un(n, e, t1, o) {
    const i = document.createRange();
    o === "left" ? (i.setStart(n, 0), i.setEnd(e, t1)) : (i.setStart(e, t1), i.setEnd(n, n.childNodes.length));
    const s = i.cloneContents(), r = document.createElement("div");
    r.appendChild(s);
    const a = r.textContent || "";
    return ai(a);
}
function Ne(n) {
    const e = d.getDeepestNode(n);
    if (e === null || d.isEmpty(n)) return !0;
    if (d.isNativeInput(e)) return e.selectionEnd === 0;
    if (d.isEmpty(n)) return !0;
    const [t1, o] = dn();
    return t1 === null ? !1 : un(n, t1, o, "left");
}
function Re(n) {
    const e = d.getDeepestNode(n, !0);
    if (e === null) return !0;
    if (d.isNativeInput(e)) return e.selectionEnd === e.value.length;
    const [t1, o] = dn();
    return t1 === null ? !1 : un(n, t1, o, "right");
}
var hn = {}, St = {}, Xe = {}, de = {}, It = {}, Ot = {};
Object.defineProperty(Ot, "__esModule", {
    value: !0
});
Ot.allInputsSelector = Ts;
function Ts() {
    var n = [
        "text",
        "password",
        "email",
        "number",
        "search",
        "tel",
        "url"
    ];
    return "[contenteditable=true], textarea, input:not([type]), " + n.map(function(e) {
        return 'input[type="'.concat(e, '"]');
    }).join(", ");
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.allInputsSelector = void 0;
    var e = Ot;
    Object.defineProperty(n, "allInputsSelector", {
        enumerable: !0,
        get: function() {
            return e.allInputsSelector;
        }
    });
})(It);
var ue = {}, _t = {};
Object.defineProperty(_t, "__esModule", {
    value: !0
});
_t.isNativeInput = Ss;
function Ss(n) {
    var e = [
        "INPUT",
        "TEXTAREA"
    ];
    return n && n.tagName ? e.includes(n.tagName) : !1;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isNativeInput = void 0;
    var e = _t;
    Object.defineProperty(n, "isNativeInput", {
        enumerable: !0,
        get: function() {
            return e.isNativeInput;
        }
    });
})(ue);
var pn = {}, Mt = {};
Object.defineProperty(Mt, "__esModule", {
    value: !0
});
Mt.append = Is;
function Is(n, e) {
    Array.isArray(e) ? e.forEach(function(t1) {
        n.appendChild(t1);
    }) : n.appendChild(e);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.append = void 0;
    var e = Mt;
    Object.defineProperty(n, "append", {
        enumerable: !0,
        get: function() {
            return e.append;
        }
    });
})(pn);
var At = {}, Lt = {};
Object.defineProperty(Lt, "__esModule", {
    value: !0
});
Lt.blockElements = Os;
function Os() {
    return [
        "address",
        "article",
        "aside",
        "blockquote",
        "canvas",
        "div",
        "dl",
        "dt",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "li",
        "main",
        "nav",
        "noscript",
        "ol",
        "output",
        "p",
        "pre",
        "ruby",
        "section",
        "table",
        "tbody",
        "thead",
        "tr",
        "tfoot",
        "ul",
        "video"
    ];
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.blockElements = void 0;
    var e = Lt;
    Object.defineProperty(n, "blockElements", {
        enumerable: !0,
        get: function() {
            return e.blockElements;
        }
    });
})(At);
var fn = {}, Pt = {};
Object.defineProperty(Pt, "__esModule", {
    value: !0
});
Pt.calculateBaseline = _s;
function _s(n) {
    var e = window.getComputedStyle(n), t1 = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t1 * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t1 * 0.8, l = (o - t1) / 2, c = r + s + i + l + a;
    return c;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.calculateBaseline = void 0;
    var e = Pt;
    Object.defineProperty(n, "calculateBaseline", {
        enumerable: !0,
        get: function() {
            return e.calculateBaseline;
        }
    });
})(fn);
var gn = {}, Nt = {}, Rt = {}, Dt = {};
Object.defineProperty(Dt, "__esModule", {
    value: !0
});
Dt.isContentEditable = Ms;
function Ms(n) {
    return n.contentEditable === "true";
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isContentEditable = void 0;
    var e = Dt;
    Object.defineProperty(n, "isContentEditable", {
        enumerable: !0,
        get: function() {
            return e.isContentEditable;
        }
    });
})(Rt);
Object.defineProperty(Nt, "__esModule", {
    value: !0
});
Nt.canSetCaret = Ps;
var As = ue, Ls = Rt;
function Ps(n) {
    var e = !0;
    if ((0, As.isNativeInput)(n)) switch(n.type){
        case "file":
        case "checkbox":
        case "radio":
        case "hidden":
        case "submit":
        case "button":
        case "image":
        case "reset":
            e = !1;
            break;
    }
    else e = (0, Ls.isContentEditable)(n);
    return e;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.canSetCaret = void 0;
    var e = Nt;
    Object.defineProperty(n, "canSetCaret", {
        enumerable: !0,
        get: function() {
            return e.canSetCaret;
        }
    });
})(gn);
var Ve = {}, Ft = {};
function Ns(n, e, t1) {
    const o = t1.value !== void 0 ? "value" : "get", i = t1[o], s = `#${e}Cache`;
    if (t1[o] = function(...r) {
        return this[s] === void 0 && (this[s] = i.apply(this, r)), this[s];
    }, o === "get" && t1.set) {
        const r = t1.set;
        t1.set = function(a) {
            delete n[s], r.apply(this, a);
        };
    }
    return t1;
}
function mn() {
    const n = {
        win: !1,
        mac: !1,
        x11: !1,
        linux: !1
    }, e = Object.keys(n).find((t1)=>window.navigator.appVersion.toLowerCase().indexOf(t1) !== -1);
    return e !== void 0 && (n[e] = !0), n;
}
function jt(n) {
    return n != null && n !== "" && (typeof n != "object" || Object.keys(n).length > 0);
}
function Rs(n) {
    return !jt(n);
}
const Ds = ()=>typeof window < "u" && window.navigator !== null && jt(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function Fs(n) {
    const e = mn();
    return n = n.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, "+"), e.mac ? n = n.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : n = n.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), n;
}
function js(n) {
    return n[0].toUpperCase() + n.slice(1);
}
function Hs(n) {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.left = "-999px", e.style.bottom = "-999px", e.innerHTML = n, document.body.appendChild(e);
    const t1 = window.getSelection(), o = document.createRange();
    if (o.selectNode(e), t1 === null) throw new Error("Cannot copy text to clipboard");
    t1.removeAllRanges(), t1.addRange(o), document.execCommand("copy"), document.body.removeChild(e);
}
function $s(n, e, t1) {
    let o;
    return (...i)=>{
        const s = this, r = ()=>{
            o = void 0, t1 !== !0 && n.apply(s, i);
        }, a = t1 === !0 && o !== void 0;
        window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);
    };
}
function oe(n) {
    return Object.prototype.toString.call(n).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function zs(n) {
    return oe(n) === "boolean";
}
function bn(n) {
    return oe(n) === "function" || oe(n) === "asyncfunction";
}
function Us(n) {
    return bn(n) && /^\s*class\s+/.test(n.toString());
}
function Ws(n) {
    return oe(n) === "number";
}
function De(n) {
    return oe(n) === "object";
}
function Ys(n) {
    return Promise.resolve(n) === n;
}
function Ks(n) {
    return oe(n) === "string";
}
function Xs(n) {
    return oe(n) === "undefined";
}
function bt(n, ...e) {
    if (!e.length) return n;
    const t1 = e.shift();
    if (De(n) && De(t1)) for(const o in t1)De(t1[o]) ? (n[o] === void 0 && Object.assign(n, {
        [o]: {}
    }), bt(n[o], t1[o])) : Object.assign(n, {
        [o]: t1[o]
    });
    return bt(n, ...e);
}
function Vs(n, e, t1) {
    const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t1}» instead.`;
    n && console.warn(o);
}
function qs(n) {
    try {
        return new URL(n).href;
    } catch  {}
    return n.substring(0, 2) === "//" ? window.location.protocol + n : window.location.origin + n;
}
function Zs(n) {
    return n > 47 && n < 58 || n === 32 || n === 13 || n === 229 || n > 64 && n < 91 || n > 95 && n < 112 || n > 185 && n < 193 || n > 218 && n < 223;
}
const Gs = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    DOWN: 40,
    RIGHT: 39,
    DELETE: 46,
    META: 91,
    SLASH: 191
}, Qs = {
    LEFT: 0,
    WHEEL: 1,
    RIGHT: 2,
    BACKWARD: 3,
    FORWARD: 4
};
let Js = class {
    constructor(){
        this.completed = Promise.resolve();
    }
    /**
   * Add new promise to queue
   * @param operation - promise should be added to queue
   */ add(e) {
        return new Promise((t1, o)=>{
            this.completed = this.completed.then(e).then(t1).catch(o);
        });
    }
};
function er(n, e, t1 = void 0) {
    let o, i, s, r = null, a = 0;
    t1 || (t1 = {});
    const l = function() {
        a = t1.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r === null && (o = i = null);
    };
    return function() {
        const c = Date.now();
        !a && t1.leading === !1 && (a = c);
        const u = e - (c - a);
        return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r === null && (o = i = null)) : !r && t1.trailing !== !1 && (r = setTimeout(l, u)), s;
    };
}
const tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    PromiseQueue: Js,
    beautifyShortcut: Fs,
    cacheable: Ns,
    capitalize: js,
    copyTextToClipboard: Hs,
    debounce: $s,
    deepMerge: bt,
    deprecationAssert: Vs,
    getUserOS: mn,
    getValidUrl: qs,
    isBoolean: zs,
    isClass: Us,
    isEmpty: Rs,
    isFunction: bn,
    isIosDevice: Ds,
    isNumber: Ws,
    isObject: De,
    isPrintableKey: Zs,
    isPromise: Ys,
    isString: Ks,
    isUndefined: Xs,
    keyCodes: Gs,
    mouseButtons: Qs,
    notEmpty: jt,
    throttle: er,
    typeOf: oe
}, Symbol.toStringTag, {
    value: "Module"
})), Ht = /* @__PURE__ */ Xn(tr);
Object.defineProperty(Ft, "__esModule", {
    value: !0
});
Ft.containsOnlyInlineElements = ir;
var or = Ht, nr = At;
function ir(n) {
    var e;
    (0, or.isString)(n) ? (e = document.createElement("div"), e.innerHTML = n) : e = n;
    var t1 = function(o) {
        return !(0, nr.blockElements)().includes(o.tagName.toLowerCase()) && Array.from(o.children).every(t1);
    };
    return Array.from(e.children).every(t1);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.containsOnlyInlineElements = void 0;
    var e = Ft;
    Object.defineProperty(n, "containsOnlyInlineElements", {
        enumerable: !0,
        get: function() {
            return e.containsOnlyInlineElements;
        }
    });
})(Ve);
var vn = {}, $t = {}, qe = {}, zt = {};
Object.defineProperty(zt, "__esModule", {
    value: !0
});
zt.make = sr;
function sr(n, e, t1) {
    var o;
    e === void 0 && (e = null), t1 === void 0 && (t1 = {});
    var i = document.createElement(n);
    if (Array.isArray(e)) {
        var s = e.filter(function(a) {
            return a !== void 0;
        });
        (o = i.classList).add.apply(o, s);
    } else e !== null && i.classList.add(e);
    for(var r in t1)Object.prototype.hasOwnProperty.call(t1, r) && (i[r] = t1[r]);
    return i;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.make = void 0;
    var e = zt;
    Object.defineProperty(n, "make", {
        enumerable: !0,
        get: function() {
            return e.make;
        }
    });
})(qe);
Object.defineProperty($t, "__esModule", {
    value: !0
});
$t.fragmentToString = ar;
var rr = qe;
function ar(n) {
    var e = (0, rr.make)("div");
    return e.appendChild(n), e.innerHTML;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.fragmentToString = void 0;
    var e = $t;
    Object.defineProperty(n, "fragmentToString", {
        enumerable: !0,
        get: function() {
            return e.fragmentToString;
        }
    });
})(vn);
var kn = {}, Ut = {};
Object.defineProperty(Ut, "__esModule", {
    value: !0
});
Ut.getContentLength = cr;
var lr = ue;
function cr(n) {
    var e, t1;
    return (0, lr.isNativeInput)(n) ? n.value.length : n.nodeType === Node.TEXT_NODE ? n.length : (t1 = (e = n.textContent) === null || e === void 0 ? void 0 : e.length) !== null && t1 !== void 0 ? t1 : 0;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.getContentLength = void 0;
    var e = Ut;
    Object.defineProperty(n, "getContentLength", {
        enumerable: !0,
        get: function() {
            return e.getContentLength;
        }
    });
})(kn);
var Wt = {}, Yt = {}, Io = Ce && Ce.__spreadArray || function(n, e, t1) {
    if (t1 || arguments.length === 2) for(var o = 0, i = e.length, s; o < i; o++)(s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);
    return n.concat(s || Array.prototype.slice.call(e));
};
Object.defineProperty(Yt, "__esModule", {
    value: !0
});
Yt.getDeepestBlockElements = yn;
var dr = Ve;
function yn(n) {
    return (0, dr.containsOnlyInlineElements)(n) ? [
        n
    ] : Array.from(n.children).reduce(function(e, t1) {
        return Io(Io([], e, !0), yn(t1), !0);
    }, []);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.getDeepestBlockElements = void 0;
    var e = Yt;
    Object.defineProperty(n, "getDeepestBlockElements", {
        enumerable: !0,
        get: function() {
            return e.getDeepestBlockElements;
        }
    });
})(Wt);
var wn = {}, Kt = {}, Ze = {}, Xt = {};
Object.defineProperty(Xt, "__esModule", {
    value: !0
});
Xt.isLineBreakTag = ur;
function ur(n) {
    return [
        "BR",
        "WBR"
    ].includes(n.tagName);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isLineBreakTag = void 0;
    var e = Xt;
    Object.defineProperty(n, "isLineBreakTag", {
        enumerable: !0,
        get: function() {
            return e.isLineBreakTag;
        }
    });
})(Ze);
var Ge = {}, Vt = {};
Object.defineProperty(Vt, "__esModule", {
    value: !0
});
Vt.isSingleTag = hr;
function hr(n) {
    return [
        "AREA",
        "BASE",
        "BR",
        "COL",
        "COMMAND",
        "EMBED",
        "HR",
        "IMG",
        "INPUT",
        "KEYGEN",
        "LINK",
        "META",
        "PARAM",
        "SOURCE",
        "TRACK",
        "WBR"
    ].includes(n.tagName);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isSingleTag = void 0;
    var e = Vt;
    Object.defineProperty(n, "isSingleTag", {
        enumerable: !0,
        get: function() {
            return e.isSingleTag;
        }
    });
})(Ge);
Object.defineProperty(Kt, "__esModule", {
    value: !0
});
Kt.getDeepestNode = En;
var pr = ue, fr = Ze, gr = Ge;
function En(n, e) {
    e === void 0 && (e = !1);
    var t1 = e ? "lastChild" : "firstChild", o = e ? "previousSibling" : "nextSibling";
    if (n.nodeType === Node.ELEMENT_NODE && n[t1]) {
        var i = n[t1];
        if ((0, gr.isSingleTag)(i) && !(0, pr.isNativeInput)(i) && !(0, fr.isLineBreakTag)(i)) if (i[o]) i = i[o];
        else if (i.parentNode !== null && i.parentNode[o]) i = i.parentNode[o];
        else return i.parentNode;
        return En(i, e);
    }
    return n;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.getDeepestNode = void 0;
    var e = Kt;
    Object.defineProperty(n, "getDeepestNode", {
        enumerable: !0,
        get: function() {
            return e.getDeepestNode;
        }
    });
})(wn);
var xn = {}, qt = {}, Me = Ce && Ce.__spreadArray || function(n, e, t1) {
    if (t1 || arguments.length === 2) for(var o = 0, i = e.length, s; o < i; o++)(s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);
    return n.concat(s || Array.prototype.slice.call(e));
};
Object.defineProperty(qt, "__esModule", {
    value: !0
});
qt.findAllInputs = yr;
var mr = Ve, br = Wt, vr = It, kr = ue;
function yr(n) {
    return Array.from(n.querySelectorAll((0, vr.allInputsSelector)())).reduce(function(e, t1) {
        return (0, kr.isNativeInput)(t1) || (0, mr.containsOnlyInlineElements)(t1) ? Me(Me([], e, !0), [
            t1
        ], !1) : Me(Me([], e, !0), (0, br.getDeepestBlockElements)(t1), !0);
    }, []);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.findAllInputs = void 0;
    var e = qt;
    Object.defineProperty(n, "findAllInputs", {
        enumerable: !0,
        get: function() {
            return e.findAllInputs;
        }
    });
})(xn);
var Bn = {}, Zt = {};
Object.defineProperty(Zt, "__esModule", {
    value: !0
});
Zt.isCollapsedWhitespaces = wr;
function wr(n) {
    return !/[^\t\n\r ]/.test(n);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isCollapsedWhitespaces = void 0;
    var e = Zt;
    Object.defineProperty(n, "isCollapsedWhitespaces", {
        enumerable: !0,
        get: function() {
            return e.isCollapsedWhitespaces;
        }
    });
})(Bn);
var Gt = {}, Qt = {};
Object.defineProperty(Qt, "__esModule", {
    value: !0
});
Qt.isElement = xr;
var Er = Ht;
function xr(n) {
    return (0, Er.isNumber)(n) ? !1 : !!n && !!n.nodeType && n.nodeType === Node.ELEMENT_NODE;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isElement = void 0;
    var e = Qt;
    Object.defineProperty(n, "isElement", {
        enumerable: !0,
        get: function() {
            return e.isElement;
        }
    });
})(Gt);
var Cn = {}, Jt = {}, eo = {}, to = {};
Object.defineProperty(to, "__esModule", {
    value: !0
});
to.isLeaf = Br;
function Br(n) {
    return n === null ? !1 : n.childNodes.length === 0;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isLeaf = void 0;
    var e = to;
    Object.defineProperty(n, "isLeaf", {
        enumerable: !0,
        get: function() {
            return e.isLeaf;
        }
    });
})(eo);
var oo = {}, no = {};
Object.defineProperty(no, "__esModule", {
    value: !0
});
no.isNodeEmpty = Or;
var Cr = Ze, Tr = Gt, Sr = ue, Ir = Ge;
function Or(n, e) {
    var t1 = "";
    return (0, Ir.isSingleTag)(n) && !(0, Cr.isLineBreakTag)(n) ? !1 : ((0, Tr.isElement)(n) && (0, Sr.isNativeInput)(n) ? t1 = n.value : n.textContent !== null && (t1 = n.textContent.replace("​", "")), e !== void 0 && (t1 = t1.replace(new RegExp(e, "g"), "")), t1.trim().length === 0);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isNodeEmpty = void 0;
    var e = no;
    Object.defineProperty(n, "isNodeEmpty", {
        enumerable: !0,
        get: function() {
            return e.isNodeEmpty;
        }
    });
})(oo);
Object.defineProperty(Jt, "__esModule", {
    value: !0
});
Jt.isEmpty = Ar;
var _r = eo, Mr = oo;
function Ar(n, e) {
    n.normalize();
    for(var t1 = [
        n
    ]; t1.length > 0;){
        var o = t1.shift();
        if (o) {
            if (n = o, (0, _r.isLeaf)(n) && !(0, Mr.isNodeEmpty)(n, e)) return !1;
            t1.push.apply(t1, Array.from(n.childNodes));
        }
    }
    return !0;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isEmpty = void 0;
    var e = Jt;
    Object.defineProperty(n, "isEmpty", {
        enumerable: !0,
        get: function() {
            return e.isEmpty;
        }
    });
})(Cn);
var Tn = {}, io = {};
Object.defineProperty(io, "__esModule", {
    value: !0
});
io.isFragment = Pr;
var Lr = Ht;
function Pr(n) {
    return (0, Lr.isNumber)(n) ? !1 : !!n && !!n.nodeType && n.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isFragment = void 0;
    var e = io;
    Object.defineProperty(n, "isFragment", {
        enumerable: !0,
        get: function() {
            return e.isFragment;
        }
    });
})(Tn);
var Sn = {}, so = {};
Object.defineProperty(so, "__esModule", {
    value: !0
});
so.isHTMLString = Rr;
var Nr = qe;
function Rr(n) {
    var e = (0, Nr.make)("div");
    return e.innerHTML = n, e.childElementCount > 0;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isHTMLString = void 0;
    var e = so;
    Object.defineProperty(n, "isHTMLString", {
        enumerable: !0,
        get: function() {
            return e.isHTMLString;
        }
    });
})(Sn);
var In = {}, ro = {};
Object.defineProperty(ro, "__esModule", {
    value: !0
});
ro.offset = Dr;
function Dr(n) {
    var e = n.getBoundingClientRect(), t1 = window.pageXOffset || document.documentElement.scrollLeft, o = window.pageYOffset || document.documentElement.scrollTop, i = e.top + o, s = e.left + t1;
    return {
        top: i,
        left: s,
        bottom: i + e.height,
        right: s + e.width
    };
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.offset = void 0;
    var e = ro;
    Object.defineProperty(n, "offset", {
        enumerable: !0,
        get: function() {
            return e.offset;
        }
    });
})(In);
var On = {}, ao = {};
Object.defineProperty(ao, "__esModule", {
    value: !0
});
ao.prepend = Fr;
function Fr(n, e) {
    Array.isArray(e) ? (e = e.reverse(), e.forEach(function(t1) {
        return n.prepend(t1);
    })) : n.prepend(e);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.prepend = void 0;
    var e = ao;
    Object.defineProperty(n, "prepend", {
        enumerable: !0,
        get: function() {
            return e.prepend;
        }
    });
})(On);
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.prepend = n.offset = n.make = n.isLineBreakTag = n.isSingleTag = n.isNodeEmpty = n.isLeaf = n.isHTMLString = n.isFragment = n.isEmpty = n.isElement = n.isContentEditable = n.isCollapsedWhitespaces = n.findAllInputs = n.isNativeInput = n.allInputsSelector = n.getDeepestNode = n.getDeepestBlockElements = n.getContentLength = n.fragmentToString = n.containsOnlyInlineElements = n.canSetCaret = n.calculateBaseline = n.blockElements = n.append = void 0;
    var e = It;
    Object.defineProperty(n, "allInputsSelector", {
        enumerable: !0,
        get: function() {
            return e.allInputsSelector;
        }
    });
    var t1 = ue;
    Object.defineProperty(n, "isNativeInput", {
        enumerable: !0,
        get: function() {
            return t1.isNativeInput;
        }
    });
    var o = pn;
    Object.defineProperty(n, "append", {
        enumerable: !0,
        get: function() {
            return o.append;
        }
    });
    var i = At;
    Object.defineProperty(n, "blockElements", {
        enumerable: !0,
        get: function() {
            return i.blockElements;
        }
    });
    var s = fn;
    Object.defineProperty(n, "calculateBaseline", {
        enumerable: !0,
        get: function() {
            return s.calculateBaseline;
        }
    });
    var r = gn;
    Object.defineProperty(n, "canSetCaret", {
        enumerable: !0,
        get: function() {
            return r.canSetCaret;
        }
    });
    var a = Ve;
    Object.defineProperty(n, "containsOnlyInlineElements", {
        enumerable: !0,
        get: function() {
            return a.containsOnlyInlineElements;
        }
    });
    var l = vn;
    Object.defineProperty(n, "fragmentToString", {
        enumerable: !0,
        get: function() {
            return l.fragmentToString;
        }
    });
    var c = kn;
    Object.defineProperty(n, "getContentLength", {
        enumerable: !0,
        get: function() {
            return c.getContentLength;
        }
    });
    var u = Wt;
    Object.defineProperty(n, "getDeepestBlockElements", {
        enumerable: !0,
        get: function() {
            return u.getDeepestBlockElements;
        }
    });
    var h = wn;
    Object.defineProperty(n, "getDeepestNode", {
        enumerable: !0,
        get: function() {
            return h.getDeepestNode;
        }
    });
    var p = xn;
    Object.defineProperty(n, "findAllInputs", {
        enumerable: !0,
        get: function() {
            return p.findAllInputs;
        }
    });
    var g = Bn;
    Object.defineProperty(n, "isCollapsedWhitespaces", {
        enumerable: !0,
        get: function() {
            return g.isCollapsedWhitespaces;
        }
    });
    var f = Rt;
    Object.defineProperty(n, "isContentEditable", {
        enumerable: !0,
        get: function() {
            return f.isContentEditable;
        }
    });
    var v = Gt;
    Object.defineProperty(n, "isElement", {
        enumerable: !0,
        get: function() {
            return v.isElement;
        }
    });
    var O = Cn;
    Object.defineProperty(n, "isEmpty", {
        enumerable: !0,
        get: function() {
            return O.isEmpty;
        }
    });
    var T = Tn;
    Object.defineProperty(n, "isFragment", {
        enumerable: !0,
        get: function() {
            return T.isFragment;
        }
    });
    var M = Sn;
    Object.defineProperty(n, "isHTMLString", {
        enumerable: !0,
        get: function() {
            return M.isHTMLString;
        }
    });
    var q = eo;
    Object.defineProperty(n, "isLeaf", {
        enumerable: !0,
        get: function() {
            return q.isLeaf;
        }
    });
    var F = oo;
    Object.defineProperty(n, "isNodeEmpty", {
        enumerable: !0,
        get: function() {
            return F.isNodeEmpty;
        }
    });
    var H = Ze;
    Object.defineProperty(n, "isLineBreakTag", {
        enumerable: !0,
        get: function() {
            return H.isLineBreakTag;
        }
    });
    var Q = Ge;
    Object.defineProperty(n, "isSingleTag", {
        enumerable: !0,
        get: function() {
            return Q.isSingleTag;
        }
    });
    var ie = qe;
    Object.defineProperty(n, "make", {
        enumerable: !0,
        get: function() {
            return ie.make;
        }
    });
    var k = In;
    Object.defineProperty(n, "offset", {
        enumerable: !0,
        get: function() {
            return k.offset;
        }
    });
    var m = On;
    Object.defineProperty(n, "prepend", {
        enumerable: !0,
        get: function() {
            return m.prepend;
        }
    });
})(de);
var Qe = {};
Object.defineProperty(Qe, "__esModule", {
    value: !0
});
Qe.getContenteditableSlice = Hr;
var jr = de;
function Hr(n, e, t1, o, i) {
    var s;
    i === void 0 && (i = !1);
    var r = document.createRange();
    if (o === "left" ? (r.setStart(n, 0), r.setEnd(e, t1)) : (r.setStart(e, t1), r.setEnd(n, n.childNodes.length)), i === !0) {
        var a = r.extractContents();
        return (0, jr.fragmentToString)(a);
    }
    var l = r.cloneContents(), c = document.createElement("div");
    c.appendChild(l);
    var u = (s = c.textContent) !== null && s !== void 0 ? s : "";
    return u;
}
Object.defineProperty(Xe, "__esModule", {
    value: !0
});
Xe.checkContenteditableSliceForEmptiness = Ur;
var $r = de, zr = Qe;
function Ur(n, e, t1, o) {
    var i = (0, zr.getContenteditableSlice)(n, e, t1, o);
    return (0, $r.isCollapsedWhitespaces)(i);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.checkContenteditableSliceForEmptiness = void 0;
    var e = Xe;
    Object.defineProperty(n, "checkContenteditableSliceForEmptiness", {
        enumerable: !0,
        get: function() {
            return e.checkContenteditableSliceForEmptiness;
        }
    });
})(St);
var _n = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.getContenteditableSlice = void 0;
    var e = Qe;
    Object.defineProperty(n, "getContenteditableSlice", {
        enumerable: !0,
        get: function() {
            return e.getContenteditableSlice;
        }
    });
})(_n);
var Mn = {}, lo = {};
Object.defineProperty(lo, "__esModule", {
    value: !0
});
lo.focus = Yr;
var Wr = de;
function Yr(n, e) {
    var t1, o;
    if (e === void 0 && (e = !0), (0, Wr.isNativeInput)(n)) {
        n.focus();
        var i = e ? 0 : n.value.length;
        n.setSelectionRange(i, i);
    } else {
        var s = document.createRange(), r = window.getSelection();
        if (!r) return;
        var a = function(p) {
            var g = document.createTextNode("");
            p.appendChild(g), s.setStart(g, 0), s.setEnd(g, 0);
        }, l = function(p) {
            return p != null;
        }, c = n.childNodes, u = e ? c[0] : c[c.length - 1];
        if (l(u)) {
            for(; l(u) && u.nodeType !== Node.TEXT_NODE;)u = e ? u.firstChild : u.lastChild;
            if (l(u) && u.nodeType === Node.TEXT_NODE) {
                var h = (o = (t1 = u.textContent) === null || t1 === void 0 ? void 0 : t1.length) !== null && o !== void 0 ? o : 0, i = e ? 0 : h;
                s.setStart(u, i), s.setEnd(u, i);
            } else a(n);
        } else a(n);
        r.removeAllRanges(), r.addRange(s);
    }
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.focus = void 0;
    var e = lo;
    Object.defineProperty(n, "focus", {
        enumerable: !0,
        get: function() {
            return e.focus;
        }
    });
})(Mn);
var co = {}, Je = {};
Object.defineProperty(Je, "__esModule", {
    value: !0
});
Je.getCaretNodeAndOffset = Kr;
function Kr() {
    var n = window.getSelection();
    if (n === null) return [
        null,
        0
    ];
    var e = n.focusNode, t1 = n.focusOffset;
    return e === null ? [
        null,
        0
    ] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t1] !== void 0 ? (e = e.childNodes[t1], t1 = 0) : (e = e.childNodes[t1 - 1], e.textContent !== null && (t1 = e.textContent.length))), [
        e,
        t1
    ]);
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.getCaretNodeAndOffset = void 0;
    var e = Je;
    Object.defineProperty(n, "getCaretNodeAndOffset", {
        enumerable: !0,
        get: function() {
            return e.getCaretNodeAndOffset;
        }
    });
})(co);
var An = {}, et = {};
Object.defineProperty(et, "__esModule", {
    value: !0
});
et.getRange = Xr;
function Xr() {
    var n = window.getSelection();
    return n && n.rangeCount ? n.getRangeAt(0) : null;
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.getRange = void 0;
    var e = et;
    Object.defineProperty(n, "getRange", {
        enumerable: !0,
        get: function() {
            return e.getRange;
        }
    });
})(An);
var Ln = {}, uo = {};
Object.defineProperty(uo, "__esModule", {
    value: !0
});
uo.isCaretAtEndOfInput = Zr;
var Oo = de, Vr = co, qr = St;
function Zr(n) {
    var e = (0, Oo.getDeepestNode)(n, !0);
    if (e === null) return !0;
    if ((0, Oo.isNativeInput)(e)) return e.selectionEnd === e.value.length;
    var t1 = (0, Vr.getCaretNodeAndOffset)(), o = t1[0], i = t1[1];
    return o === null ? !1 : (0, qr.checkContenteditableSliceForEmptiness)(n, o, i, "right");
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isCaretAtEndOfInput = void 0;
    var e = uo;
    Object.defineProperty(n, "isCaretAtEndOfInput", {
        enumerable: !0,
        get: function() {
            return e.isCaretAtEndOfInput;
        }
    });
})(Ln);
var Pn = {}, ho = {};
Object.defineProperty(ho, "__esModule", {
    value: !0
});
ho.isCaretAtStartOfInput = Jr;
var Ae = de, Gr = Je, Qr = Xe;
function Jr(n) {
    var e = (0, Ae.getDeepestNode)(n);
    if (e === null || (0, Ae.isEmpty)(n)) return !0;
    if ((0, Ae.isNativeInput)(e)) return e.selectionEnd === 0;
    if ((0, Ae.isEmpty)(n)) return !0;
    var t1 = (0, Gr.getCaretNodeAndOffset)(), o = t1[0], i = t1[1];
    return o === null ? !1 : (0, Qr.checkContenteditableSliceForEmptiness)(n, o, i, "left");
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.isCaretAtStartOfInput = void 0;
    var e = ho;
    Object.defineProperty(n, "isCaretAtStartOfInput", {
        enumerable: !0,
        get: function() {
            return e.isCaretAtStartOfInput;
        }
    });
})(Pn);
var Nn = {}, po = {};
Object.defineProperty(po, "__esModule", {
    value: !0
});
po.save = oa;
var ea = de, ta = et;
function oa() {
    var n = (0, ta.getRange)(), e = (0, ea.make)("span");
    if (e.id = "cursor", e.hidden = !0, !!n) return n.insertNode(e), function() {
        var o = window.getSelection();
        o && (n.setStartAfter(e), n.setEndAfter(e), o.removeAllRanges(), o.addRange(n), setTimeout(function() {
            e.remove();
        }, 150));
    };
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.save = void 0;
    var e = po;
    Object.defineProperty(n, "save", {
        enumerable: !0,
        get: function() {
            return e.save;
        }
    });
})(Nn);
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.save = n.isCaretAtStartOfInput = n.isCaretAtEndOfInput = n.getRange = n.getCaretNodeAndOffset = n.focus = n.getContenteditableSlice = n.checkContenteditableSliceForEmptiness = void 0;
    var e = St;
    Object.defineProperty(n, "checkContenteditableSliceForEmptiness", {
        enumerable: !0,
        get: function() {
            return e.checkContenteditableSliceForEmptiness;
        }
    });
    var t1 = _n;
    Object.defineProperty(n, "getContenteditableSlice", {
        enumerable: !0,
        get: function() {
            return t1.getContenteditableSlice;
        }
    });
    var o = Mn;
    Object.defineProperty(n, "focus", {
        enumerable: !0,
        get: function() {
            return o.focus;
        }
    });
    var i = co;
    Object.defineProperty(n, "getCaretNodeAndOffset", {
        enumerable: !0,
        get: function() {
            return i.getCaretNodeAndOffset;
        }
    });
    var s = An;
    Object.defineProperty(n, "getRange", {
        enumerable: !0,
        get: function() {
            return s.getRange;
        }
    });
    var r = Ln;
    Object.defineProperty(n, "isCaretAtEndOfInput", {
        enumerable: !0,
        get: function() {
            return r.isCaretAtEndOfInput;
        }
    });
    var a = Pn;
    Object.defineProperty(n, "isCaretAtStartOfInput", {
        enumerable: !0,
        get: function() {
            return a.isCaretAtStartOfInput;
        }
    });
    var l = Nn;
    Object.defineProperty(n, "save", {
        enumerable: !0,
        get: function() {
            return l.save;
        }
    });
})(hn);
class na extends E {
    /**
   * All keydowns on Block
   *
   * @param {KeyboardEvent} event - keydown
   */ keydown(e) {
        switch(this.beforeKeydownProcessing(e), e.keyCode){
            case y.BACKSPACE:
                this.backspace(e);
                break;
            case y.DELETE:
                this.delete(e);
                break;
            case y.ENTER:
                this.enter(e);
                break;
            case y.DOWN:
            case y.RIGHT:
                this.arrowRightAndDown(e);
                break;
            case y.UP:
            case y.LEFT:
                this.arrowLeftAndUp(e);
                break;
            case y.TAB:
                this.tabPressed(e);
                break;
        }
        e.key === "/" && !e.ctrlKey && !e.metaKey && this.slashPressed(e), e.code === "Slash" && (e.ctrlKey || e.metaKey) && (e.preventDefault(), this.commandSlashPressed());
    }
    /**
   * Fires on keydown before event processing
   *
   * @param {KeyboardEvent} event - keydown
   */ beforeKeydownProcessing(e) {
        this.needToolbarClosing(e) && Po(e.keyCode) && (this.Editor.Toolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || this.Editor.BlockSelection.clearSelection(e));
    }
    /**
   * Key up on Block:
   * - shows Inline Toolbar if something selected
   * - shows conversion toolbar with 85% of block selection
   *
   * @param {KeyboardEvent} event - keyup event
   */ keyup(e) {
        e.shiftKey || this.Editor.UI.checkEmptiness();
    }
    /**
   * Add drop target styles
   *
   * @param {DragEvent} event - drag over event
   */ dragOver(e) {
        const t1 = this.Editor.BlockManager.getBlockByChildNode(e.target);
        t1.dropTarget = !0;
    }
    /**
   * Remove drop target style
   *
   * @param {DragEvent} event - drag leave event
   */ dragLeave(e) {
        const t1 = this.Editor.BlockManager.getBlockByChildNode(e.target);
        t1.dropTarget = !1;
    }
    /**
   * Copying selected blocks
   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard
   *
   * @param {ClipboardEvent} event - clipboard event
   */ handleCommandC(e) {
        const { BlockSelection: t1 } = this.Editor;
        t1.anyBlockSelected && t1.copySelectedBlocks(e);
    }
    /**
   * Copy and Delete selected Blocks
   *
   * @param {ClipboardEvent} event - clipboard event
   */ handleCommandX(e) {
        const { BlockSelection: t1, BlockManager: o, Caret: i } = this.Editor;
        t1.anyBlockSelected && t1.copySelectedBlocks(e).then(()=>{
            const s = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(s, !0);
            i.setToBlock(r, i.positions.START), t1.clearSelection(e);
        });
    }
    /**
   * Tab pressed inside a Block.
   *
   * @param {KeyboardEvent} event - keydown
   */ tabPressed(e) {
        const { InlineToolbar: t1, Caret: o } = this.Editor;
        if (t1.opened) return;
        (e.shiftKey ? o.navigatePrevious(!0) : o.navigateNext(!0)) && e.preventDefault();
    }
    /**
   * '/' + 'command' keydown inside a Block
   */ commandSlashPressed() {
        this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();
    }
    /**
   * '/' keydown inside a Block
   *
   * @param event - keydown
   */ slashPressed(e) {
        this.Editor.BlockManager.currentBlock.isEmpty && (e.preventDefault(), this.Editor.Caret.insertContentAtCaretPosition("/"), this.activateToolbox());
    }
    /**
   * ENTER pressed on block
   *
   * @param {KeyboardEvent} event - keydown
   */ enter(e) {
        const { BlockManager: t1, UI: o } = this.Editor, i = t1.currentBlock;
        if (i === void 0 || i.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey && !pt) return;
        let s = i;
        i.currentInput !== void 0 && Ne(i.currentInput) && !i.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : i.currentInput && Re(i.currentInput) ? s = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : s = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s), e.preventDefault();
    }
    /**
   * Handle backspace keydown on Block
   *
   * @param {KeyboardEvent} event - keydown
   */ backspace(e) {
        const { BlockManager: t1, Caret: o } = this.Editor, { currentBlock: i, previousBlock: s } = t1;
        if (i === void 0 || !b.isCollapsed || !i.currentInput || !Ne(i.currentInput)) return;
        if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.firstInput)) {
            o.navigatePrevious();
            return;
        }
        if (s === null) return;
        if (s.isEmpty) {
            t1.removeBlock(s);
            return;
        }
        if (i.isEmpty) {
            t1.removeBlock(i);
            const l = t1.currentBlock;
            o.setToBlock(l, o.positions.END);
            return;
        }
        xo(s, i) ? this.mergeBlocks(s, i) : o.setToBlock(s, o.positions.END);
    }
    /**
   * Handles delete keydown on Block
   * Removes char after the caret.
   * If caret is at the end of the block, merge next block with current
   *
   * @param {KeyboardEvent} event - keydown
   */ delete(e) {
        const { BlockManager: t1, Caret: o } = this.Editor, { currentBlock: i, nextBlock: s } = t1;
        if (!b.isCollapsed || !Re(i.currentInput)) return;
        if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.lastInput)) {
            o.navigateNext();
            return;
        }
        if (s === null) return;
        if (s.isEmpty) {
            t1.removeBlock(s);
            return;
        }
        if (i.isEmpty) {
            t1.removeBlock(i), o.setToBlock(s, o.positions.START);
            return;
        }
        xo(i, s) ? this.mergeBlocks(i, s) : o.setToBlock(s, o.positions.START);
    }
    /**
   * Merge passed Blocks
   *
   * @param targetBlock - to which Block we want to merge
   * @param blockToMerge - what Block we want to merge
   */ mergeBlocks(e, t1) {
        const { BlockManager: o, Toolbar: i } = this.Editor;
        e.lastInput !== void 0 && (hn.focus(e.lastInput, !1), o.mergeBlocks(e, t1).then(()=>{
            i.close();
        }));
    }
    /**
   * Handle right and down keyboard keys
   *
   * @param {KeyboardEvent} event - keyboard event
   */ arrowRightAndDown(e) {
        const t1 = ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB);
        if (this.Editor.UI.someToolbarOpened && t1) return;
        this.Editor.Toolbar.close();
        const { currentBlock: o } = this.Editor.BlockManager, s = ((o == null ? void 0 : o.currentInput) !== void 0 ? Re(o.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;
        if (e.shiftKey && e.keyCode === y.DOWN && s) {
            this.Editor.CrossBlockSelection.toggleBlockSelectedState();
            return;
        }
        if (e.keyCode === y.DOWN || e.keyCode === y.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {
            e.preventDefault();
            return;
        }
        Fe(()=>{
            this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
        }, 20)(), this.Editor.BlockSelection.clearSelection(e);
    }
    /**
   * Handle left and up keyboard keys
   *
   * @param {KeyboardEvent} event - keyboard event
   */ arrowLeftAndUp(e) {
        if (this.Editor.UI.someToolbarOpened) {
            if (ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB)) return;
            this.Editor.UI.closeAllToolbars();
        }
        this.Editor.Toolbar.close();
        const { currentBlock: t1 } = this.Editor.BlockManager, i = ((t1 == null ? void 0 : t1.currentInput) !== void 0 ? Ne(t1.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;
        if (e.shiftKey && e.keyCode === y.UP && i) {
            this.Editor.CrossBlockSelection.toggleBlockSelectedState(!1);
            return;
        }
        if (e.keyCode === y.UP || e.keyCode === y.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {
            e.preventDefault();
            return;
        }
        Fe(()=>{
            this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
        }, 20)(), this.Editor.BlockSelection.clearSelection(e);
    }
    /**
   * Cases when we need to close Toolbar
   *
   * @param {KeyboardEvent} event - keyboard event
   */ needToolbarClosing(e) {
        const t1 = e.keyCode === y.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === y.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === y.ENTER && this.Editor.InlineToolbar.opened, s = e.keyCode === y.TAB;
        return !(e.shiftKey || s || t1 || o || i);
    }
    /**
   * If Toolbox is not open, then just open it and show plus button
   */ activateToolbox() {
        this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();
    }
    /**
   * Open Toolbar and show BlockSettings before flipping Tools
   */ activateBlockSettings() {
        this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();
    }
}
class ct {
    /**
   * @class
   * @param {HTMLElement} workingArea — editor`s working node
   */ constructor(e){
        this.blocks = [], this.workingArea = e;
    }
    /**
   * Get length of Block instances array
   *
   * @returns {number}
   */ get length() {
        return this.blocks.length;
    }
    /**
   * Get Block instances array
   *
   * @returns {Block[]}
   */ get array() {
        return this.blocks;
    }
    /**
   * Get blocks html elements array
   *
   * @returns {HTMLElement[]}
   */ get nodes() {
        return No(this.workingArea.children);
    }
    /**
   * Proxy trap to implement array-like setter
   *
   * @example
   * blocks[0] = new Block(...)
   * @param {Blocks} instance — Blocks instance
   * @param {PropertyKey} property — block index or any Blocks class property key to set
   * @param {Block} value — value to set
   * @returns {boolean}
   */ static set(e, t1, o) {
        return isNaN(Number(t1)) ? (Reflect.set(e, t1, o), !0) : (e.insert(+t1, o), !0);
    }
    /**
   * Proxy trap to implement array-like getter
   *
   * @param {Blocks} instance — Blocks instance
   * @param {PropertyKey} property — Blocks class property key
   * @returns {Block|*}
   */ static get(e, t1) {
        return isNaN(Number(t1)) ? Reflect.get(e, t1) : e.get(+t1);
    }
    /**
   * Push new Block to the blocks array and append it to working area
   *
   * @param {Block} block - Block to add
   */ push(e) {
        this.blocks.push(e), this.insertToDOM(e);
    }
    /**
   * Swaps blocks with indexes first and second
   *
   * @param {number} first - first block index
   * @param {number} second - second block index
   * @deprecated — use 'move' instead
   */ swap(e, t1) {
        const o = this.blocks[t1];
        d.swap(this.blocks[e].holder, o.holder), this.blocks[t1] = this.blocks[e], this.blocks[e] = o;
    }
    /**
   * Move a block from one to another index
   *
   * @param {number} toIndex - new index of the block
   * @param {number} fromIndex - block to move
   */ move(e, t1) {
        const o = this.blocks.splice(t1, 1)[0], i = e - 1, s = Math.max(0, i), r = this.blocks[s];
        e > 0 ? this.insertToDOM(o, "afterend", r) : this.insertToDOM(o, "beforebegin", r), this.blocks.splice(e, 0, o);
        const a = this.composeBlockEvent("move", {
            fromIndex: t1,
            toIndex: e
        });
        o.call(ee.MOVED, a);
    }
    /**
   * Insert new Block at passed index
   *
   * @param {number} index — index to insert Block
   * @param {Block} block — Block to insert
   * @param {boolean} replace — it true, replace block on given index
   */ insert(e, t1, o = !1) {
        if (!this.length) {
            this.push(t1);
            return;
        }
        e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED));
        const i = o ? 1 : 0;
        if (this.blocks.splice(e, i, t1), e > 0) {
            const s = this.blocks[e - 1];
            this.insertToDOM(t1, "afterend", s);
        } else {
            const s = this.blocks[e + 1];
            s ? this.insertToDOM(t1, "beforebegin", s) : this.insertToDOM(t1);
        }
    }
    /**
   * Replaces block under passed index with passed block
   *
   * @param index - index of existed block
   * @param block - new block
   */ replace(e, t1) {
        if (this.blocks[e] === void 0) throw Error("Incorrect index");
        this.blocks[e].holder.replaceWith(t1.holder), this.blocks[e] = t1;
    }
    /**
   * Inserts several blocks at once
   *
   * @param blocks - blocks to insert
   * @param index - index to insert blocks at
   */ insertMany(e, t1) {
        const o = new DocumentFragment();
        for (const i of e)o.appendChild(i.holder);
        if (this.length > 0) {
            if (t1 > 0) {
                const i = Math.min(t1 - 1, this.length - 1);
                this.blocks[i].holder.after(o);
            } else t1 === 0 && this.workingArea.prepend(o);
            this.blocks.splice(t1, 0, ...e);
        } else this.blocks.push(...e), this.workingArea.appendChild(o);
        e.forEach((i)=>i.call(ee.RENDERED));
    }
    /**
   * Remove block
   *
   * @param {number} index - index of Block to remove
   */ remove(e) {
        isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED), this.blocks.splice(e, 1);
    }
    /**
   * Remove all blocks
   */ removeAll() {
        this.workingArea.innerHTML = "", this.blocks.forEach((e)=>e.call(ee.REMOVED)), this.blocks.length = 0;
    }
    /**
   * Insert Block after passed target
   *
   * @todo decide if this method is necessary
   * @param {Block} targetBlock — target after which Block should be inserted
   * @param {Block} newBlock — Block to insert
   */ insertAfter(e, t1) {
        const o = this.blocks.indexOf(e);
        this.insert(o + 1, t1);
    }
    /**
   * Get Block by index
   *
   * @param {number} index — Block index
   * @returns {Block}
   */ get(e) {
        return this.blocks[e];
    }
    /**
   * Return index of passed Block
   *
   * @param {Block} block - Block to find
   * @returns {number}
   */ indexOf(e) {
        return this.blocks.indexOf(e);
    }
    /**
   * Insert new Block into DOM
   *
   * @param {Block} block - Block to insert
   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)
   * @param {Block} target — Block related to position
   */ insertToDOM(e, t1, o) {
        t1 ? o.holder.insertAdjacentElement(t1, e.holder) : this.workingArea.appendChild(e.holder), e.call(ee.RENDERED);
    }
    /**
   * Composes Block event with passed type and details
   *
   * @param {string} type - event type
   * @param {object} detail - event detail
   */ composeBlockEvent(e, t1) {
        return new CustomEvent(e, {
            detail: t1
        });
    }
}
const _o = "block-removed", Mo = "block-added", ia = "block-moved", Ao = "block-changed";
class sa {
    constructor(){
        this.completed = Promise.resolve();
    }
    /**
   * Add new promise to queue
   *
   * @param operation - promise should be added to queue
   */ add(e) {
        return new Promise((t1, o)=>{
            this.completed = this.completed.then(e).then(t1).catch(o);
        });
    }
}
class ra extends E {
    constructor(){
        super(...arguments), this._currentBlockIndex = -1, this._blocks = null;
    }
    /**
   * Returns current Block index
   *
   * @returns {number}
   */ get currentBlockIndex() {
        return this._currentBlockIndex;
    }
    /**
   * Set current Block index and fire Block lifecycle callbacks
   *
   * @param {number} newIndex - index of Block to set as current
   */ set currentBlockIndex(e) {
        this._currentBlockIndex = e;
    }
    /**
   * returns first Block
   *
   * @returns {Block}
   */ get firstBlock() {
        return this._blocks[0];
    }
    /**
   * returns last Block
   *
   * @returns {Block}
   */ get lastBlock() {
        return this._blocks[this._blocks.length - 1];
    }
    /**
   * Get current Block instance
   *
   * @returns {Block}
   */ get currentBlock() {
        return this._blocks[this.currentBlockIndex];
    }
    /**
   * Set passed Block as a current
   *
   * @param block - block to set as a current
   */ set currentBlock(e) {
        this.currentBlockIndex = this.getBlockIndex(e);
    }
    /**
   * Returns next Block instance
   *
   * @returns {Block|null}
   */ get nextBlock() {
        return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];
    }
    /**
   * Return first Block with inputs after current Block
   *
   * @returns {Block | undefined}
   */ get nextContentfulBlock() {
        return this.blocks.slice(this.currentBlockIndex + 1).find((t1)=>!!t1.inputs.length);
    }
    /**
   * Return first Block with inputs before current Block
   *
   * @returns {Block | undefined}
   */ get previousContentfulBlock() {
        return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t1)=>!!t1.inputs.length);
    }
    /**
   * Returns previous Block instance
   *
   * @returns {Block|null}
   */ get previousBlock() {
        return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];
    }
    /**
   * Get array of Block instances
   *
   * @returns {Block[]} {@link Blocks#array}
   */ get blocks() {
        return this._blocks.array;
    }
    /**
   * Check if each Block is empty
   *
   * @returns {boolean}
   */ get isEditorEmpty() {
        return this.blocks.every((e)=>e.isEmpty);
    }
    /**
   * Should be called after Editor.UI preparation
   * Define this._blocks property
   */ prepare() {
        const e = new ct(this.Editor.UI.nodes.redactor);
        this._blocks = new Proxy(e, {
            set: ct.set,
            get: ct.get
        }), this.listeners.on(document, "copy", (t1)=>this.Editor.BlockEvents.handleCommandC(t1));
    }
    /**
   * Toggle read-only state
   *
   * If readOnly is true:
   *  - Unbind event handlers from created Blocks
   *
   * if readOnly is false:
   *  - Bind event handlers to all existing Blocks
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */ toggleReadOnly(e) {
        e ? this.disableModuleBindings() : this.enableModuleBindings();
    }
    /**
   * Creates Block instance by tool name
   *
   * @param {object} options - block creation options
   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}
   * @param {string} [options.id] - unique id for this block
   * @param {BlockToolData} [options.data] - constructor params
   * @returns {Block}
   */ composeBlock({ tool: e, data: t1 = {}, id: o = void 0, tunes: i = {} }) {
        const s = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), a = new R({
            id: o,
            data: t1,
            tool: r,
            api: this.Editor.API,
            readOnly: s,
            tunesData: i
        }, this.eventsDispatcher);
        return s || window.requestIdleCallback(()=>{
            this.bindBlockEvents(a);
        }, {
            timeout: 2e3
        }), a;
    }
    /**
   * Insert new block into _blocks
   *
   * @param {object} options - insert options
   * @param {string} [options.id] - block's unique id
   * @param {string} [options.tool] - plugin name, by default method inserts the default block type
   * @param {object} [options.data] - plugin data
   * @param {number} [options.index] - index where to insert new Block
   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index
   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one
   * @returns {Block}
   */ insert({ id: e = void 0, tool: t1 = this.config.defaultBlock, data: o = {}, index: i, needToFocus: s = !0, replace: r = !1, tunes: a = {} } = {}) {
        let l = i;
        l === void 0 && (l = this.currentBlockIndex + (r ? 0 : 1));
        const c = this.composeBlock({
            id: e,
            tool: t1,
            data: o,
            tunes: a
        });
        return r && this.blockDidMutated(_o, this.getBlockByIndex(l), {
            index: l
        }), this._blocks.insert(l, c, r), this.blockDidMutated(Mo, c, {
            index: l
        }), s ? this.currentBlockIndex = l : l <= this.currentBlockIndex && this.currentBlockIndex++, c;
    }
    /**
   * Inserts several blocks at once
   *
   * @param blocks - blocks to insert
   * @param index - index where to insert
   */ insertMany(e, t1 = 0) {
        this._blocks.insertMany(e, t1);
    }
    /**
   * Update Block data.
   *
   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type
   * Should not trigger 'block-removed' or 'block-added' events.
   *
   * If neither data nor tunes is provided, return the provided block instead.
   *
   * @param block - block to update
   * @param data - (optional) new data
   * @param tunes - (optional) tune data
   */ async update(e, t1, o) {
        if (!t1 && !o) return e;
        const i = await e.data, s = this.composeBlock({
            id: e.id,
            tool: e.name,
            data: Object.assign({}, i, t1 ?? {}),
            tunes: o ?? e.tunes
        }), r = this.getBlockIndex(e);
        return this._blocks.replace(r, s), this.blockDidMutated(Ao, s, {
            index: r
        }), s;
    }
    /**
   * Replace passed Block with the new one with specified Tool and data
   *
   * @param block - block to replace
   * @param newTool - new Tool name
   * @param data - new Tool data
   */ replace(e, t1, o) {
        const i = this.getBlockIndex(e);
        return this.insert({
            tool: t1,
            data: o,
            index: i,
            replace: !0
        });
    }
    /**
   * Insert pasted content. Call onPaste callback after insert.
   *
   * @param {string} toolName - name of Tool to insert
   * @param {PasteEvent} pasteEvent - pasted data
   * @param {boolean} replace - should replace current block
   */ paste(e, t1, o = !1) {
        const i = this.insert({
            tool: e,
            replace: o
        });
        try {
            window.requestIdleCallback(()=>{
                i.call(ee.ON_PASTE, t1);
            });
        } catch (s) {
            S(`${e}: onPaste callback call is failed`, "error", s);
        }
        return i;
    }
    /**
   * Insert new default block at passed index
   *
   * @param {number} index - index where Block should be inserted
   * @param {boolean} needToFocus - if true, updates current Block index
   *
   * TODO: Remove method and use insert() with index instead (?)
   * @returns {Block} inserted Block
   */ insertDefaultBlockAtIndex(e, t1 = !1) {
        const o = this.composeBlock({
            tool: this.config.defaultBlock
        });
        return this._blocks[e] = o, this.blockDidMutated(Mo, o, {
            index: e
        }), t1 ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;
    }
    /**
   * Always inserts at the end
   *
   * @returns {Block}
   */ insertAtEnd() {
        return this.currentBlockIndex = this.blocks.length - 1, this.insert();
    }
    /**
   * Merge two blocks
   *
   * @param {Block} targetBlock - previous block will be append to this block
   * @param {Block} blockToMerge - block that will be merged with target block
   * @returns {Promise} - the sequence that can be continued
   */ async mergeBlocks(e, t1) {
        let o;
        if (e.name === t1.name && e.mergeable) {
            const i = await t1.data;
            if (V(i)) {
                console.error("Could not merge Block. Failed to extract original Block data.");
                return;
            }
            const [s] = yt([
                i
            ], e.tool.sanitizeConfig);
            o = s;
        } else if (e.mergeable && He(t1, "export") && He(e, "import")) {
            const i = await t1.exportDataAsString(), s = Z(i, e.tool.sanitizeConfig);
            o = Bo(s, e.tool.conversionConfig);
        }
        o !== void 0 && (await e.mergeWith(o), this.removeBlock(t1), this.currentBlockIndex = this._blocks.indexOf(e));
    }
    /**
   * Remove passed Block
   *
   * @param block - Block to remove
   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead
   */ removeBlock(e, t1 = !0) {
        return new Promise((o)=>{
            const i = this._blocks.indexOf(e);
            if (!this.validateIndex(i)) throw new Error("Can't find a Block to remove");
            e.destroy(), this._blocks.remove(i), this.blockDidMutated(_o, e, {
                index: i
            }), this.currentBlockIndex >= i && this.currentBlockIndex--, this.blocks.length ? i === 0 && (this.currentBlockIndex = 0) : (this.unsetCurrentBlock(), t1 && this.insert()), o();
        });
    }
    /**
   * Remove only selected Blocks
   * and returns first Block index where started removing...
   *
   * @returns {number|undefined}
   */ removeSelectedBlocks() {
        let e;
        for(let t1 = this.blocks.length - 1; t1 >= 0; t1--)this.blocks[t1].selected && (this.removeBlock(this.blocks[t1]), e = t1);
        return e;
    }
    /**
   * Attention!
   * After removing insert the new default typed Block and focus on it
   * Removes all blocks
   */ removeAllBlocks() {
        for(let e = this.blocks.length - 1; e >= 0; e--)this._blocks.remove(e);
        this.unsetCurrentBlock(), this.insert(), this.currentBlock.firstInput.focus();
    }
    /**
   * Split current Block
   * 1. Extract content from Caret position to the Block`s end
   * 2. Insert a new Block below current one with extracted content
   *
   * @returns {Block}
   */ split() {
        const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t1 = d.make("div");
        t1.appendChild(e);
        const o = {
            text: d.isEmpty(t1) ? "" : t1.innerHTML
        };
        return this.insert({
            data: o
        });
    }
    /**
   * Returns Block by passed index
   *
   * @param {number} index - index to get. -1 to get last
   * @returns {Block}
   */ getBlockByIndex(e) {
        return e === -1 && (e = this._blocks.length - 1), this._blocks[e];
    }
    /**
   * Returns an index for passed Block
   *
   * @param block - block to find index
   */ getBlockIndex(e) {
        return this._blocks.indexOf(e);
    }
    /**
   * Returns the Block by passed id
   *
   * @param id - id of block to get
   * @returns {Block}
   */ getBlockById(e) {
        return this._blocks.array.find((t1)=>t1.id === e);
    }
    /**
   * Get Block instance by html element
   *
   * @param {Node} element - html element to get Block by
   */ getBlock(e) {
        d.isElement(e) || (e = e.parentNode);
        const t1 = this._blocks.nodes, o = e.closest(`.${R.CSS.wrapper}`), i = t1.indexOf(o);
        if (i >= 0) return this._blocks[i];
    }
    /**
   * 1) Find first-level Block from passed child Node
   * 2) Mark it as current
   *
   * @param {Node} childNode - look ahead from this node.
   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance
   */ setCurrentBlockByChildNode(e) {
        d.isElement(e) || (e = e.parentNode);
        const t1 = e.closest(`.${R.CSS.wrapper}`);
        if (!t1) return;
        const o = t1.closest(`.${this.Editor.UI.CSS.editorWrapper}`);
        if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper)) return this.currentBlockIndex = this._blocks.nodes.indexOf(t1), this.currentBlock.updateCurrentInput(), this.currentBlock;
    }
    /**
   * Return block which contents passed node
   *
   * @param {Node} childNode - node to get Block by
   * @returns {Block}
   */ getBlockByChildNode(e) {
        if (!e || !(e instanceof Node)) return;
        d.isElement(e) || (e = e.parentNode);
        const t1 = e.closest(`.${R.CSS.wrapper}`);
        return this.blocks.find((o)=>o.holder === t1);
    }
    /**
   * Swap Blocks Position
   *
   * @param {number} fromIndex - index of first block
   * @param {number} toIndex - index of second block
   * @deprecated — use 'move' instead
   */ swap(e, t1) {
        this._blocks.swap(e, t1), this.currentBlockIndex = t1;
    }
    /**
   * Move a block to a new index
   *
   * @param {number} toIndex - index where to move Block
   * @param {number} fromIndex - index of Block to move
   */ move(e, t1 = this.currentBlockIndex) {
        if (isNaN(e) || isNaN(t1)) {
            S("Warning during 'move' call: incorrect indices provided.", "warn");
            return;
        }
        if (!this.validateIndex(e) || !this.validateIndex(t1)) {
            S("Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.", "warn");
            return;
        }
        this._blocks.move(e, t1), this.currentBlockIndex = e, this.blockDidMutated(ia, this.currentBlock, {
            fromIndex: t1,
            toIndex: e
        });
    }
    /**
   * Converts passed Block to the new Tool
   * Uses Conversion Config
   *
   * @param blockToConvert - Block that should be converted
   * @param targetToolName - name of the Tool to convert to
   * @param blockDataOverrides - optional new Block data overrides
   */ async convert(e, t1, o) {
        if (!await e.save()) throw new Error("Could not convert Block. Failed to extract original Block data.");
        const s = this.Editor.Tools.blockTools.get(t1);
        if (!s) throw new Error(`Could not convert Block. Tool «${t1}» not found.`);
        const r = await e.exportDataAsString(), a = Z(r, s.sanitizeConfig);
        let l = Bo(a, s.conversionConfig, s.settings);
        return o && (l = Object.assign(l, o)), this.replace(e, s.name, l);
    }
    /**
   * Sets current Block Index -1 which means unknown
   * and clear highlights
   */ unsetCurrentBlock() {
        this.currentBlockIndex = -1;
    }
    /**
   * Clears Editor
   *
   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)
   *                                             we don't need to add an empty default block
   *                                        2) in api.blocks.clear we should add empty block
   */ async clear(e = !1) {
        const t1 = new sa();
        this.blocks.forEach((o)=>{
            t1.add(async ()=>{
                await this.removeBlock(o, !1);
            });
        }), await t1.completed, this.unsetCurrentBlock(), e && this.insert(), this.Editor.UI.checkEmptiness();
    }
    /**
   * Cleans up all the block tools' resources
   * This is called when editor is destroyed
   */ async destroy() {
        await Promise.all(this.blocks.map((e)=>e.destroy()));
    }
    /**
   * Bind Block events
   *
   * @param {Block} block - Block to which event should be bound
   */ bindBlockEvents(e) {
        const { BlockEvents: t1 } = this.Editor;
        this.readOnlyMutableListeners.on(e.holder, "keydown", (o)=>{
            t1.keydown(o);
        }), this.readOnlyMutableListeners.on(e.holder, "keyup", (o)=>{
            t1.keyup(o);
        }), this.readOnlyMutableListeners.on(e.holder, "dragover", (o)=>{
            t1.dragOver(o);
        }), this.readOnlyMutableListeners.on(e.holder, "dragleave", (o)=>{
            t1.dragLeave(o);
        }), e.on("didMutated", (o)=>this.blockDidMutated(Ao, o, {
                index: this.getBlockIndex(o)
            }));
    }
    /**
   * Disable mutable handlers and bindings
   */ disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
    }
    /**
   * Enables all module handlers and bindings for all Blocks
   */ enableModuleBindings() {
        this.readOnlyMutableListeners.on(document, "cut", (e)=>this.Editor.BlockEvents.handleCommandX(e)), this.blocks.forEach((e)=>{
            this.bindBlockEvents(e);
        });
    }
    /**
   * Validates that the given index is not lower than 0 or higher than the amount of blocks
   *
   * @param {number} index - index of blocks array to validate
   * @returns {boolean}
   */ validateIndex(e) {
        return !(e < 0 || e >= this._blocks.length);
    }
    /**
   * Block mutation callback
   *
   * @param mutationType - what happened with block
   * @param block - mutated block
   * @param detailData - additional data to pass with change event
   */ blockDidMutated(e, t1, o) {
        const i = new CustomEvent(e, {
            detail: {
                target: new J(t1),
                ...o
            }
        });
        return this.eventsDispatcher.emit($o, {
            event: i
        }), t1;
    }
}
class aa extends E {
    constructor(){
        super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;
    }
    /**
   * Sanitizer Config
   *
   * @returns {SanitizerConfig}
   */ get sanitizerConfig() {
        return {
            p: {},
            h1: {},
            h2: {},
            h3: {},
            h4: {},
            h5: {},
            h6: {},
            ol: {},
            ul: {},
            li: {},
            br: !0,
            img: {
                src: !0,
                width: !0,
                height: !0
            },
            a: {
                href: !0
            },
            b: {},
            i: {},
            u: {}
        };
    }
    /**
   * Flag that identifies all Blocks selection
   *
   * @returns {boolean}
   */ get allBlocksSelected() {
        const { BlockManager: e } = this.Editor;
        return e.blocks.every((t1)=>t1.selected === !0);
    }
    /**
   * Set selected all blocks
   *
   * @param {boolean} state - state to set
   */ set allBlocksSelected(e) {
        const { BlockManager: t1 } = this.Editor;
        t1.blocks.forEach((o)=>{
            o.selected = e;
        }), this.clearCache();
    }
    /**
   * Flag that identifies any Block selection
   *
   * @returns {boolean}
   */ get anyBlockSelected() {
        const { BlockManager: e } = this.Editor;
        return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t1)=>t1.selected === !0)), this.anyBlockSelectedCache;
    }
    /**
   * Return selected Blocks array
   *
   * @returns {Block[]}
   */ get selectedBlocks() {
        return this.Editor.BlockManager.blocks.filter((e)=>e.selected);
    }
    /**
   * Module Preparation
   * Registers Shortcuts CMD+A and CMD+C
   * to select all and copy them
   */ prepare() {
        this.selection = new b(), ge.add({
            name: "CMD+A",
            handler: (e)=>{
                const { BlockManager: t1, ReadOnly: o } = this.Editor;
                if (o.isEnabled) {
                    e.preventDefault(), this.selectAllBlocks();
                    return;
                }
                t1.currentBlock && this.handleCommandA(e);
            },
            on: this.Editor.UI.nodes.redactor
        });
    }
    /**
   * Toggle read-only state
   *
   *  - Remove all ranges
   *  - Unselect all Blocks
   */ toggleReadOnly() {
        b.get().removeAllRanges(), this.allBlocksSelected = !1;
    }
    /**
   * Remove selection of Block
   *
   * @param {number?} index - Block index according to the BlockManager's indexes
   */ unSelectBlockByIndex(e) {
        const { BlockManager: t1 } = this.Editor;
        let o;
        isNaN(e) ? o = t1.currentBlock : o = t1.getBlockByIndex(e), o.selected = !1, this.clearCache();
    }
    /**
   * Clear selection from Blocks
   *
   * @param {Event} reason - event caused clear of selection
   * @param {boolean} restoreSelection - if true, restore saved selection
   */ clearSelection(e, t1 = !1) {
        const { BlockManager: o, Caret: i, RectangleSelection: s } = this.Editor;
        this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;
        const r = e && e instanceof KeyboardEvent, a = r && Po(e.keyCode);
        if (this.anyBlockSelected && r && a && !b.isSelectionExists) {
            const l = o.removeSelectedBlocks();
            o.insertDefaultBlockAtIndex(l, !0), i.setToBlock(o.currentBlock), Fe(()=>{
                const c = e.key;
                i.insertContentAtCaretPosition(c.length > 1 ? "" : c);
            }, 20)();
        }
        if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || s.isRectActivated()) {
            this.Editor.RectangleSelection.clearSelection();
            return;
        }
        t1 && this.selection.restore(), this.allBlocksSelected = !1;
    }
    /**
   * Reduce each Block and copy its content
   *
   * @param {ClipboardEvent} e - copy/cut event
   * @returns {Promise<void>}
   */ copySelectedBlocks(e) {
        e.preventDefault();
        const t1 = d.make("div");
        this.selectedBlocks.forEach((s)=>{
            const r = Z(s.holder.innerHTML, this.sanitizerConfig), a = d.make("p");
            a.innerHTML = r, t1.appendChild(a);
        });
        const o = Array.from(t1.childNodes).map((s)=>s.textContent).join(`

`), i = t1.innerHTML;
        return e.clipboardData.setData("text/plain", o), e.clipboardData.setData("text/html", i), Promise.all(this.selectedBlocks.map((s)=>s.save())).then((s)=>{
            try {
                e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(s));
            } catch  {}
        });
    }
    /**
   * Select Block by its index
   *
   * @param {number?} index - Block index according to the BlockManager's indexes
   */ selectBlockByIndex(e) {
        const { BlockManager: t1 } = this.Editor, o = t1.getBlockByIndex(e);
        o !== void 0 && this.selectBlock(o);
    }
    /**
   * Select passed Block
   *
   * @param {Block} block - Block to select
   */ selectBlock(e) {
        this.selection.save(), b.get().removeAllRanges(), e.selected = !0, this.clearCache(), this.Editor.InlineToolbar.close();
    }
    /**
   * Remove selection from passed Block
   *
   * @param {Block} block - Block to unselect
   */ unselectBlock(e) {
        e.selected = !1, this.clearCache();
    }
    /**
   * Clear anyBlockSelected cache
   */ clearCache() {
        this.anyBlockSelectedCache = null;
    }
    /**
   * Module destruction
   * De-registers Shortcut CMD+A
   */ destroy() {
        ge.remove(this.Editor.UI.nodes.redactor, "CMD+A");
    }
    /**
   * First CMD+A selects all input content by native behaviour,
   * next CMD+A keypress selects all blocks
   *
   * @param {KeyboardEvent} event - keyboard event
   */ handleCommandA(e) {
        if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e.target) && !this.readyToBlockSelection) {
            this.readyToBlockSelection = !0;
            return;
        }
        const t1 = this.Editor.BlockManager.getBlock(e.target), o = t1.inputs;
        if (o.length > 1 && !this.readyToBlockSelection) {
            this.readyToBlockSelection = !0;
            return;
        }
        if (o.length === 1 && !this.needToSelectAll) {
            this.needToSelectAll = !0;
            return;
        }
        this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = !1, this.readyToBlockSelection = !1) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlock(t1), this.needToSelectAll = !0);
    }
    /**
   * Select All Blocks
   * Each Block has selected setter that makes Block copyable
   */ selectAllBlocks() {
        this.selection.save(), b.get().removeAllRanges(), this.allBlocksSelected = !0, this.Editor.InlineToolbar.close();
    }
}
class Ye extends E {
    /**
   * Allowed caret positions in input
   *
   * @static
   * @returns {{START: string, END: string, DEFAULT: string}}
   */ get positions() {
        return {
            START: "start",
            END: "end",
            DEFAULT: "default"
        };
    }
    /**
   * Elements styles that can be useful for Caret Module
   */ static get CSS() {
        return {
            shadowCaret: "cdx-shadow-caret"
        };
    }
    /**
   * Method gets Block instance and puts caret to the text node with offset
   * There two ways that method applies caret position:
   *   - first found text node: sets at the beginning, but you can pass an offset
   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour
   *
   * @param {Block} block - Block class
   * @param {string} position - position where to set caret.
   *                            If default - leave default behaviour and apply offset if it's passed
   * @param {number} offset - caret offset regarding to the text node
   */ setToBlock(e, t1 = this.positions.DEFAULT, o = 0) {
        var c;
        const { BlockManager: i, BlockSelection: s } = this.Editor;
        if (s.clearSelection(), !e.focusable) {
            (c = window.getSelection()) == null || c.removeAllRanges(), s.selectBlock(e), i.currentBlock = e;
            return;
        }
        let r;
        switch(t1){
            case this.positions.START:
                r = e.firstInput;
                break;
            case this.positions.END:
                r = e.lastInput;
                break;
            default:
                r = e.currentInput;
        }
        if (!r) return;
        const a = d.getDeepestNode(r, t1 === this.positions.END), l = d.getContentLength(a);
        switch(!0){
            case t1 === this.positions.START:
                o = 0;
                break;
            case t1 === this.positions.END:
            case o > l:
                o = l;
                break;
        }
        this.set(a, o), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = r;
    }
    /**
   * Set caret to the current input of current Block.
   *
   * @param {HTMLElement} input - input where caret should be set
   * @param {string} position - position of the caret.
   *                            If default - leave default behaviour and apply offset if it's passed
   * @param {number} offset - caret offset regarding to the text node
   */ setToInput(e, t1 = this.positions.DEFAULT, o = 0) {
        const { currentBlock: i } = this.Editor.BlockManager, s = d.getDeepestNode(e);
        switch(t1){
            case this.positions.START:
                this.set(s, 0);
                break;
            case this.positions.END:
                this.set(s, d.getContentLength(s));
                break;
            default:
                o && this.set(s, o);
        }
        i.currentInput = e;
    }
    /**
   * Creates Document Range and sets caret to the element with offset
   *
   * @param {HTMLElement} element - target node.
   * @param {number} offset - offset
   */ set(e, t1 = 0) {
        const { top: i, bottom: s } = b.setCursor(e, t1), { innerHeight: r } = window;
        i < 0 ? window.scrollBy(0, i - 30) : s > r && window.scrollBy(0, s - r + 30);
    }
    /**
   * Set Caret to the last Block
   * If last block is not empty, append another empty block
   */ setToTheLastBlock() {
        const e = this.Editor.BlockManager.lastBlock;
        if (e) if (e.tool.isDefault && e.isEmpty) this.setToBlock(e);
        else {
            const t1 = this.Editor.BlockManager.insertAtEnd();
            this.setToBlock(t1);
        }
    }
    /**
   * Extract content fragment of current Block from Caret position to the end of the Block
   */ extractFragmentFromCaretPosition() {
        const e = b.get();
        if (e.rangeCount) {
            const t1 = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;
            if (t1.deleteContents(), o) if (d.isNativeInput(o)) {
                const i = o, s = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), a = i.value.substring(i.selectionStart);
                return s.textContent = a, i.value = r, s;
            } else {
                const i = t1.cloneRange();
                return i.selectNodeContents(o), i.setStart(t1.endContainer, t1.endOffset), i.extractContents();
            }
        }
    }
    /**
   * Set's caret to the next Block or Tool`s input
   * Before moving caret, we should check if caret position is at the end of Plugins node
   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
   *
   * @param {boolean} force - pass true to skip check for caret position
   */ navigateNext(e = !1) {
        const { BlockManager: t1 } = this.Editor, { currentBlock: o, nextBlock: i } = t1;
        if (o === void 0) return !1;
        const { nextInput: s, currentInput: r } = o, a = r !== void 0 ? Re(r) : void 0;
        let l = i;
        const c = e || a || !o.focusable;
        if (s && c) return this.setToInput(s, this.positions.START), !0;
        if (l === null) {
            if (o.tool.isDefault || !c) return !1;
            l = t1.insertAtEnd();
        }
        return c ? (this.setToBlock(l, this.positions.START), !0) : !1;
    }
    /**
   * Set's caret to the previous Tool`s input or Block
   * Before moving caret, we should check if caret position is start of the Plugins node
   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
   *
   * @param {boolean} force - pass true to skip check for caret position
   */ navigatePrevious(e = !1) {
        const { currentBlock: t1, previousBlock: o } = this.Editor.BlockManager;
        if (!t1) return !1;
        const { previousInput: i, currentInput: s } = t1, r = s !== void 0 ? Ne(s) : void 0, a = e || r || !t1.focusable;
        return i && a ? (this.setToInput(i, this.positions.END), !0) : o !== null && a ? (this.setToBlock(o, this.positions.END), !0) : !1;
    }
    /**
   * Inserts shadow element after passed element where caret can be placed
   *
   * @param {Element} element - element after which shadow caret should be inserted
   */ createShadow(e) {
        const t1 = document.createElement("span");
        t1.classList.add(Ye.CSS.shadowCaret), e.insertAdjacentElement("beforeend", t1);
    }
    /**
   * Restores caret position
   *
   * @param {HTMLElement} element - element where caret should be restored
   */ restoreCaret(e) {
        const t1 = e.querySelector(`.${Ye.CSS.shadowCaret}`);
        if (!t1) return;
        new b().expandToTag(t1);
        const i = document.createRange();
        i.selectNode(t1), i.extractContents();
    }
    /**
   * Inserts passed content at caret position
   *
   * @param {string} content - content to insert
   */ insertContentAtCaretPosition(e) {
        const t1 = document.createDocumentFragment(), o = document.createElement("div"), i = b.get(), s = b.range;
        o.innerHTML = e, Array.from(o.childNodes).forEach((c)=>t1.appendChild(c)), t1.childNodes.length === 0 && t1.appendChild(new Text());
        const r = t1.lastChild;
        s.deleteContents(), s.insertNode(t1);
        const a = document.createRange(), l = r.nodeType === Node.TEXT_NODE ? r : r.firstChild;
        l !== null && l.textContent !== null && a.setStart(l, l.textContent.length), i.removeAllRanges(), i.addRange(a);
    }
}
class la extends E {
    constructor(){
        super(...arguments), this.onMouseUp = ()=>{
            this.listeners.off(document, "mouseover", this.onMouseOver), this.listeners.off(document, "mouseup", this.onMouseUp);
        }, this.onMouseOver = (e)=>{
            const { BlockManager: t1, BlockSelection: o } = this.Editor;
            if (e.relatedTarget === null && e.target === null) return;
            const i = t1.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, s = t1.getBlockByChildNode(e.target);
            if (!(!i || !s) && s !== i) {
                if (i === this.firstSelectedBlock) {
                    b.get().removeAllRanges(), i.selected = !0, s.selected = !0, o.clearCache();
                    return;
                }
                if (s === this.firstSelectedBlock) {
                    i.selected = !1, s.selected = !1, o.clearCache();
                    return;
                }
                this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, s), this.lastSelectedBlock = s;
            }
        };
    }
    /**
   * Module preparation
   *
   * @returns {Promise}
   */ async prepare() {
        this.listeners.on(document, "mousedown", (e)=>{
            this.enableCrossBlockSelection(e);
        });
    }
    /**
   * Sets up listeners
   *
   * @param {MouseEvent} event - mouse down event
   */ watchSelection(e) {
        if (e.button !== qn.LEFT) return;
        const { BlockManager: t1 } = this.Editor;
        this.firstSelectedBlock = t1.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, "mouseover", this.onMouseOver), this.listeners.on(document, "mouseup", this.onMouseUp);
    }
    /**
   * Return boolean is cross block selection started:
   * there should be at least 2 selected blocks
   */ get isCrossBlockSelectionStarted() {
        return !!this.firstSelectedBlock && !!this.lastSelectedBlock && this.firstSelectedBlock !== this.lastSelectedBlock;
    }
    /**
   * Change selection state of the next Block
   * Used for CBS via Shift + arrow keys
   *
   * @param {boolean} next - if true, toggle next block. Previous otherwise
   */ toggleBlockSelectedState(e = !0) {
        const { BlockManager: t1, BlockSelection: o } = this.Editor;
        this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t1.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = !0, o.clearCache(), b.get().removeAllRanges());
        const i = t1.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), s = t1.blocks[i];
        s && (this.lastSelectedBlock.selected !== s.selected ? (s.selected = !0, o.clearCache()) : (this.lastSelectedBlock.selected = !1, o.clearCache()), this.lastSelectedBlock = s, this.Editor.InlineToolbar.close(), s.holder.scrollIntoView({
            block: "nearest"
        }));
    }
    /**
   * Clear saved state
   *
   * @param {Event} reason - event caused clear of selection
   */ clear(e) {
        const { BlockManager: t1, BlockSelection: o, Caret: i } = this.Editor, s = t1.blocks.indexOf(this.firstSelectedBlock), r = t1.blocks.indexOf(this.lastSelectedBlock);
        if (o.anyBlockSelected && s > -1 && r > -1 && e && e instanceof KeyboardEvent) switch(e.keyCode){
            case y.DOWN:
            case y.RIGHT:
                i.setToBlock(t1.blocks[Math.max(s, r)], i.positions.END);
                break;
            case y.UP:
            case y.LEFT:
                i.setToBlock(t1.blocks[Math.min(s, r)], i.positions.START);
                break;
            default:
                i.setToBlock(t1.blocks[Math.max(s, r)], i.positions.END);
        }
        this.firstSelectedBlock = this.lastSelectedBlock = null;
    }
    /**
   * Enables Cross Block Selection
   *
   * @param {MouseEvent} event - mouse down event
   */ enableCrossBlockSelection(e) {
        const { UI: t1 } = this.Editor;
        b.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t1.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);
    }
    /**
   * Change blocks selection state between passed two blocks.
   *
   * @param {Block} firstBlock - first block in range
   * @param {Block} lastBlock - last block in range
   */ toggleBlocksSelectedState(e, t1) {
        const { BlockManager: o, BlockSelection: i } = this.Editor, s = o.blocks.indexOf(e), r = o.blocks.indexOf(t1), a = e.selected !== t1.selected;
        for(let l = Math.min(s, r); l <= Math.max(s, r); l++){
            const c = o.blocks[l];
            c !== this.firstSelectedBlock && c !== (a ? e : t1) && (o.blocks[l].selected = !o.blocks[l].selected, i.clearCache());
        }
    }
}
class ca extends E {
    constructor(){
        super(...arguments), this.isStartedAtEditor = !1;
    }
    /**
   * Toggle read-only state
   *
   * if state is true:
   *  - disable all drag-n-drop event handlers
   *
   * if state is false:
   *  - restore drag-n-drop event handlers
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */ toggleReadOnly(e) {
        e ? this.disableModuleBindings() : this.enableModuleBindings();
    }
    /**
   * Add drag events listeners to editor zone
   */ enableModuleBindings() {
        const { UI: e } = this.Editor;
        this.readOnlyMutableListeners.on(e.nodes.holder, "drop", async (t1)=>{
            await this.processDrop(t1);
        }, !0), this.readOnlyMutableListeners.on(e.nodes.holder, "dragstart", ()=>{
            this.processDragStart();
        }), this.readOnlyMutableListeners.on(e.nodes.holder, "dragover", (t1)=>{
            this.processDragOver(t1);
        }, !0);
    }
    /**
   * Unbind drag-n-drop event handlers
   */ disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
    }
    /**
   * Handle drop event
   *
   * @param {DragEvent} dropEvent - drop event
   */ async processDrop(e) {
        const { BlockManager: t1, Paste: o, Caret: i } = this.Editor;
        e.preventDefault(), t1.blocks.forEach((r)=>{
            r.dropTarget = !1;
        }), b.isAtEditor && !b.isCollapsed && this.isStartedAtEditor && document.execCommand("delete"), this.isStartedAtEditor = !1;
        const s = t1.setCurrentBlockByChildNode(e.target);
        if (s) this.Editor.Caret.setToBlock(s, i.positions.END);
        else {
            const r = t1.setCurrentBlockByChildNode(t1.lastBlock.holder);
            this.Editor.Caret.setToBlock(r, i.positions.END);
        }
        await o.processDataTransfer(e.dataTransfer, !0);
    }
    /**
   * Handle drag start event
   */ processDragStart() {
        b.isAtEditor && !b.isCollapsed && (this.isStartedAtEditor = !0), this.Editor.InlineToolbar.close();
    }
    /**
   * @param {DragEvent} dragEvent - drag event
   */ processDragOver(e) {
        e.preventDefault();
    }
}
const da = 180, ua = 400;
class ha extends E {
    /**
   * Prepare the module
   *
   * @param options - options used by the modification observer module
   * @param options.config - Editor configuration object
   * @param options.eventsDispatcher - common Editor event bus
   */ constructor({ config: e, eventsDispatcher: t1 }){
        super({
            config: e,
            eventsDispatcher: t1
        }), this.disabled = !1, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = ua, this.mutationObserver = new MutationObserver((o)=>{
            this.redactorChanged(o);
        }), this.eventsDispatcher.on($o, (o)=>{
            this.particularBlockChanged(o.event);
        }), this.eventsDispatcher.on(zo, ()=>{
            this.disable();
        }), this.eventsDispatcher.on(Uo, ()=>{
            this.enable();
        });
    }
    /**
   * Enables onChange event
   */ enable() {
        this.mutationObserver.observe(this.Editor.UI.nodes.redactor, {
            childList: !0,
            subtree: !0,
            characterData: !0,
            attributes: !0
        }), this.disabled = !1;
    }
    /**
   * Disables onChange event
   */ disable() {
        this.mutationObserver.disconnect(), this.disabled = !0;
    }
    /**
   * Call onChange event passed to Editor.js configuration
   *
   * @param event - some of our custom change events
   */ particularBlockChanged(e) {
        this.disabled || !A(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(()=>{
            let t1;
            this.batchingOnChangeQueue.size === 1 ? t1 = this.batchingOnChangeQueue.values().next().value : t1 = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t1), this.batchingOnChangeQueue.clear();
        }, this.batchTime));
    }
    /**
   * Fired on every blocks wrapper dom change
   *
   * @param mutations - mutations happened
   */ redactorChanged(e) {
        this.eventsDispatcher.emit(ft, {
            mutations: e
        });
    }
}
const Rn = class Dn extends E {
    constructor(){
        super(...arguments), this.MIME_TYPE = "application/x-editor-js", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (e)=>{
            try {
                const t1 = e.create({}, {}, !1);
                if (e.pasteConfig === !1) {
                    this.exceptionList.push(e.name);
                    return;
                }
                if (!A(t1.onPaste)) return;
                this.getTagsConfig(e), this.getFilesConfig(e), this.getPatternsConfig(e);
            } catch (t1) {
                S(`Paste handling for «${e.name}» Tool hasn't been set up because of the error`, "warn", t1);
            }
        }, this.handlePasteEvent = async (e)=>{
            const { BlockManager: t1, Toolbar: o } = this.Editor, i = t1.setCurrentBlockByChildNode(e.target);
            !i || this.isNativeBehaviour(e.target) && !e.clipboardData.types.includes("Files") || i && this.exceptionList.includes(i.name) || (e.preventDefault(), this.processDataTransfer(e.clipboardData), o.close());
        };
    }
    /**
   * Set onPaste callback and collect tools` paste configurations
   */ async prepare() {
        this.processTools();
    }
    /**
   * Set read-only state
   *
   * @param {boolean} readOnlyEnabled - read only flag value
   */ toggleReadOnly(e) {
        e ? this.unsetCallback() : this.setCallback();
    }
    /**
   * Handle pasted or dropped data transfer object
   *
   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object
   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events
   */ async processDataTransfer(e, t1 = !1) {
        const { Tools: o } = this.Editor, i = e.types;
        if ((i.includes ? i.includes("Files") : i.contains("Files")) && !V(this.toolsFiles)) {
            await this.processFiles(e.files);
            return;
        }
        const r = e.getData(this.MIME_TYPE), a = e.getData("text/plain");
        let l = e.getData("text/html");
        if (r) try {
            this.insertEditorJSData(JSON.parse(r));
            return;
        } catch  {}
        t1 && a.trim() && l.trim() && (l = "<p>" + (l.trim() ? l : a) + "</p>");
        const c = Object.keys(this.toolsTags).reduce((p, g)=>(p[g.toLowerCase()] = this.toolsTags[g].sanitizationConfig ?? {}, p), {}), u = Object.assign({}, c, o.getAllInlineToolsSanitizeConfig(), {
            br: {}
        }), h = Z(l, u);
        !h.trim() || h.trim() === a || !d.isHTMLString(h) ? await this.processText(a) : await this.processText(h, !0);
    }
    /**
   * Process pasted text and divide them into Blocks
   *
   * @param {string} data - text to process. Can be HTML or plain.
   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true
   */ async processText(e, t1 = !1) {
        const { Caret: o, BlockManager: i } = this.Editor, s = t1 ? this.processHTML(e) : this.processPlain(e);
        if (!s.length) return;
        if (s.length === 1) {
            s[0].isBlock ? this.processSingleBlock(s.pop()) : this.processInlinePaste(s.pop());
            return;
        }
        const a = i.currentBlock && i.currentBlock.tool.isDefault && i.currentBlock.isEmpty;
        s.map(async (l, c)=>this.insertBlock(l, c === 0 && a)), i.currentBlock && o.setToBlock(i.currentBlock, o.positions.END);
    }
    /**
   * Set onPaste callback handler
   */ setCallback() {
        this.listeners.on(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
    }
    /**
   * Unset onPaste callback handler
   */ unsetCallback() {
        this.listeners.off(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
    }
    /**
   * Get and process tool`s paste configs
   */ processTools() {
        const e = this.Editor.Tools.blockTools;
        Array.from(e.values()).forEach(this.processTool);
    }
    /**
   * Get tags name list from either tag name or sanitization config.
   *
   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.
   * @returns {string[]} array of tags.
   */ collectTagNames(e) {
        return te(e) ? [
            e
        ] : D(e) ? Object.keys(e) : [];
    }
    /**
   * Get tags to substitute by Tool
   *
   * @param tool - BlockTool object
   */ getTagsConfig(e) {
        if (e.pasteConfig === !1) return;
        const t1 = e.pasteConfig.tags || [], o = [];
        t1.forEach((i)=>{
            const s = this.collectTagNames(i);
            o.push(...s), s.forEach((r)=>{
                if (Object.prototype.hasOwnProperty.call(this.toolsTags, r)) {
                    S(`Paste handler for «${e.name}» Tool on «${r}» tag is skipped because it is already used by «${this.toolsTags[r].tool.name}» Tool.`, "warn");
                    return;
                }
                const a = D(i) ? i[r] : null;
                this.toolsTags[r.toUpperCase()] = {
                    tool: e,
                    sanitizationConfig: a
                };
            });
        }), this.tagsByTool[e.name] = o.map((i)=>i.toUpperCase());
    }
    /**
   * Get files` types and extensions to substitute by Tool
   *
   * @param tool - BlockTool object
   */ getFilesConfig(e) {
        if (e.pasteConfig === !1) return;
        const { files: t1 = {} } = e.pasteConfig;
        let { extensions: o, mimeTypes: i } = t1;
        !o && !i || (o && !Array.isArray(o) && (S(`«extensions» property of the onDrop config for «${e.name}» Tool should be an array`), o = []), i && !Array.isArray(i) && (S(`«mimeTypes» property of the onDrop config for «${e.name}» Tool should be an array`), i = []), i && (i = i.filter((s)=>ei(s) ? !0 : (S(`MIME type value «${s}» for the «${e.name}» Tool is not a valid MIME type`, "warn"), !1))), this.toolsFiles[e.name] = {
            extensions: o || [],
            mimeTypes: i || []
        });
    }
    /**
   * Get RegExp patterns to substitute by Tool
   *
   * @param tool - BlockTool object
   */ getPatternsConfig(e) {
        e.pasteConfig === !1 || !e.pasteConfig.patterns || V(e.pasteConfig.patterns) || Object.entries(e.pasteConfig.patterns).forEach(([t1, o])=>{
            o instanceof RegExp || S(`Pattern ${o} for «${e.name}» Tool is skipped because it should be a Regexp instance.`, "warn"), this.toolsPatterns.push({
                key: t1,
                pattern: o,
                tool: e
            });
        });
    }
    /**
   * Check if browser behavior suits better
   *
   * @param {EventTarget} element - element where content has been pasted
   * @returns {boolean}
   */ isNativeBehaviour(e) {
        return d.isNativeInput(e);
    }
    /**
   * Get files from data transfer object and insert related Tools
   *
   * @param {FileList} items - pasted or dropped items
   */ async processFiles(e) {
        const { BlockManager: t1 } = this.Editor;
        let o;
        o = await Promise.all(Array.from(e).map((r)=>this.processFile(r))), o = o.filter((r)=>!!r);
        const s = t1.currentBlock.tool.isDefault && t1.currentBlock.isEmpty;
        o.forEach((r, a)=>{
            t1.paste(r.type, r.event, a === 0 && s);
        });
    }
    /**
   * Get information about file and find Tool to handle it
   *
   * @param {File} file - file to process
   */ async processFile(e) {
        const t1 = Jn(e), o = Object.entries(this.toolsFiles).find(([r, { mimeTypes: a, extensions: l }])=>{
            const [c, u] = e.type.split("/"), h = l.find((g)=>g.toLowerCase() === t1.toLowerCase()), p = a.find((g)=>{
                const [f, v] = g.split("/");
                return f === c && (v === u || v === "*");
            });
            return !!h || !!p;
        });
        if (!o) return;
        const [i] = o;
        return {
            event: this.composePasteEvent("file", {
                file: e
            }),
            type: i
        };
    }
    /**
   * Split HTML string to blocks and return it as array of Block data
   *
   * @param {string} innerHTML - html string to process
   * @returns {PasteData[]}
   */ processHTML(e) {
        const { Tools: t1 } = this.Editor, o = d.make("DIV");
        return o.innerHTML = e, this.getNodes(o).map((s)=>{
            let r, a = t1.defaultTool, l = !1;
            switch(s.nodeType){
                case Node.DOCUMENT_FRAGMENT_NODE:
                    r = d.make("div"), r.appendChild(s);
                    break;
                case Node.ELEMENT_NODE:
                    r = s, l = !0, this.toolsTags[r.tagName] && (a = this.toolsTags[r.tagName].tool);
                    break;
            }
            const { tags: c } = a.pasteConfig || {
                tags: []
            }, u = c.reduce((g, f)=>(this.collectTagNames(f).forEach((O)=>{
                    const T = D(f) ? f[O] : null;
                    g[O.toLowerCase()] = T || {};
                }), g), {}), h = Object.assign({}, u, a.baseSanitizeConfig);
            if (r.tagName.toLowerCase() === "table") {
                const g = Z(r.outerHTML, h);
                r = d.make("div", void 0, {
                    innerHTML: g
                }).firstChild;
            } else r.innerHTML = Z(r.innerHTML, h);
            const p = this.composePasteEvent("tag", {
                data: r
            });
            return {
                content: r,
                isBlock: l,
                tool: a.name,
                event: p
            };
        }).filter((s)=>{
            const r = d.isEmpty(s.content), a = d.isSingleTag(s.content);
            return !r || a;
        });
    }
    /**
   * Split plain text by new line symbols and return it as array of Block data
   *
   * @param {string} plain - string to process
   * @returns {PasteData[]}
   */ processPlain(e) {
        const { defaultBlock: t1 } = this.config;
        if (!e) return [];
        const o = t1;
        return e.split(/\r?\n/).filter((i)=>i.trim()).map((i)=>{
            const s = d.make("div");
            s.textContent = i;
            const r = this.composePasteEvent("tag", {
                data: s
            });
            return {
                content: s,
                tool: o,
                isBlock: !1,
                event: r
            };
        });
    }
    /**
   * Process paste of single Block tool content
   *
   * @param {PasteData} dataToInsert - data of Block to insert
   */ async processSingleBlock(e) {
        const { Caret: t1, BlockManager: o } = this.Editor, { currentBlock: i } = o;
        if (!i || e.tool !== i.name || !d.containsOnlyInlineElements(e.content.innerHTML)) {
            this.insertBlock(e, (i == null ? void 0 : i.tool.isDefault) && i.isEmpty);
            return;
        }
        t1.insertContentAtCaretPosition(e.content.innerHTML);
    }
    /**
   * Process paste to single Block:
   * 1. Find patterns` matches
   * 2. Insert new block if it is not the same type as current one
   * 3. Just insert text if there is no substitutions
   *
   * @param {PasteData} dataToInsert - data of Block to insert
   */ async processInlinePaste(e) {
        const { BlockManager: t1, Caret: o } = this.Editor, { content: i } = e;
        if (t1.currentBlock && t1.currentBlock.tool.isDefault && i.textContent.length < Dn.PATTERN_PROCESSING_MAX_LENGTH) {
            const r = await this.processPattern(i.textContent);
            if (r) {
                const a = t1.currentBlock && t1.currentBlock.tool.isDefault && t1.currentBlock.isEmpty, l = t1.paste(r.tool, r.event, a);
                o.setToBlock(l, o.positions.END);
                return;
            }
        }
        if (t1.currentBlock && t1.currentBlock.currentInput) {
            const r = t1.currentBlock.tool.baseSanitizeConfig;
            document.execCommand("insertHTML", !1, Z(i.innerHTML, r));
        } else this.insertBlock(e);
    }
    /**
   * Get patterns` matches
   *
   * @param {string} text - text to process
   * @returns {Promise<{event: PasteEvent, tool: string}>}
   */ async processPattern(e) {
        const t1 = this.toolsPatterns.find((i)=>{
            const s = i.pattern.exec(e);
            return s ? e === s.shift() : !1;
        });
        return t1 ? {
            event: this.composePasteEvent("pattern", {
                key: t1.key,
                data: e
            }),
            tool: t1.tool.name
        } : void 0;
    }
    /**
   * Insert pasted Block content to Editor
   *
   * @param {PasteData} data - data to insert
   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block
   * @returns {void}
   */ insertBlock(e, t1 = !1) {
        const { BlockManager: o, Caret: i } = this.Editor, { currentBlock: s } = o;
        let r;
        if (t1 && s && s.isEmpty) {
            r = o.paste(e.tool, e.event, !0), i.setToBlock(r, i.positions.END);
            return;
        }
        r = o.paste(e.tool, e.event), i.setToBlock(r, i.positions.END);
    }
    /**
   * Insert data passed as application/x-editor-js JSON
   *
   * @param {Array} blocks — Blocks' data to insert
   * @returns {void}
   */ insertEditorJSData(e) {
        const { BlockManager: t1, Caret: o, Tools: i } = this.Editor;
        yt(e, (r)=>i.blockTools.get(r).sanitizeConfig).forEach(({ tool: r, data: a }, l)=>{
            let c = !1;
            l === 0 && (c = t1.currentBlock && t1.currentBlock.tool.isDefault && t1.currentBlock.isEmpty);
            const u = t1.insert({
                tool: r,
                data: a,
                replace: c
            });
            o.setToBlock(u, o.positions.END);
        });
    }
    /**
   * Fetch nodes from Element node
   *
   * @param {Node} node - current node
   * @param {Node[]} nodes - processed nodes
   * @param {Node} destNode - destination node
   */ processElementNode(e, t1, o) {
        const i = Object.keys(this.toolsTags), s = e, { tool: r } = this.toolsTags[s.tagName] || {}, a = this.tagsByTool[r == null ? void 0 : r.name] || [], l = i.includes(s.tagName), c = d.blockElements.includes(s.tagName.toLowerCase()), u = Array.from(s.children).some(({ tagName: p })=>i.includes(p) && !a.includes(p)), h = Array.from(s.children).some(({ tagName: p })=>d.blockElements.includes(p.toLowerCase()));
        if (!c && !l && !u) return o.appendChild(s), [
            ...t1,
            o
        ];
        if (l && !u || c && !h && !u) return [
            ...t1,
            o,
            s
        ];
    }
    /**
   * Recursively divide HTML string to two types of nodes:
   * 1. Block element
   * 2. Document Fragments contained text and markup tags like a, b, i etc.
   *
   * @param {Node} wrapper - wrapper of paster HTML content
   * @returns {Node[]}
   */ getNodes(e) {
        const t1 = Array.from(e.childNodes);
        let o;
        const i = (s, r)=>{
            if (d.isEmpty(r) && !d.isSingleTag(r)) return s;
            const a = s[s.length - 1];
            let l = new DocumentFragment();
            switch(a && d.isFragment(a) && (l = s.pop()), r.nodeType){
                case Node.ELEMENT_NODE:
                    if (o = this.processElementNode(r, s, l), o) return o;
                    break;
                case Node.TEXT_NODE:
                    return l.appendChild(r), [
                        ...s,
                        l
                    ];
                default:
                    return [
                        ...s,
                        l
                    ];
            }
            return [
                ...s,
                ...Array.from(r.childNodes).reduce(i, [])
            ];
        };
        return t1.reduce(i, []);
    }
    /**
   * Compose paste event with passed type and detail
   *
   * @param {string} type - event type
   * @param {PasteEventDetail} detail - event detail
   */ composePasteEvent(e, t1) {
        return new CustomEvent(e, {
            detail: t1
        });
    }
};
Rn.PATTERN_PROCESSING_MAX_LENGTH = 450;
let pa = Rn;
class fa extends E {
    constructor(){
        super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = !1;
    }
    /**
   * Returns state of read only mode
   */ get isEnabled() {
        return this.readOnlyEnabled;
    }
    /**
   * Set initial state
   */ async prepare() {
        const { Tools: e } = this.Editor, { blockTools: t1 } = e, o = [];
        Array.from(t1.entries()).forEach(([i, s])=>{
            s.isReadOnlySupported || o.push(i);
        }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly, !0);
    }
    /**
   * Set read-only mode or toggle current state
   * Call all Modules `toggleReadOnly` method and re-render Editor
   *
   * @param state - (optional) read-only state or toggle
   * @param isInitial - (optional) true when editor is initializing
   */ async toggle(e = !this.readOnlyEnabled, t1 = !1) {
        e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();
        const o = this.readOnlyEnabled;
        this.readOnlyEnabled = e;
        for(const s in this.Editor)this.Editor[s].toggleReadOnly && this.Editor[s].toggleReadOnly(e);
        if (o === e) return this.readOnlyEnabled;
        if (t1) return this.readOnlyEnabled;
        this.Editor.ModificationsObserver.disable();
        const i = await this.Editor.Saver.save();
        return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(i.blocks), this.Editor.ModificationsObserver.enable(), this.readOnlyEnabled;
    }
    /**
   * Throws an error about tools which don't support read-only mode
   */ throwCriticalError() {
        throw new Ho(`To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(", ")} don't support read-only mode.`);
    }
}
class Be extends E {
    constructor(){
        super(...arguments), this.isRectSelectionActivated = !1, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = !1, this.isScrolling = !1, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];
    }
    /**
   * CSS classes for the Block
   *
   * @returns {{wrapper: string, content: string}}
   */ static get CSS() {
        return {
            overlay: "codex-editor-overlay",
            overlayContainer: "codex-editor-overlay__container",
            rect: "codex-editor-overlay__rectangle",
            topScrollZone: "codex-editor-overlay__scroll-zone--top",
            bottomScrollZone: "codex-editor-overlay__scroll-zone--bottom"
        };
    }
    /**
   * Module Preparation
   * Creating rect and hang handlers
   */ prepare() {
        this.enableModuleBindings();
    }
    /**
   * Init rect params
   *
   * @param {number} pageX - X coord of mouse
   * @param {number} pageY - Y coord of mouse
   */ startSelection(e, t1) {
        const o = document.elementFromPoint(e - window.pageXOffset, t1 - window.pageYOffset);
        o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = !1, this.clearSelection(), this.stackOfSelected = []);
        const s = [
            `.${R.CSS.content}`,
            `.${this.Editor.Toolbar.CSS.toolbar}`,
            `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`
        ], r = o.closest("." + this.Editor.UI.CSS.editorWrapper), a = s.some((l)=>!!o.closest(l));
        !r || a || (this.mousedown = !0, this.startX = e, this.startY = t1);
    }
    /**
   * Clear all params to end selection
   */ endSelection() {
        this.mousedown = !1, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = "none";
    }
    /**
   * is RectSelection Activated
   */ isRectActivated() {
        return this.isRectSelectionActivated;
    }
    /**
   * Mark that selection is end
   */ clearSelection() {
        this.isRectSelectionActivated = !1;
    }
    /**
   * Sets Module necessary event handlers
   */ enableModuleBindings() {
        const { container: e } = this.genHTML();
        this.listeners.on(e, "mousedown", (t1)=>{
            this.processMouseDown(t1);
        }, !1), this.listeners.on(document.body, "mousemove", dt((t1)=>{
            this.processMouseMove(t1);
        }, 10), {
            passive: !0
        }), this.listeners.on(document.body, "mouseleave", ()=>{
            this.processMouseLeave();
        }), this.listeners.on(window, "scroll", dt((t1)=>{
            this.processScroll(t1);
        }, 10), {
            passive: !0
        }), this.listeners.on(document.body, "mouseup", ()=>{
            this.processMouseUp();
        }, !1);
    }
    /**
   * Handle mouse down events
   *
   * @param {MouseEvent} mouseEvent - mouse event payload
   */ processMouseDown(e) {
        if (e.button !== this.MAIN_MOUSE_BUTTON) return;
        e.target.closest(d.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);
    }
    /**
   * Handle mouse move events
   *
   * @param {MouseEvent} mouseEvent - mouse event payload
   */ processMouseMove(e) {
        this.changingRectangle(e), this.scrollByZones(e.clientY);
    }
    /**
   * Handle mouse leave
   */ processMouseLeave() {
        this.clearSelection(), this.endSelection();
    }
    /**
   * @param {MouseEvent} mouseEvent - mouse event payload
   */ processScroll(e) {
        this.changingRectangle(e);
    }
    /**
   * Handle mouse up
   */ processMouseUp() {
        this.clearSelection(), this.endSelection();
    }
    /**
   * Scroll If mouse in scroll zone
   *
   * @param {number} clientY - Y coord of mouse
   */ scrollByZones(e) {
        if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {
            this.isScrolling = !1;
            return;
        }
        this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = !0);
    }
    /**
   * Generates required HTML elements
   *
   * @returns {Object<string, Element>}
   */ genHTML() {
        const { UI: e } = this.Editor, t1 = e.nodes.holder.querySelector("." + e.CSS.editorWrapper), o = d.make("div", Be.CSS.overlay, {}), i = d.make("div", Be.CSS.overlayContainer, {}), s = d.make("div", Be.CSS.rect, {});
        return i.appendChild(s), o.appendChild(i), t1.appendChild(o), this.overlayRectangle = s, {
            container: t1,
            overlay: o
        };
    }
    /**
   * Activates scrolling if blockSelection is active and mouse is in scroll zone
   *
   * @param {number} speed - speed of scrolling
   */ scrollVertical(e) {
        if (!(this.inScrollZone && this.mousedown)) return;
        const t1 = window.pageYOffset;
        window.scrollBy(0, e), this.mouseY += window.pageYOffset - t1, setTimeout(()=>{
            this.scrollVertical(e);
        }, 0);
    }
    /**
   * Handles the change in the rectangle and its effect
   *
   * @param {MouseEvent} event - mouse event
   */ changingRectangle(e) {
        if (!this.mousedown) return;
        e.pageY !== void 0 && (this.mouseX = e.pageX, this.mouseY = e.pageY);
        const { rightPos: t1, leftPos: o, index: i } = this.genInfoForMouseSelection(), s = this.startX > t1 && this.mouseX > t1, r = this.startX < o && this.mouseX < o;
        this.rectCrossesBlocks = !(s || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = !1, this.isRectSelectionActivated = !0, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = "block"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== void 0 && (this.trySelectNextBlock(i), this.inverseSelection(), b.get().removeAllRanges());
    }
    /**
   * Shrink rect to singular point
   */ shrinkRectangleToPoint() {
        this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;
    }
    /**
   * Select or unselect all of blocks in array if rect is out or in selectable area
   */ inverseSelection() {
        const t1 = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;
        if (this.rectCrossesBlocks && !t1) for (const o of this.stackOfSelected)this.Editor.BlockSelection.selectBlockByIndex(o);
        if (!this.rectCrossesBlocks && t1) for (const o of this.stackOfSelected)this.Editor.BlockSelection.unSelectBlockByIndex(o);
    }
    /**
   * Updates size of rectangle
   */ updateRectangleSize() {
        this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);
    }
    /**
   * Collects information needed to determine the behavior of the rectangle
   *
   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border
   */ genInfoForMouseSelection() {
        const t1 = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t1, o), s = this.Editor.BlockManager.getBlockByChildNode(i);
        let r;
        s !== void 0 && (r = this.Editor.BlockManager.blocks.findIndex((h)=>h.holder === s.holder));
        const a = this.Editor.BlockManager.lastBlock.holder.querySelector("." + R.CSS.content), l = Number.parseInt(window.getComputedStyle(a).width, 10) / 2, c = t1 - l, u = t1 + l;
        return {
            index: r,
            leftPos: c,
            rightPos: u
        };
    }
    /**
   * Select block with index index
   *
   * @param index - index of block in redactor
   */ addBlockInSelection(e) {
        this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);
    }
    /**
   * Adds a block to the selection and determines which blocks should be selected
   *
   * @param {object} index - index of new block in the reactor
   */ trySelectNextBlock(e) {
        const t1 = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, s = -1, r = 0;
        if (t1) return;
        const a = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;
        let l = r;
        o > 1 && (l = a ? i : s);
        const c = e > this.stackOfSelected[o - 1] && l === i, u = e < this.stackOfSelected[o - 1] && l === s, p = !(c || u || l === r);
        if (!p && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === void 0)) {
            let v = this.stackOfSelected[o - 1] + 1 || e;
            for(v; v <= e; v++)this.addBlockInSelection(v);
            return;
        }
        if (!p && e < this.stackOfSelected[o - 1]) {
            for(let v = this.stackOfSelected[o - 1] - 1; v >= e; v--)this.addBlockInSelection(v);
            return;
        }
        if (!p) return;
        let g = o - 1, f;
        for(e > this.stackOfSelected[o - 1] ? f = ()=>e > this.stackOfSelected[g] : f = ()=>e < this.stackOfSelected[g]; f();)this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[g]), this.stackOfSelected.pop(), g--;
    }
}
class ga extends E {
    /**
   * Renders passed blocks as one batch
   *
   * @param blocksData - blocks to render
   */ async render(e) {
        return new Promise((t1)=>{
            const { Tools: o, BlockManager: i } = this.Editor;
            if (e.length === 0) i.insert();
            else {
                const s = e.map(({ type: r, data: a, tunes: l, id: c })=>{
                    o.available.has(r) === !1 && (X(`Tool «${r}» is not found. Check 'tools' property at the Editor.js config.`, "warn"), a = this.composeStubDataForTool(r, a, c), r = o.stubTool);
                    let u;
                    try {
                        u = i.composeBlock({
                            id: c,
                            tool: r,
                            data: a,
                            tunes: l
                        });
                    } catch (h) {
                        S(`Block «${r}» skipped because of plugins error`, "error", {
                            data: a,
                            error: h
                        }), a = this.composeStubDataForTool(r, a, c), r = o.stubTool, u = i.composeBlock({
                            id: c,
                            tool: r,
                            data: a,
                            tunes: l
                        });
                    }
                    return u;
                });
                i.insertMany(s);
            }
            window.requestIdleCallback(()=>{
                t1();
            }, {
                timeout: 2e3
            });
        });
    }
    /**
   * Create data for the Stub Tool that will be used instead of unavailable tool
   *
   * @param tool - unavailable tool name to stub
   * @param data - data of unavailable block
   * @param [id] - id of unavailable block
   */ composeStubDataForTool(e, t1, o) {
        const { Tools: i } = this.Editor;
        let s = e;
        if (i.unavailable.has(e)) {
            const r = i.unavailable.get(e).toolbox;
            r !== void 0 && r[0].title !== void 0 && (s = r[0].title);
        }
        return {
            savedData: {
                id: o,
                type: e,
                data: t1
            },
            title: s
        };
    }
}
class ma extends E {
    /**
   * Composes new chain of Promises to fire them alternatelly
   *
   * @returns {OutputData}
   */ async save() {
        const { BlockManager: e, Tools: t1 } = this.Editor, o = e.blocks, i = [];
        try {
            o.forEach((a)=>{
                i.push(this.getSavedData(a));
            });
            const s = await Promise.all(i), r = await yt(s, (a)=>t1.blockTools.get(a).sanitizeConfig);
            return this.makeOutput(r);
        } catch (s) {
            X("Saving failed due to the Error %o", "error", s);
        }
    }
    /**
   * Saves and validates
   *
   * @param {Block} block - Editor's Tool
   * @returns {ValidatedData} - Tool's validated data
   */ async getSavedData(e) {
        const t1 = await e.save(), o = t1 && await e.validate(t1.data);
        return {
            ...t1,
            isValid: o
        };
    }
    /**
   * Creates output object with saved data, time and version of editor
   *
   * @param {ValidatedData} allExtractedData - data extracted from Blocks
   * @returns {OutputData}
   */ makeOutput(e) {
        const t1 = [];
        return e.forEach(({ id: o, tool: i, data: s, tunes: r, isValid: a })=>{
            if (!a) {
                S(`Block «${i}» skipped because saved data is invalid`);
                return;
            }
            if (i === this.Editor.Tools.stubTool) {
                t1.push(s);
                return;
            }
            const l = {
                id: o,
                type: i,
                data: s,
                ...!V(r) && {
                    tunes: r
                }
            };
            t1.push(l);
        }), {
            time: +/* @__PURE__ */ new Date(),
            blocks: t1,
            version: "2.31.0-rc.7"
        };
    }
}
(function() {
    try {
        if (typeof document < "u") {
            var n = document.createElement("style");
            n.appendChild(document.createTextNode(".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}")), document.head.appendChild(n);
        }
    } catch (e) {
        console.error("vite-plugin-css-injected-by-js", e);
    }
})();
const ba = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14"/></svg>';
function va(n) {
    const e = document.createElement("div");
    e.innerHTML = n.trim();
    const t1 = document.createDocumentFragment();
    return t1.append(...Array.from(e.childNodes)), t1;
}
/**
 * Base Paragraph Block for the Editor.js.
 * Represents a regular text block
 *
 * @author CodeX (team@codex.so)
 * @copyright CodeX 2018
 * @license The MIT License (MIT)
 */ class fo {
    /**
   * Default placeholder for Paragraph Tool
   *
   * @returns {string}
   * @class
   */ static get DEFAULT_PLACEHOLDER() {
        return "";
    }
    /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {object} params - constructor params
   * @param {ParagraphData} params.data - previously saved data
   * @param {ParagraphConfig} params.config - user config for Tool
   * @param {object} params.api - editor.js api
   * @param {boolean} readOnly - read only mode flag
   */ constructor({ data: e, config: t1, api: o, readOnly: i }){
        this.api = o, this.readOnly = i, this._CSS = {
            block: this.api.styles.block,
            wrapper: "ce-paragraph"
        }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t1.placeholder ? t1.placeholder : fo.DEFAULT_PLACEHOLDER, this._data = e ?? {}, this._element = null, this._preserveBlank = t1.preserveBlank ?? !1;
    }
    /**
   * Check if text content is empty and set empty string to inner html.
   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements
   *
   * @param {KeyboardEvent} e - key up event
   */ onKeyUp(e) {
        if (e.code !== "Backspace" && e.code !== "Delete" || !this._element) return;
        const { textContent: t1 } = this._element;
        t1 === "" && (this._element.innerHTML = "");
    }
    /**
   * Create Tool's view
   *
   * @returns {HTMLDivElement}
   * @private
   */ drawView() {
        const e = document.createElement("DIV");
        return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = "false", e.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = "true", e.addEventListener("keyup", this.onKeyUp)), e;
    }
    /**
   * Return Tool's view
   *
   * @returns {HTMLDivElement}
   */ render() {
        return this._element = this.drawView(), this._element;
    }
    /**
   * Method that specified how to merge two Text blocks.
   * Called by Editor.js by backspace at the beginning of the Block
   *
   * @param {ParagraphData} data
   * @public
   */ merge(e) {
        if (!this._element) return;
        this._data.text += e.text;
        const t1 = va(e.text);
        this._element.appendChild(t1), this._element.normalize();
    }
    /**
   * Validate Paragraph block data:
   * - check for emptiness
   *
   * @param {ParagraphData} savedData — data received after saving
   * @returns {boolean} false if saved data is not correct, otherwise true
   * @public
   */ validate(e) {
        return !(e.text.trim() === "" && !this._preserveBlank);
    }
    /**
   * Extract Tool's data from the view
   *
   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view
   * @returns {ParagraphData} - saved data
   * @public
   */ save(e) {
        return {
            text: e.innerHTML
        };
    }
    /**
   * On paste callback fired from Editor.
   *
   * @param {HTMLPasteEvent} event - event with pasted data
   */ onPaste(e) {
        const t1 = {
            text: e.detail.data.innerHTML
        };
        this._data = t1, window.requestAnimationFrame(()=>{
            this._element && (this._element.innerHTML = this._data.text || "");
        });
    }
    /**
   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools
   * @returns {ConversionConfig}
   */ static get conversionConfig() {
        return {
            export: "text",
            // to convert Paragraph to other block, use 'text' property of saved data
            import: "text"
        };
    }
    /**
   * Sanitizer rules
   * @returns {SanitizerConfig} - Edtior.js sanitizer config
   */ static get sanitize() {
        return {
            text: {
                br: !0
            }
        };
    }
    /**
   * Returns true to notify the core that read-only mode is supported
   *
   * @returns {boolean}
   */ static get isReadOnlySupported() {
        return !0;
    }
    /**
   * Used by Editor paste handling API.
   * Provides configuration to handle P tags.
   *
   * @returns {PasteConfig} - Paragraph Paste Setting
   */ static get pasteConfig() {
        return {
            tags: [
                "P"
            ]
        };
    }
    /**
   * Icon and title for displaying at the Toolbox
   *
   * @returns {ToolboxConfig} - Paragraph Toolbox Setting
   */ static get toolbox() {
        return {
            icon: ba,
            title: "Text"
        };
    }
}
class go {
    constructor(){
        this.commandName = "bold";
    }
    /**
   * Sanitizer Rule
   * Leave <b> tags
   *
   * @returns {object}
   */ static get sanitize() {
        return {
            b: {}
        };
    }
    /**
   * Create button for Inline Toolbar
   */ render() {
        return {
            icon: Ki,
            name: "bold",
            onActivate: ()=>{
                document.execCommand(this.commandName);
            },
            isActive: ()=>document.queryCommandState(this.commandName)
        };
    }
    /**
   * Set a shortcut
   *
   * @returns {boolean}
   */ get shortcut() {
        return "CMD+B";
    }
}
go.isInline = !0;
go.title = "Bold";
class mo {
    constructor(){
        this.commandName = "italic", this.CSS = {
            button: "ce-inline-tool",
            buttonActive: "ce-inline-tool--active",
            buttonModifier: "ce-inline-tool--italic"
        }, this.nodes = {
            button: null
        };
    }
    /**
   * Sanitizer Rule
   * Leave <i> tags
   *
   * @returns {object}
   */ static get sanitize() {
        return {
            i: {}
        };
    }
    /**
   * Create button for Inline Toolbar
   */ render() {
        return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Ji, this.nodes.button;
    }
    /**
   * Wrap range with <i> tag
   */ surround() {
        document.execCommand(this.commandName);
    }
    /**
   * Check selection and set activated state to button if there are <i> tag
   */ checkState() {
        const e = document.queryCommandState(this.commandName);
        return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;
    }
    /**
   * Set a shortcut
   */ get shortcut() {
        return "CMD+I";
    }
}
mo.isInline = !0;
mo.title = "Italic";
class bo {
    /**
   * @param api - Editor.js API
   */ constructor({ api: e }){
        this.commandLink = "createLink", this.commandUnlink = "unlink", this.ENTER_KEY = 13, this.CSS = {
            button: "ce-inline-tool",
            buttonActive: "ce-inline-tool--active",
            buttonModifier: "ce-inline-tool--link",
            buttonUnlink: "ce-inline-tool--unlink",
            input: "ce-inline-tool-input",
            inputShowed: "ce-inline-tool-input--showed"
        }, this.nodes = {
            button: null,
            input: null
        }, this.inputOpened = !1, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new b();
    }
    /**
   * Sanitizer Rule
   * Leave <a> tags
   *
   * @returns {object}
   */ static get sanitize() {
        return {
            a: {
                href: !0,
                target: "_blank",
                rel: "nofollow"
            }
        };
    }
    /**
   * Create button for Inline Toolbar
   */ render() {
        return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Co, this.nodes.button;
    }
    /**
   * Input for the link
   */ renderActions() {
        return this.nodes.input = document.createElement("input"), this.nodes.input.placeholder = this.i18n.t("Add a link"), this.nodes.input.enterKeyHint = "done", this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener("keydown", (e)=>{
            e.keyCode === this.ENTER_KEY && this.enterPressed(e);
        }), this.nodes.input;
    }
    /**
   * Handle clicks on the Inline Toolbar icon
   *
   * @param {Range} range - range to wrap with link
   */ surround(e) {
        if (e) {
            this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());
            const t1 = this.selection.findParentTag("A");
            if (t1) {
                this.selection.expandToTag(t1), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();
                return;
            }
        }
        this.toggleActions();
    }
    /**
   * Check selection and set activated state to button if there are <a> tag
   */ checkState() {
        const e = this.selection.findParentTag("A");
        if (e) {
            this.nodes.button.innerHTML = ns, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();
            const t1 = e.getAttribute("href");
            this.nodes.input.value = t1 !== "null" ? t1 : "", this.selection.save();
        } else this.nodes.button.innerHTML = Co, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);
        return !!e;
    }
    /**
   * Function called with Inline Toolbar closing
   */ clear() {
        this.closeActions();
    }
    /**
   * Set a shortcut
   */ get shortcut() {
        return "CMD+K";
    }
    /**
   * Show/close link input
   */ toggleActions() {
        this.inputOpened ? this.closeActions(!1) : this.openActions(!0);
    }
    /**
   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.
   */ openActions(e = !1) {
        this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = !0;
    }
    /**
   * Close input
   *
   * @param {boolean} clearSavedSelection — we don't need to clear saved selection
   *                                        on toggle-clicks on the icon of opened Toolbar
   */ closeActions(e = !0) {
        if (this.selection.isFakeBackgroundEnabled) {
            const t1 = new b();
            t1.save(), this.selection.restore(), this.selection.removeFakeBackground(), t1.restore();
        }
        this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = "", e && this.selection.clearSaved(), this.inputOpened = !1;
    }
    /**
   * Enter pressed on input
   *
   * @param {KeyboardEvent} event - enter keydown event
   */ enterPressed(e) {
        let t1 = this.nodes.input.value || "";
        if (!t1.trim()) {
            this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();
            return;
        }
        if (!this.validateURL(t1)) {
            this.notifier.show({
                message: "Pasted link is not valid.",
                style: "error"
            }), S("Incorrect Link pasted", "warn", t1);
            return;
        }
        t1 = this.prepareLink(t1), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t1), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();
    }
    /**
   * Detects if passed string is URL
   *
   * @param {string} str - string to validate
   * @returns {boolean}
   */ validateURL(e) {
        return !/\s/.test(e);
    }
    /**
   * Process link before injection
   * - sanitize
   * - add protocol for links like 'google.com'
   *
   * @param {string} link - raw user input
   */ prepareLink(e) {
        return e = e.trim(), e = this.addProtocol(e), e;
    }
    /**
   * Add 'http' protocol to the links like 'vc.ru', 'google.com'
   *
   * @param {string} link - string to process
   */ addProtocol(e) {
        if (/^(\w+):(\/\/)?/.test(e)) return e;
        const t1 = /^\/[^/\s]/.test(e), o = e.substring(0, 1) === "#", i = /^\/\/[^/\s]/.test(e);
        return !t1 && !o && !i && (e = "http://" + e), e;
    }
    /**
   * Inserts <a> tag with "href"
   *
   * @param {string} link - "href" value
   */ insertLink(e) {
        const t1 = this.selection.findParentTag("A");
        t1 && this.selection.expandToTag(t1), document.execCommand(this.commandLink, !1, e);
    }
    /**
   * Removes <a> tag
   */ unlink() {
        document.execCommand(this.commandUnlink);
    }
}
bo.isInline = !0;
bo.title = "Link";
class Fn {
    /**
   * @param api - Editor.js API
   */ constructor({ api: e }){
        this.i18nAPI = e.i18n, this.blocksAPI = e.blocks, this.selectionAPI = e.selection, this.toolsAPI = e.tools, this.caretAPI = e.caret;
    }
    /**
   * Returns tool's UI config
   */ async render() {
        const e = b.get(), t1 = this.blocksAPI.getBlockByElement(e.anchorNode);
        if (t1 === void 0) return [];
        const o = this.toolsAPI.getBlockTools(), i = await Yo(t1, o);
        if (i.length === 0) return [];
        const s = i.reduce((c, u)=>{
            var h;
            return (h = u.toolbox) == null || h.forEach((p)=>{
                c.push({
                    icon: p.icon,
                    title: z.t(K.toolNames, p.title),
                    name: u.name,
                    closeOnActivate: !0,
                    onActivate: async ()=>{
                        const g = await this.blocksAPI.convert(t1.id, u.name, p.data);
                        this.caretAPI.setToBlock(g, "end");
                    }
                });
            }), c;
        }, []), r = await t1.getActiveToolboxEntry(), a = r !== void 0 ? r.icon : Go, l = !be();
        return {
            icon: a,
            name: "convert-to",
            hint: {
                title: this.i18nAPI.t("Convert to")
            },
            children: {
                searchable: l,
                items: s,
                onOpen: ()=>{
                    l && (this.selectionAPI.setFakeBackground(), this.selectionAPI.save());
                },
                onClose: ()=>{
                    l && (this.selectionAPI.restore(), this.selectionAPI.removeFakeBackground());
                }
            }
        };
    }
}
Fn.isInline = !0;
class jn {
    /**
   * @param options - constructor options
   * @param options.data - stub tool data
   * @param options.api - Editor.js API
   */ constructor({ data: e, api: t1 }){
        this.CSS = {
            wrapper: "ce-stub",
            info: "ce-stub__info",
            title: "ce-stub__title",
            subtitle: "ce-stub__subtitle"
        }, this.api = t1, this.title = e.title || this.api.i18n.t("Error"), this.subtitle = this.api.i18n.t("The block can not be displayed correctly."), this.savedData = e.savedData, this.wrapper = this.make();
    }
    /**
   * Returns stub holder
   *
   * @returns {HTMLElement}
   */ render() {
        return this.wrapper;
    }
    /**
   * Return original Tool data
   *
   * @returns {BlockToolData}
   */ save() {
        return this.savedData;
    }
    /**
   * Create Tool html markup
   *
   * @returns {HTMLElement}
   */ make() {
        const e = d.make("div", this.CSS.wrapper), t1 = is, o = d.make("div", this.CSS.info), i = d.make("div", this.CSS.title, {
            textContent: this.title
        }), s = d.make("div", this.CSS.subtitle, {
            textContent: this.subtitle
        });
        return e.innerHTML = t1, o.appendChild(i), o.appendChild(s), e.appendChild(o), e;
    }
}
jn.isReadOnlySupported = !0;
class ka extends Tt {
    constructor(){
        super(...arguments), this.type = ae.Inline;
    }
    /**
   * Returns title for Inline Tool if specified by user
   */ get title() {
        return this.constructable[We.Title];
    }
    /**
   * Constructs new InlineTool instance from constructable
   */ create() {
        return new this.constructable({
            api: this.api,
            config: this.settings
        });
    }
    /**
   * Allows inline tool to be available in read-only mode
   * Can be used, for example, by comments tool
   */ get isReadOnlySupported() {
        return this.constructable[We.IsReadOnlySupported] ?? !1;
    }
}
class ya extends Tt {
    constructor(){
        super(...arguments), this.type = ae.Tune;
    }
    /**
   * Constructs new BlockTune instance from constructable
   *
   * @param data - Tune data
   * @param block - Block API object
   */ create(e, t1) {
        return new this.constructable({
            api: this.api,
            config: this.settings,
            block: t1,
            data: e
        });
    }
}
class j extends Map {
    /**
   * Returns Block Tools collection
   */ get blockTools() {
        const e = Array.from(this.entries()).filter(([, t1])=>t1.isBlock());
        return new j(e);
    }
    /**
   * Returns Inline Tools collection
   */ get inlineTools() {
        const e = Array.from(this.entries()).filter(([, t1])=>t1.isInline());
        return new j(e);
    }
    /**
   * Returns Block Tunes collection
   */ get blockTunes() {
        const e = Array.from(this.entries()).filter(([, t1])=>t1.isTune());
        return new j(e);
    }
    /**
   * Returns internal Tools collection
   */ get internalTools() {
        const e = Array.from(this.entries()).filter(([, t1])=>t1.isInternal);
        return new j(e);
    }
    /**
   * Returns Tools collection provided by user
   */ get externalTools() {
        const e = Array.from(this.entries()).filter(([, t1])=>!t1.isInternal);
        return new j(e);
    }
}
var wa = Object.defineProperty, Ea = Object.getOwnPropertyDescriptor, Hn = (n, e, t1, o)=>{
    for(var i = o > 1 ? void 0 : o ? Ea(e, t1) : e, s = n.length - 1, r; s >= 0; s--)(r = n[s]) && (i = (o ? r(e, t1, i) : r(i)) || i);
    return o && i && wa(e, t1, i), i;
};
class vo extends Tt {
    constructor(){
        super(...arguments), this.type = ae.Block, this.inlineTools = new j(), this.tunes = new j();
    }
    /**
   * Creates new Tool instance
   *
   * @param data - Tool data
   * @param block - BlockAPI for current Block
   * @param readOnly - True if Editor is in read-only mode
   */ create(e, t1, o) {
        return new this.constructable({
            data: e,
            block: t1,
            readOnly: o,
            api: this.api,
            config: this.settings
        });
    }
    /**
   * Returns true if read-only mode is supported by Tool
   */ get isReadOnlySupported() {
        return this.constructable[pe.IsReadOnlySupported] === !0;
    }
    /**
   * Returns true if Tool supports linebreaks
   */ get isLineBreaksEnabled() {
        return this.constructable[pe.IsEnabledLineBreaks];
    }
    /**
   * Returns Tool toolbox configuration (internal or user-specified).
   *
   * Merges internal and user-defined toolbox configs based on the following rules:
   *
   * - If both internal and user-defined toolbox configs are arrays their items are merged.
   * Length of the second one is kept.
   *
   * - If both are objects their properties are merged.
   *
   * - If one is an object and another is an array than internal config is replaced with user-defined
   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)
   */ get toolbox() {
        const e = this.constructable[pe.Toolbox], t1 = this.config[Pe.Toolbox];
        if (!V(e) && t1 !== !1) return t1 ? Array.isArray(e) ? Array.isArray(t1) ? t1.map((o, i)=>{
            const s = e[i];
            return s ? {
                ...s,
                ...o
            } : o;
        }) : [
            t1
        ] : Array.isArray(t1) ? t1 : [
            {
                ...e,
                ...t1
            }
        ] : Array.isArray(e) ? e : [
            e
        ];
    }
    /**
   * Returns Tool conversion configuration
   */ get conversionConfig() {
        return this.constructable[pe.ConversionConfig];
    }
    /**
   * Returns enabled inline tools for Tool
   */ get enabledInlineTools() {
        return this.config[Pe.EnabledInlineTools] || !1;
    }
    /**
   * Returns enabled tunes for Tool
   */ get enabledBlockTunes() {
        return this.config[Pe.EnabledBlockTunes];
    }
    /**
   * Returns Tool paste configuration
   */ get pasteConfig() {
        return this.constructable[pe.PasteConfig] ?? {};
    }
    get sanitizeConfig() {
        const e = super.sanitizeConfig, t1 = this.baseSanitizeConfig;
        if (V(e)) return t1;
        const o = {};
        for(const i in e)if (Object.prototype.hasOwnProperty.call(e, i)) {
            const s = e[i];
            D(s) ? o[i] = Object.assign({}, t1, s) : o[i] = s;
        }
        return o;
    }
    get baseSanitizeConfig() {
        const e = {};
        return Array.from(this.inlineTools.values()).forEach((t1)=>Object.assign(e, t1.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t1)=>Object.assign(e, t1.sanitizeConfig)), e;
    }
}
Hn([
    me
], vo.prototype, "sanitizeConfig", 1);
Hn([
    me
], vo.prototype, "baseSanitizeConfig", 1);
class xa {
    /**
   * @class
   * @param config - tools config
   * @param editorConfig - EditorJS config
   * @param api - EditorJS API module
   */ constructor(e, t1, o){
        this.api = o, this.config = e, this.editorConfig = t1;
    }
    /**
   * Returns Tool object based on it's type
   *
   * @param name - tool name
   */ get(e) {
        const { class: t1, isInternal: o = !1, ...i } = this.config[e], s = this.getConstructor(t1), r = t1[mt.IsTune];
        return new s({
            name: e,
            constructable: t1,
            config: i,
            api: this.api.getMethodsForTool(e, r),
            isDefault: e === this.editorConfig.defaultBlock,
            defaultPlaceholder: this.editorConfig.placeholder,
            isInternal: o
        });
    }
    /**
   * Find appropriate Tool object constructor for Tool constructable
   *
   * @param constructable - Tools constructable
   */ getConstructor(e) {
        switch(!0){
            case e[We.IsInline]:
                return ka;
            case e[mt.IsTune]:
                return ya;
            default:
                return vo;
        }
    }
}
class $n {
    /**
   * MoveDownTune constructor
   *
   * @param {API} api — Editor's API
   */ constructor({ api: e }){
        this.CSS = {
            animation: "wobble"
        }, this.api = e;
    }
    /**
   * Tune's appearance in block settings menu
   */ render() {
        return {
            icon: Xi,
            title: this.api.i18n.t("Move down"),
            onActivate: ()=>this.handleClick(),
            name: "move-down"
        };
    }
    /**
   * Handle clicks on 'move down' button
   */ handleClick() {
        const e = this.api.blocks.getCurrentBlockIndex(), t1 = this.api.blocks.getBlockByIndex(e + 1);
        if (!t1) throw new Error("Unable to move Block down since it is already the last");
        const o = t1.holder, i = o.getBoundingClientRect();
        let s = Math.abs(window.innerHeight - o.offsetHeight);
        i.top < window.innerHeight && (s = window.scrollY + o.offsetHeight), window.scrollTo(0, s), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(!0);
    }
}
$n.isTune = !0;
class zn {
    /**
   * DeleteTune constructor
   *
   * @param {API} api - Editor's API
   */ constructor({ api: e }){
        this.api = e;
    }
    /**
   * Tune's appearance in block settings menu
   */ render() {
        return {
            icon: Gi,
            title: this.api.i18n.t("Delete"),
            name: "delete",
            confirmation: {
                title: this.api.i18n.t("Click to delete"),
                onActivate: ()=>this.handleClick()
            }
        };
    }
    /**
   * Delete block conditions passed
   */ handleClick() {
        this.api.blocks.delete();
    }
}
zn.isTune = !0;
class Un {
    /**
   * MoveUpTune constructor
   *
   * @param {API} api - Editor's API
   */ constructor({ api: e }){
        this.CSS = {
            animation: "wobble"
        }, this.api = e;
    }
    /**
   * Tune's appearance in block settings menu
   */ render() {
        return {
            icon: Zi,
            title: this.api.i18n.t("Move up"),
            onActivate: ()=>this.handleClick(),
            name: "move-up"
        };
    }
    /**
   * Move current block up
   */ handleClick() {
        const e = this.api.blocks.getCurrentBlockIndex(), t1 = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);
        if (e === 0 || !t1 || !o) throw new Error("Unable to move Block up since it is already the first");
        const i = t1.holder, s = o.holder, r = i.getBoundingClientRect(), a = s.getBoundingClientRect();
        let l;
        a.top > 0 ? l = Math.abs(r.top) - Math.abs(a.top) : l = Math.abs(r.top) + a.height, window.scrollBy(0, -1 * l), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(!0);
    }
}
Un.isTune = !0;
var Ba = Object.defineProperty, Ca = Object.getOwnPropertyDescriptor, Ta = (n, e, t1, o)=>{
    for(var i = o > 1 ? void 0 : o ? Ca(e, t1) : e, s = n.length - 1, r; s >= 0; s--)(r = n[s]) && (i = (o ? r(e, t1, i) : r(i)) || i);
    return o && i && Ba(e, t1, i), i;
};
class Wn extends E {
    constructor(){
        super(...arguments), this.stubTool = "stub", this.toolsAvailable = new j(), this.toolsUnavailable = new j();
    }
    /**
   * Returns available Tools
   */ get available() {
        return this.toolsAvailable;
    }
    /**
   * Returns unavailable Tools
   */ get unavailable() {
        return this.toolsUnavailable;
    }
    /**
   * Return Tools for the Inline Toolbar
   */ get inlineTools() {
        return this.available.inlineTools;
    }
    /**
   * Return editor block tools
   */ get blockTools() {
        return this.available.blockTools;
    }
    /**
   * Return available Block Tunes
   *
   * @returns {object} - object of Inline Tool's classes
   */ get blockTunes() {
        return this.available.blockTunes;
    }
    /**
   * Returns default Tool object
   */ get defaultTool() {
        return this.blockTools.get(this.config.defaultBlock);
    }
    /**
   * Returns internal tools
   */ get internal() {
        return this.available.internalTools;
    }
    /**
   * Creates instances via passed or default configuration
   *
   * @returns {Promise<void>}
   */ async prepare() {
        if (this.validateTools(), this.config.tools = ut({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, "tools") || Object.keys(this.config.tools).length === 0) throw Error("Can't start without tools");
        const e = this.prepareConfig();
        this.factory = new xa(e, this.config, this.Editor.API);
        const t1 = this.getListOfPrepareFunctions(e);
        if (t1.length === 0) return Promise.resolve();
        await Qn(t1, (o)=>{
            this.toolPrepareMethodSuccess(o);
        }, (o)=>{
            this.toolPrepareMethodFallback(o);
        }), this.prepareBlockTools();
    }
    getAllInlineToolsSanitizeConfig() {
        const e = {};
        return Array.from(this.inlineTools.values()).forEach((t1)=>{
            Object.assign(e, t1.sanitizeConfig);
        }), e;
    }
    /**
   * Calls each Tool reset method to clean up anything set by Tool
   */ destroy() {
        Object.values(this.available).forEach(async (e)=>{
            A(e.reset) && await e.reset();
        });
    }
    /**
   * Returns internal tools
   * Includes Bold, Italic, Link and Paragraph
   */ get internalTools() {
        return {
            convertTo: {
                class: Fn,
                isInternal: !0
            },
            link: {
                class: bo,
                isInternal: !0
            },
            bold: {
                class: go,
                isInternal: !0
            },
            italic: {
                class: mo,
                isInternal: !0
            },
            paragraph: {
                class: fo,
                inlineToolbar: !0,
                isInternal: !0
            },
            stub: {
                class: jn,
                isInternal: !0
            },
            moveUp: {
                class: Un,
                isInternal: !0
            },
            delete: {
                class: zn,
                isInternal: !0
            },
            moveDown: {
                class: $n,
                isInternal: !0
            }
        };
    }
    /**
   * Tool prepare method success callback
   *
   * @param {object} data - append tool to available list
   */ toolPrepareMethodSuccess(e) {
        const t1 = this.factory.get(e.toolName);
        if (t1.isInline()) {
            const i = [
                "render"
            ].filter((s)=>!t1.create()[s]);
            if (i.length) {
                S(`Incorrect Inline Tool: ${t1.name}. Some of required methods is not implemented %o`, "warn", i), this.toolsUnavailable.set(t1.name, t1);
                return;
            }
        }
        this.toolsAvailable.set(t1.name, t1);
    }
    /**
   * Tool prepare method fail callback
   *
   * @param {object} data - append tool to unavailable list
   */ toolPrepareMethodFallback(e) {
        this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));
    }
    /**
   * Binds prepare function of plugins with user or default config
   *
   * @returns {Array} list of functions that needs to be fired sequentially
   * @param config - tools config
   */ getListOfPrepareFunctions(e) {
        const t1 = [];
        return Object.entries(e).forEach(([o, i])=>{
            t1.push({
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                function: A(i.class.prepare) ? i.class.prepare : ()=>{},
                data: {
                    toolName: o,
                    config: i.config
                }
            });
        }), t1;
    }
    /**
   * Assign enabled Inline Tools and Block Tunes for Block Tool
   */ prepareBlockTools() {
        Array.from(this.blockTools.values()).forEach((e)=>{
            this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);
        });
    }
    /**
   * Assign enabled Inline Tools for Block Tool
   *
   * @param tool - Block Tool
   */ assignInlineToolsToBlockTool(e) {
        if (this.config.inlineToolbar !== !1) {
            if (e.enabledInlineTools === !0) {
                e.inlineTools = new j(Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t1)=>[
                        t1,
                        this.inlineTools.get(t1)
                    ]) : Array.from(this.inlineTools.entries()));
                return;
            }
            Array.isArray(e.enabledInlineTools) && (e.inlineTools = new j(/** Prepend ConvertTo Inline Tool */ [
                "convertTo",
                ...e.enabledInlineTools
            ].map((t1)=>[
                    t1,
                    this.inlineTools.get(t1)
                ])));
        }
    }
    /**
   * Assign enabled Block Tunes for Block Tool
   *
   * @param tool — Block Tool
   */ assignBlockTunesToBlockTool(e) {
        if (e.enabledBlockTunes !== !1) {
            if (Array.isArray(e.enabledBlockTunes)) {
                const t1 = new j(e.enabledBlockTunes.map((o)=>[
                        o,
                        this.blockTunes.get(o)
                    ]));
                e.tunes = new j([
                    ...t1,
                    ...this.blockTunes.internalTools
                ]);
                return;
            }
            if (Array.isArray(this.config.tunes)) {
                const t1 = new j(this.config.tunes.map((o)=>[
                        o,
                        this.blockTunes.get(o)
                    ]));
                e.tunes = new j([
                    ...t1,
                    ...this.blockTunes.internalTools
                ]);
                return;
            }
            e.tunes = this.blockTunes.internalTools;
        }
    }
    /**
   * Validate Tools configuration objects and throw Error for user if it is invalid
   */ validateTools() {
        for(const e in this.config.tools)if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {
            if (e in this.internalTools) return;
            const t1 = this.config.tools[e];
            if (!A(t1) && !A(t1.class)) throw Error(`Tool «${e}» must be a constructor function or an object with function in the «class» property`);
        }
    }
    /**
   * Unify tools config
   */ prepareConfig() {
        const e = {};
        for(const t1 in this.config.tools)D(this.config.tools[t1]) ? e[t1] = this.config.tools[t1] : e[t1] = {
            class: this.config.tools[t1]
        };
        return e;
    }
}
Ta([
    me
], Wn.prototype, "getAllInlineToolsSanitizeConfig", 1);
const Sa = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:"\\feff"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;--color-background-icon-active: rgba(56, 138, 229, .1);--color-text-icon-active: #388AE5;--color-text-primary: black;position:absolute;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3;opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{color:var(--color-text-primary);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:0;border-radius:4px;line-height:normal;height:100%;padding:0;width:28px;background-color:transparent;cursor:pointer}@media (max-width: 650px){.ce-inline-tool{width:36px;height:36px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#f8f8f8}}.ce-inline-tool svg{display:block;width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:4px 8px;font-size:14px;line-height:22px;outline:none;margin:0;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-inline-tool--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:"";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:"";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:"";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #EFF0F1;--color-shadow: rgba(13, 20, 33, .1);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #F8F8F8;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;--popover-top: calc(100% + var(--offset-from-target));--popover-left: 0;--nested-popover-overlap: 4px;--icon-size: 20px;--item-padding: 3px;--item-height: calc(var(--icon-size) + 2 * var(--item-padding))}.ce-popover__container{min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0px 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:var(--popover-left);top:var(--popover-top);background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened>.ce-popover__container{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened>.ce-popover__container{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover--open-top .ce-popover__container{--popover-top: calc(-1 * (var(--offset-from-target) + var(--popover-height)))}.ce-popover--open-left .ce-popover__container{--popover-left: calc(-1 * var(--width) + 100%)}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}@media (max-width: 650px){.ce-popover .ce-popover__container{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}}.ce-popover__search{margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover--nested .ce-popover__container{--popover-left: calc(var(--nesting-level) * (var(--width) - var(--nested-popover-overlap)));top:calc(var(--trigger-item-top) - var(--nested-popover-overlap));position:absolute}.ce-popover--open-top.ce-popover--nested .ce-popover__container{top:calc(var(--trigger-item-top) - var(--popover-height) + var(--item-height) + var(--offset-from-target) + var(--nested-popover-overlap))}.ce-popover--open-left .ce-popover--nested .ce-popover__container{--popover-left: calc(-1 * (var(--nesting-level) + 1) * var(--width) + 100%)}.ce-popover-item-separator{padding:4px 3px}.ce-popover-item-separator--hidden{display:none}.ce-popover-item-separator__line{height:1px;background:var(--color-border);width:100%}.ce-popover-item-html--hidden{display:none}.ce-popover-item{--border-radius: 6px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:var(--item-padding);color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:none;background:transparent}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover-item__icon--tool{margin-right:4px}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-right:auto}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title,.ce-popover-item--confirmation .ce-popover-item__icon{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}.ce-popover-header{margin-bottom:8px;margin-top:4px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover-header__text{font-size:18px;font-weight:600}.ce-popover-header__back-button{border:0;background:transparent;width:36px;height:36px;color:var(--color-text-primary)}.ce-popover-header__back-button svg{display:block;width:28px;height:28px}.ce-popover--inline{--height: 38px;--height-mobile: 46px;--container-padding: 4px;position:relative}.ce-popover--inline .ce-popover__custom-content{margin-bottom:0}.ce-popover--inline .ce-popover__items{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-popover--inline .ce-popover__container{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:var(--container-padding);height:var(--height);top:0;min-width:-webkit-max-content;min-width:-moz-max-content;min-width:max-content;width:-webkit-max-content;width:-moz-max-content;width:max-content;-webkit-animation:none;animation:none}@media (max-width: 650px){.ce-popover--inline .ce-popover__container{height:var(--height-mobile);position:absolute}}.ce-popover--inline .ce-popover-item-separator{padding:0 4px}.ce-popover--inline .ce-popover-item-separator__line{height:100%;width:1px}.ce-popover--inline .ce-popover-item{border-radius:4px;padding:4px}.ce-popover--inline .ce-popover-item__icon--tool{-webkit-box-shadow:none;box-shadow:none;background:transparent;margin-right:0}.ce-popover--inline .ce-popover-item__icon{width:auto;width:initial;height:auto;height:initial}.ce-popover--inline .ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover--inline .ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover--inline .ce-popover-item:not(:last-of-type){margin-bottom:0;margin-bottom:initial}.ce-popover--inline .ce-popover-item-html{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover--inline .ce-popover-item__icon--chevron-right{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{--offset: 3px;left:0;top:calc(var(--height) + var(--offset))}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{top:calc(var(--height-mobile) + var(--offset))}}.ce-popover--inline .ce-popover--nested .ce-popover__container{min-width:var(--width);width:var(--width);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding:6px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.ce-popover--inline .ce-popover--nested .ce-popover__items{display:block;width:100%}.ce-popover--inline .ce-popover--nested .ce-popover-item{border-radius:6px;padding:3px}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested .ce-popover-item{padding:4px}}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon--tool{margin-right:4px}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon{width:26px;height:26px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator{padding:4px 3px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator__line{width:100%;height:1px}.codex-editor [data-placeholder]:empty:before,.codex-editor [data-placeholder][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text;content:attr(data-placeholder)}.codex-editor [data-placeholder-active]:empty:before,.codex-editor [data-placeholder-active][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text}.codex-editor [data-placeholder-active]:empty:focus:before,.codex-editor [data-placeholder-active][data-empty=true]:focus:before{content:attr(data-placeholder-active)}
`;
class Ia extends E {
    constructor(){
        super(...arguments), this.isMobile = !1, this.contentRectCache = null, this.resizeDebouncer = Eo(()=>{
            this.windowResize();
        }, 200), this.selectionChangeDebounced = Eo(()=>{
            this.selectionChanged();
        }, da), this.documentTouchedListener = (e)=>{
            this.documentTouched(e);
        };
    }
    /**
   * Editor.js UI CSS class names
   *
   * @returns {{editorWrapper: string, editorZone: string}}
   */ get CSS() {
        return {
            editorWrapper: "codex-editor",
            editorWrapperNarrow: "codex-editor--narrow",
            editorZone: "codex-editor__redactor",
            editorZoneHidden: "codex-editor__redactor--hidden",
            editorEmpty: "codex-editor--empty",
            editorRtlFix: "codex-editor--rtl"
        };
    }
    /**
   * Return Width of center column of Editor
   *
   * @returns {DOMRect}
   */ get contentRect() {
        if (this.contentRectCache !== null) return this.contentRectCache;
        const e = this.nodes.wrapper.querySelector(`.${R.CSS.content}`);
        return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {
            width: 650,
            left: 0,
            right: 0
        };
    }
    /**
   * Making main interface
   */ async prepare() {
        this.setIsMobile(), this.make(), this.loadStyles();
    }
    /**
   * Toggle read-only state
   *
   * If readOnly is true:
   *  - removes all listeners from main UI module elements
   *
   * if readOnly is false:
   *  - enables all listeners to UI module elements
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */ toggleReadOnly(e) {
        e ? this.unbindReadOnlySensitiveListeners() : window.requestIdleCallback(()=>{
            this.bindReadOnlySensitiveListeners();
        }, {
            timeout: 2e3
        });
    }
    /**
   * Check if Editor is empty and set CSS class to wrapper
   */ checkEmptiness() {
        const { BlockManager: e } = this.Editor;
        this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);
    }
    /**
   * Check if one of Toolbar is opened
   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar
   *
   * @returns {boolean}
   */ get someToolbarOpened() {
        const { Toolbar: e, BlockSettings: t1, InlineToolbar: o } = this.Editor;
        return !!(t1.opened || o.opened || e.toolbox.opened);
    }
    /**
   * Check for some Flipper-buttons is under focus
   */ get someFlipperButtonFocused() {
        return this.Editor.Toolbar.toolbox.hasFocus() ? !0 : Object.entries(this.Editor).filter(([e, t1])=>t1.flipper instanceof ce).some(([e, t1])=>t1.flipper.hasFocus());
    }
    /**
   * Clean editor`s UI
   */ destroy() {
        this.nodes.holder.innerHTML = "", this.unbindReadOnlyInsensitiveListeners();
    }
    /**
   * Close all Editor's toolbars
   */ closeAllToolbars() {
        const { Toolbar: e, BlockSettings: t1, InlineToolbar: o } = this.Editor;
        t1.close(), o.close(), e.toolbox.close();
    }
    /**
   * Check for mobile mode and save the result
   */ setIsMobile() {
        const e = window.innerWidth < Ro;
        e !== this.isMobile && this.eventsDispatcher.emit(Te, {
            isEnabled: this.isMobile
        }), this.isMobile = e;
    }
    /**
   * Makes Editor.js interface
   */ make() {
        this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make("div", [
            this.CSS.editorWrapper,
            ...this.isRtl ? [
                this.CSS.editorRtlFix
            ] : []
        ]), this.nodes.redactor = d.make("div", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + "px", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper), this.bindReadOnlyInsensitiveListeners();
    }
    /**
   * Appends CSS
   */ loadStyles() {
        const e = "editor-js-styles";
        if (d.get(e)) return;
        const t1 = d.make("style", null, {
            id: e,
            textContent: Sa.toString()
        });
        this.config.style && !V(this.config.style) && this.config.style.nonce && t1.setAttribute("nonce", this.config.style.nonce), d.prepend(document.head, t1);
    }
    /**
   * Adds listeners that should work both in read-only and read-write modes
   */ bindReadOnlyInsensitiveListeners() {
        this.listeners.on(document, "selectionchange", this.selectionChangeDebounced), this.listeners.on(window, "resize", this.resizeDebouncer, {
            passive: !0
        }), this.listeners.on(this.nodes.redactor, "mousedown", this.documentTouchedListener, {
            capture: !0,
            passive: !0
        }), this.listeners.on(this.nodes.redactor, "touchstart", this.documentTouchedListener, {
            capture: !0,
            passive: !0
        });
    }
    /**
   * Removes listeners that should work both in read-only and read-write modes
   */ unbindReadOnlyInsensitiveListeners() {
        this.listeners.off(document, "selectionchange", this.selectionChangeDebounced), this.listeners.off(window, "resize", this.resizeDebouncer), this.listeners.off(this.nodes.redactor, "mousedown", this.documentTouchedListener), this.listeners.off(this.nodes.redactor, "touchstart", this.documentTouchedListener);
    }
    /**
   * Adds listeners that should work only in read-only mode
   */ bindReadOnlySensitiveListeners() {
        this.readOnlyMutableListeners.on(this.nodes.redactor, "click", (e)=>{
            this.redactorClicked(e);
        }, !1), this.readOnlyMutableListeners.on(document, "keydown", (e)=>{
            this.documentKeydown(e);
        }, !0), this.readOnlyMutableListeners.on(document, "mousedown", (e)=>{
            this.documentClicked(e);
        }, !0), this.watchBlockHoveredEvents(), this.enableInputsEmptyMark();
    }
    /**
   * Listen redactor mousemove to emit 'block-hovered' event
   */ watchBlockHoveredEvents() {
        let e;
        this.readOnlyMutableListeners.on(this.nodes.redactor, "mousemove", dt((t1)=>{
            const o = t1.target.closest(".ce-block");
            this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(ln, {
                block: this.Editor.BlockManager.getBlockByChildNode(o)
            }));
        }, 20), {
            passive: !0
        });
    }
    /**
   * Unbind events that should work only in read-only mode
   */ unbindReadOnlySensitiveListeners() {
        this.readOnlyMutableListeners.clearAll();
    }
    /**
   * Resize window handler
   */ windowResize() {
        this.contentRectCache = null, this.setIsMobile();
    }
    /**
   * All keydowns on document
   *
   * @param {KeyboardEvent} event - keyboard event
   */ documentKeydown(e) {
        switch(e.keyCode){
            case y.ENTER:
                this.enterPressed(e);
                break;
            case y.BACKSPACE:
            case y.DELETE:
                this.backspacePressed(e);
                break;
            case y.ESC:
                this.escapePressed(e);
                break;
            default:
                this.defaultBehaviour(e);
                break;
        }
    }
    /**
   * Ignore all other document's keydown events
   *
   * @param {KeyboardEvent} event - keyboard event
   */ defaultBehaviour(e) {
        const { currentBlock: t1 } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;
        if (t1 !== void 0 && o === null) {
            this.Editor.BlockEvents.keydown(e);
            return;
        }
        o || t1 && i || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());
    }
    /**
   * @param {KeyboardEvent} event - keyboard event
   */ backspacePressed(e) {
        const { BlockManager: t1, BlockSelection: o, Caret: i } = this.Editor;
        if (o.anyBlockSelected && !b.isSelectionExists) {
            const s = t1.removeSelectedBlocks(), r = t1.insertDefaultBlockAtIndex(s, !0);
            i.setToBlock(r, i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();
        }
    }
    /**
   * Escape pressed
   * If some of Toolbar components are opened, then close it otherwise close Toolbar
   *
   * @param {Event} event - escape keydown event
   */ escapePressed(e) {
        this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();
    }
    /**
   * Enter pressed on document
   *
   * @param {KeyboardEvent} event - keyboard event
   */ enterPressed(e) {
        const { BlockManager: t1, BlockSelection: o } = this.Editor;
        if (this.someToolbarOpened) return;
        const i = t1.currentBlockIndex >= 0;
        if (o.anyBlockSelected && !b.isSelectionExists) {
            o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();
            return;
        }
        if (!this.someToolbarOpened && i && e.target.tagName === "BODY") {
            const s = this.Editor.BlockManager.insert();
            e.preventDefault(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s);
        }
        this.Editor.BlockSelection.clearSelection(e);
    }
    /**
   * All clicks on document
   *
   * @param {MouseEvent} event - Click event
   */ documentClicked(e) {
        var a, l;
        if (!e.isTrusted) return;
        const t1 = e.target;
        this.nodes.holder.contains(t1) || b.isAtEditor || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());
        const i = (a = this.Editor.BlockSettings.nodes.wrapper) == null ? void 0 : a.contains(t1), s = (l = this.Editor.Toolbar.nodes.settingsToggler) == null ? void 0 : l.contains(t1), r = i || s;
        if (this.Editor.BlockSettings.opened && !r) {
            this.Editor.BlockSettings.close();
            const c = this.Editor.BlockManager.getBlockByChildNode(t1);
            this.Editor.Toolbar.moveAndOpen(c);
        }
        this.Editor.BlockSelection.clearSelection(e);
    }
    /**
   * First touch on editor
   * Fired before click
   *
   * Used to change current block — we need to do it before 'selectionChange' event.
   * Also:
   * - Move and show the Toolbar
   * - Set a Caret
   *
   * @param event - touch or mouse event
   */ documentTouched(e) {
        let t1 = e.target;
        if (t1 === this.nodes.redactor) {
            const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;
            t1 = document.elementFromPoint(o, i);
        }
        try {
            this.Editor.BlockManager.setCurrentBlockByChildNode(t1);
        } catch  {
            this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();
        }
        this.Editor.ReadOnly.isEnabled || this.Editor.Toolbar.moveAndOpen();
    }
    /**
   * All clicks on the redactor zone
   *
   * @param {MouseEvent} event - click event
   * @description
   * - By clicks on the Editor's bottom zone:
   *      - if last Block is empty, set a Caret to this
   *      - otherwise, add a new empty Block and set a Caret to that
   */ redactorClicked(e) {
        if (!b.isCollapsed) return;
        const t1 = e.target, o = e.metaKey || e.ctrlKey;
        if (d.isAnchor(t1) && o) {
            e.stopImmediatePropagation(), e.stopPropagation();
            const i = t1.getAttribute("href"), s = oi(i);
            ii(s);
            return;
        }
        this.processBottomZoneClick(e);
    }
    /**
   * Check if user clicks on the Editor's bottom zone:
   *  - set caret to the last block
   *  - or add new empty block
   *
   * @param event - click event
   */ processBottomZoneClick(e) {
        const t1 = this.Editor.BlockManager.getBlockByIndex(-1), o = d.offset(t1.holder).bottom, i = e.pageY, { BlockSelection: s } = this.Editor;
        if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && /**
    * If there is cross block selection started, target will be equal to redactor so we need additional check
    */ !s.anyBlockSelected && /**
    * Prevent caret jumping (to last block) when clicking between blocks
    */ o < i) {
            e.stopImmediatePropagation(), e.stopPropagation();
            const { BlockManager: a, Caret: l, Toolbar: c } = this.Editor;
            (!a.lastBlock.tool.isDefault || !a.lastBlock.isEmpty) && a.insertAtEnd(), l.setToTheLastBlock(), c.moveAndOpen(a.lastBlock);
        }
    }
    /**
   * Handle selection changes on mobile devices
   * Uses for showing the Inline Toolbar
   */ selectionChanged() {
        const { CrossBlockSelection: e, BlockSelection: t1 } = this.Editor, o = b.anchorElement;
        if (e.isCrossBlockSelectionStarted && t1.anyBlockSelected && b.get().removeAllRanges(), !o) {
            b.range || this.Editor.InlineToolbar.close();
            return;
        }
        const i = o.closest(`.${R.CSS.content}`);
        (i === null || i.closest(`.${b.CSS.editorWrapper}`) !== this.nodes.wrapper) && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === "true")) || (this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o), this.Editor.InlineToolbar.tryToShow(!0));
    }
    /**
   * Editor.js provides and ability to show placeholders for empty contenteditable elements
   *
   * This method watches for input and focus events and toggles 'data-empty' attribute
   * to workaroud the case, when inputs contains only <br>s and has no visible content
   * Then, CSS could rely on this attribute to show placeholders
   */ enableInputsEmptyMark() {
        function e(t1) {
            const o = t1.target;
            Do(o);
        }
        this.readOnlyMutableListeners.on(this.nodes.wrapper, "input", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, "focusin", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, "focusout", e);
    }
}
const Oa = {
    // API Modules
    BlocksAPI: gi,
    CaretAPI: bi,
    EventsAPI: vi,
    I18nAPI: kt,
    API: ki,
    InlineToolbarAPI: yi,
    ListenersAPI: wi,
    NotifierAPI: Ci,
    ReadOnlyAPI: Ti,
    SanitizerAPI: Li,
    SaverAPI: Pi,
    SelectionAPI: Ni,
    ToolsAPI: Ri,
    StylesAPI: Di,
    ToolbarAPI: Fi,
    TooltipAPI: Ui,
    UiAPI: Wi,
    // Toolbar Modules
    BlockSettings: ms,
    Toolbar: Bs,
    InlineToolbar: Cs,
    // Modules
    BlockEvents: na,
    BlockManager: ra,
    BlockSelection: aa,
    Caret: Ye,
    CrossBlockSelection: la,
    DragNDrop: ca,
    ModificationsObserver: ha,
    Paste: pa,
    ReadOnly: fa,
    RectangleSelection: Be,
    Renderer: ga,
    Saver: ma,
    Tools: Wn,
    UI: Ia
};
class _a {
    /**
   * @param {EditorConfig} config - user configuration
   */ constructor(e){
        this.moduleInstances = {}, this.eventsDispatcher = new Oe();
        let t1, o;
        this.isReady = new Promise((i, s)=>{
            t1 = i, o = s;
        }), Promise.resolve().then(async ()=>{
            this.configuration = e, this.validate(), this.init(), await this.start(), await this.render();
            const { BlockManager: i, Caret: s, UI: r, ModificationsObserver: a } = this.moduleInstances;
            r.checkEmptiness(), a.enable(), this.configuration.autofocus === !0 && this.configuration.readOnly !== !0 && s.setToBlock(i.blocks[0], s.positions.START), t1();
        }).catch((i)=>{
            S(`Editor.js is not ready because of ${i}`, "error"), o(i);
        });
    }
    /**
   * Setting for configuration
   *
   * @param {EditorConfig|string} config - Editor's config to set
   */ set configuration(e) {
        var o, i;
        D(e) ? this.config = {
            ...e
        } : this.config = {
            holder: e
        }, ht(!!this.config.holderId, "config.holderId", "config.holder"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = "editorjs"), this.config.logLevel || (this.config.logLevel = Lo.VERBOSE), Zn(this.config.logLevel), ht(!!this.config.initialBlock, "config.initialBlock", "config.defaultBlock"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || "paragraph", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;
        const t1 = {
            type: this.config.defaultBlock,
            data: {}
        };
        this.config.placeholder = this.config.placeholder || !1, this.config.sanitizer = this.config.sanitizer || {
            p: !0,
            b: !0,
            a: !0
        }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : !1, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || {
            blocks: []
        }, this.config.onReady = this.config.onReady || (()=>{}), this.config.onChange = this.config.onChange || (()=>{}), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : !0, (V(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = {
            blocks: [
                t1
            ]
        }), this.config.readOnly = this.config.readOnly || !1, (o = this.config.i18n) != null && o.messages && z.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? void 0 : i.direction) || "ltr";
    }
    /**
   * Returns private property
   *
   * @returns {EditorConfig}
   */ get configuration() {
        return this.config;
    }
    /**
   * Checks for required fields in Editor's config
   */ validate() {
        const { holderId: e, holder: t1 } = this.config;
        if (e && t1) throw Error("«holderId» and «holder» param can't assign at the same time.");
        if (te(t1) && !d.get(t1)) throw Error(`element with ID «${t1}» is missing. Pass correct holder's ID.`);
        if (t1 && D(t1) && !d.isElement(t1)) throw Error("«holder» value must be an Element node");
    }
    /**
   * Initializes modules:
   *  - make and save instances
   *  - configure
   */ init() {
        this.constructModules(), this.configureModules();
    }
    /**
   * Start Editor!
   *
   * Get list of modules that needs to be prepared and return a sequence (Promise)
   *
   * @returns {Promise<void>}
   */ async start() {
        await [
            "Tools",
            "UI",
            "BlockManager",
            "Paste",
            "BlockSelection",
            "RectangleSelection",
            "CrossBlockSelection",
            "ReadOnly"
        ].reduce((t1, o)=>t1.then(async ()=>{
                try {
                    await this.moduleInstances[o].prepare();
                } catch (i) {
                    if (i instanceof Ho) throw new Error(i.message);
                    S(`Module ${o} was skipped because of %o`, "warn", i);
                }
            }), Promise.resolve());
    }
    /**
   * Render initial data
   */ render() {
        return this.moduleInstances.Renderer.render(this.config.data.blocks);
    }
    /**
   * Make modules instances and save it to the @property this.moduleInstances
   */ constructModules() {
        Object.entries(Oa).forEach(([e, t1])=>{
            try {
                this.moduleInstances[e] = new t1({
                    config: this.configuration,
                    eventsDispatcher: this.eventsDispatcher
                });
            } catch (o) {
                S("[constructModules]", `Module ${e} skipped because`, "error", o);
            }
        });
    }
    /**
   * Modules instances configuration:
   *  - pass other modules to the 'state' property
   *  - ...
   */ configureModules() {
        for(const e in this.moduleInstances)Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));
    }
    /**
   * Return modules without passed name
   *
   * @param {string} name - module for witch modules difference should be calculated
   */ getModulesDiff(e) {
        const t1 = {};
        for(const o in this.moduleInstances)o !== e && (t1[o] = this.moduleInstances[o]);
        return t1;
    }
}
/**
 * Editor.js
 *
 * @license Apache-2.0
 * @see Editor.js <https://editorjs.io>
 * @author CodeX Team <https://codex.so>
 */ class Aa {
    /** Editor version */ static get version() {
        return "2.31.0-rc.7";
    }
    /**
   * @param {EditorConfig|string|undefined} [configuration] - user configuration
   */ constructor(e){
        let t1 = ()=>{};
        D(e) && A(e.onReady) && (t1 = e.onReady);
        const o = new _a(e);
        this.isReady = o.isReady.then(()=>{
            this.exportAPI(o), t1();
        });
    }
    /**
   * Export external API methods
   *
   * @param {Core} editor — Editor's instance
   */ exportAPI(e) {
        const t1 = [
            "configuration"
        ], o = ()=>{
            Object.values(e.moduleInstances).forEach((s)=>{
                A(s.destroy) && s.destroy(), s.listeners.removeAll();
            }), zi(), e = null;
            for(const s in this)Object.prototype.hasOwnProperty.call(this, s) && delete this[s];
            Object.setPrototypeOf(this, null);
        };
        t1.forEach((s)=>{
            this[s] = e[s];
        }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({
            blocks: {
                clear: "clear",
                render: "render"
            },
            caret: {
                focus: "focus"
            },
            events: {
                on: "on",
                off: "off",
                emit: "emit"
            },
            saver: {
                save: "save"
            }
        }).forEach(([s, r])=>{
            Object.entries(r).forEach(([a, l])=>{
                this[l] = e.moduleInstances.API.methods[s][a];
            });
        });
    }
}
;
}}),
"[project]/node_modules/axios/lib/defaults/transitional.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
'use strict';
const __TURBOPACK__default__export__ = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};
}}),
"[project]/node_modules/axios/lib/helpers/bind.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>bind)
});
'use strict';
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}
}}),
"[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/bind.js [app-client] (ecmascript)");
'use strict';
;
// utils is a library of generic helper functions non-specific to axios
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest('undefined');
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest('ArrayBuffer');
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
    } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest('string');
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest('function');
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest('number');
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === 'object';
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== 'object') {
        return false;
    }
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest('Date');
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest('File');
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest('Blob');
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest('FileList');
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' || kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest('URLSearchParams');
const [isReadableStream, isRequest, isResponse, isHeaders] = [
    'ReadableStream',
    'Request',
    'Response',
    'Headers'
].map(kindOfTest);
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys = false } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
        return;
    }
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/ obj = [
            obj
        ];
    }
    if (isArray(obj)) {
        // Iterate over array values
        for(i = 0, l = obj.length; i < l; i++){
            fn.call(null, obj[i], i, obj);
        }
    } else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) {
            return _key;
        }
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
            result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
            result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
            result[targetKey] = val.slice();
        } else {
            result[targetKey] = val;
        }
    };
    for(let i = 0, l = arguments.length; i < l; i++){
        arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys } = {})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) {
            a[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(val, thisArg);
        } else {
            a[key] = val;
        }
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
    }
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, 'super', {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype)
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) {
        position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0){
        arr[i] = thing[i];
    }
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null){
        arr.push(matches);
    }
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest('HTMLFormElement');
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest('RegExp');
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
        }
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            'arguments',
            'caller',
            'callee'
        ].indexOf(name) !== -1) {
            return false;
        }
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ('writable' in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) {
            descriptor.set = ()=>{
                throw Error('Can not rewrite read-only method \'' + name + '\'');
            };
        }
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{};
const toFiniteNumber = (value, defaultValue)=>{
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
const DIGIT = '0123456789';
const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{
    let str = '';
    const { length } = alphabet;
    while(size--){
        str += alphabet[Math.random() * length | 0];
    }
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) {
                return;
            }
            if (!('toJSON' in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const isAsyncFn = kindOfTest('AsyncFunction');
const isThenable = (thing)=>thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34
const _setImmediate = ((setImmediateSupported, postMessageSupported)=>{
    if (setImmediateSupported) {
        return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks)=>{
        _global.addEventListener("message", ({ source, data })=>{
            if (source === _global && data === token) {
                callbacks.length && callbacks.shift()();
            }
        }, false);
        return (cb)=>{
            callbacks.push(cb);
            _global.postMessage(token, "*");
        };
    })(`axios@${Math.random()}`, []) : (cb)=>setTimeout(cb);
})(typeof setImmediate === 'function', isFunction(_global.postMessage));
const asap = typeof queueMicrotask !== 'undefined' ? queueMicrotask.bind(_global) : typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick || _setImmediate;
const __TURBOPACK__default__export__ = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap
};
}}),
"[project]/node_modules/axios/lib/helpers/null.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// eslint-disable-next-line strict
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = null;
}}),
"[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    } else {
        this.stack = new Error().stack;
    }
    this.message = message;
    this.name = 'AxiosError';
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
    }
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toJSONObject(this.config),
            code: this.code,
            status: this.status
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {};
[
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL'
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== 'isAxiosError';
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
const __TURBOPACK__default__export__ = AxiosError;
}}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/axios/lib/helpers/toFormData.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$null$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/null.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
;
;
;
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPlainObject(thing) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].endsWith(key, '[]') ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? '[' + token + ']' : token;
    }).join(dots ? '.' : '');
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(arr) && !arr.some(isVisitable);
}
const predicates = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toFlatObject(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(obj)) {
        throw new TypeError('target must be an object');
    }
    // eslint-disable-next-line no-param-reassign
    formData = formData || new (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$null$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
    const useBlob = _Blob && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isSpecCompliantForm(formData);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(visitor)) {
        throw new TypeError('visitor must be a function');
    }
    function convertValue(value) {
        if (value === null) return '';
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDate(value)) {
            return value.toISOString();
        }
        if (!useBlob && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isBlob(value)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Blob is not supported. Use a Buffer instead.');
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArrayBuffer(value) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isTypedArray(value)) {
            return useBlob && typeof Blob === 'function' ? new Blob([
                value
            ]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value);
        }
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === 'object') {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].endsWith(key, '{}')) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(value) && isFlatArray(value) || (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFileList(value) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].endsWith(key, '[]')) && (arr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) {
            return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
            throw Error('Circular reference detected in ' + path.join('.'));
        }
        stack.push(value);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(value, function each(el, key) {
            const result = !(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(el) || el === null) && visitor.call(formData, el, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) {
                build(el, path ? path.concat(key) : [
                    key
                ]);
            }
        });
        stack.pop();
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(obj)) {
        throw new TypeError('data must be an object');
    }
    build(obj);
    return formData;
}
const __TURBOPACK__default__export__ = toFormData;
}}),
"[project]/node_modules/axios/lib/platform/common/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "hasBrowserEnv": (()=>hasBrowserEnv),
    "hasStandardBrowserEnv": (()=>hasStandardBrowserEnv),
    "hasStandardBrowserWebWorkerEnv": (()=>hasStandardBrowserWebWorkerEnv),
    "navigator": (()=>_navigator),
    "origin": (()=>origin)
});
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
const _navigator = typeof navigator === 'object' && navigator || undefined;
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || [
    'ReactNative',
    'NativeScript',
    'NS'
].indexOf(_navigator.product) < 0);
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const hasStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== 'undefined' && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();
const origin = hasBrowserEnv && window.location.href || 'http://localhost';
;
}}),
"[project]/node_modules/axios/lib/helpers/AxiosURLSearchParams.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/toFormData.js [app-client] (ecmascript)");
'use strict';
;
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '~': '%7E',
        '%20': '+',
        '%00': '\x00'
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + '=' + _encode(pair[1]);
    }, '').join('&');
};
const __TURBOPACK__default__export__ = AxiosURLSearchParams;
}}),
"[project]/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$AxiosURLSearchParams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/AxiosURLSearchParams.js [app-client] (ecmascript)");
'use strict';
;
const __TURBOPACK__default__export__ = typeof URLSearchParams !== 'undefined' ? URLSearchParams : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$AxiosURLSearchParams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}}),
"[project]/node_modules/axios/lib/platform/browser/classes/FormData.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
'use strict';
const __TURBOPACK__default__export__ = typeof FormData !== 'undefined' ? FormData : null;
}}),
"[project]/node_modules/axios/lib/platform/browser/classes/Blob.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
'use strict';
const __TURBOPACK__default__export__ = typeof Blob !== 'undefined' ? Blob : null;
}}),
"[project]/node_modules/axios/lib/platform/browser/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$classes$2f$URLSearchParams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$classes$2f$FormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/browser/classes/FormData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$classes$2f$Blob$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/browser/classes/Blob.js [app-client] (ecmascript)");
;
;
;
const __TURBOPACK__default__export__ = {
    isBrowser: true,
    classes: {
        URLSearchParams: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$classes$2f$URLSearchParams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        FormData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$classes$2f$FormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        Blob: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$classes$2f$Blob$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    },
    protocols: [
        'http',
        'https',
        'file',
        'blob',
        'url',
        'data'
    ]
};
}}),
"[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$common$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/common/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/browser/index.js [app-client] (ecmascript)");
;
;
const __TURBOPACK__default__export__ = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$common$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$browser$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
};
}}),
"[project]/node_modules/axios/lib/helpers/toURLEncodedForm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>toURLEncodedForm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/toFormData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
;
;
function toURLEncodedForm(data, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNode && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isBuffer(value)) {
                this.append(key, value.toString('base64'));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}
}}),
"[project]/node_modules/axios/lib/helpers/formDataToJSON.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === '[]' ? '' : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === '__proto__') return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(target) ? target.length : name;
        if (isLast) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasOwnProp(target, name)) {
                target[name] = [
                    target[name],
                    value
                ];
            } else {
                target[name] = value;
            }
            return !isNumericKey;
        }
        if (!target[name] || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(target[name])) {
            target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(target[name])) {
            target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFormData(formData) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(formData.entries)) {
        const obj = {};
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
const __TURBOPACK__default__export__ = formDataToJSON;
}}),
"[project]/node_modules/axios/lib/defaults/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$transitional$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/defaults/transitional.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toURLEncodedForm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/toURLEncodedForm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/toFormData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$formDataToJSON$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/formDataToJSON.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
'use strict';
;
;
;
;
;
;
;
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(rawValue)) {
        try {
            (parser || JSON.parse)(rawValue);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].trim(rawValue);
        } catch (e) {
            if (e.name !== 'SyntaxError') {
                throw e;
            }
        }
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$transitional$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    adapter: [
        'xhr',
        'http',
        'fetch'
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || '';
            const hasJSONContentType = contentType.indexOf('application/json') > -1;
            const isObjectPayload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(data);
            if (isObjectPayload && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isHTMLForm(data)) {
                data = new FormData(data);
            }
            const isFormData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFormData(data);
            if (isFormData) {
                return hasJSONContentType ? JSON.stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$formDataToJSON$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data)) : data;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArrayBuffer(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isBuffer(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isStream(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFile(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isBlob(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isReadableStream(data)) {
                return data;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArrayBufferView(data)) {
                return data.buffer;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isURLSearchParams(data)) {
                headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toURLEncodedForm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data, this.formSerializer).toString();
                }
                if ((isFileList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(isFileList ? {
                        'files[]': data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType('application/json', false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === 'json';
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isResponse(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isReadableStream(data)) {
                return data;
            }
            if (data && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === 'SyntaxError') {
                            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(e, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_RESPONSE, this, null, this.response);
                        }
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].classes.FormData,
        Blob: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            'Accept': 'application/json, text/plain, */*',
            'Content-Type': undefined
        }
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach([
    'delete',
    'get',
    'head',
    'post',
    'put',
    'patch'
], (method)=>{
    defaults.headers[method] = {};
});
const __TURBOPACK__default__export__ = defaults;
}}),
"[project]/node_modules/axios/lib/env/data.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "VERSION": (()=>VERSION)
});
const VERSION = "1.7.9";
}}),
"[project]/node_modules/axios/lib/helpers/validator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$env$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/env/data.js [app-client] (ecmascript)");
'use strict';
;
;
const validators = {};
// eslint-disable-next-line func-names
[
    'object',
    'boolean',
    'number',
    'function',
    'string',
    'symbol'
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
});
const deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return '[Axios v' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$env$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"] + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_DEPRECATED);
        }
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
validators.spelling = function spelling(correctSpelling) {
    return (value, opt)=>{
        // eslint-disable-next-line no-console
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== 'object') {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('options must be an object', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('option ' + opt + ' must be ' + result, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_OPTION_VALUE);
            }
            continue;
        }
        if (allowUnknown !== true) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Unknown option ' + opt, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_OPTION);
        }
    }
}
const __TURBOPACK__default__export__ = {
    assertOptions,
    validators
};
}}),
"[project]/node_modules/axios/lib/core/InterceptorManager.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) {
            this.handlers[id] = null;
        }
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) {
            this.handlers = [];
        }
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
                fn(h);
            }
        });
    }
}
const __TURBOPACK__default__export__ = InterceptorManager;
}}),
"[project]/node_modules/axios/lib/helpers/parseHeaders.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toObjectSet([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent'
]);
const __TURBOPACK__default__export__ = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
        i = line.indexOf(':');
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
        }
        if (key === 'set-cookie') {
            if (parsed[key]) {
                parsed[key].push(val);
            } else {
                parsed[key] = [
                    val
                ];
            }
        } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
    });
    return parsed;
};
}}),
"[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$parseHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/parseHeaders.js [app-client] (ecmascript)");
'use strict';
;
;
const $internals = Symbol('internals');
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) {
        return value;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str)){
        tokens[match[1]] = match[2];
    }
    return tokens;
}
const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(filter)) {
        return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
        value = header;
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(value)) return;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(filter)) {
        return value.indexOf(filter) !== -1;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isRegExp(filter)) {
        return filter.test(value);
    }
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toCamelCase(' ' + header);
    [
        'get',
        'set',
        'has'
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
                throw new Error('header name must be a non-empty string');
            }
            const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
                self[key || _header] = normalizeValue(_value);
            }
        }
        const setHeaders = (headers, _rewrite)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPlainObject(header) || header instanceof this.constructor) {
            setHeaders(header, valueOrRewrite);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$parseHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(header), valueOrRewrite);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isHeaders(header)) {
            for (const [key, value] of header.entries()){
                setHeader(value, key, rewrite);
            }
        } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) {
                    return value;
                }
                if (parser === true) {
                    return parseTokens(value);
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(parser)) {
                    return parser.call(this, value, key);
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isRegExp(parser)) {
                    return parser.exec(value);
                }
                throw new TypeError('parser must be boolean|regexp|function');
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(header)) {
            header.forEach(deleteHeader);
        } else {
            deleteHeader(header);
        }
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(this, (value, header)=>{
            const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].findKey(headers, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
                delete self[header];
            }
            self[normalized] = normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(value) ? value.join(', ') : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ': ' + value).join('\n');
    }
    get [Symbol.toStringTag]() {
        return 'AxiosHeaders';
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    'Content-Type',
    'Content-Length',
    'Accept',
    'Accept-Encoding',
    'User-Agent',
    'Authorization'
]);
// reserved names hotfix
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].reduceDescriptors(AxiosHeaders.prototype, ({ value }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].freezeMethods(AxiosHeaders);
const __TURBOPACK__default__export__ = AxiosHeaders;
}}),
"[project]/node_modules/axios/lib/core/mergeConfig.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>mergeConfig)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
;
const headersToObject = (thing)=>thing instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? {
        ...thing
    } : thing;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPlainObject(target) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPlainObject(source)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].merge.call({
                caseless
            }, target, source);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPlainObject(source)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].merge({}, source);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(source)) {
            return source.slice();
        }
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, prop, caseless) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(b)) {
            return getMergedValue(a, b, prop, caseless);
        } else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(a)) {
            return getMergedValue(undefined, a, prop, caseless);
        }
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(b)) {
            return getMergedValue(undefined, b);
        }
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(b)) {
            return getMergedValue(undefined, b);
        } else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(a)) {
            return getMergedValue(undefined, a);
        }
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
            return getMergedValue(a, b);
        } else if (prop in config1) {
            return getMergedValue(undefined, a);
        }
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop)=>mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}
}}),
"[project]/node_modules/axios/lib/core/transformData.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>transformData)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/defaults/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
;
;
function transformData(fns, response) {
    const config = this || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    const context = response || config;
    const headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(context.headers);
    let data = context.data;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}
}}),
"[project]/node_modules/axios/lib/helpers/speedometer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
'use strict';
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
            firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
            tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
            return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
const __TURBOPACK__default__export__ = speedometer;
}}),
"[project]/node_modules/axios/lib/helpers/throttle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1000 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now())=>{
        timestamp = now;
        lastArgs = null;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        fn.apply(null, args);
    };
    const throttled = (...args)=>{
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
            invoke(args, now);
        } else {
            lastArgs = args;
            if (!timer) {
                timer = setTimeout(()=>{
                    timer = null;
                    invoke(lastArgs);
                }, threshold - passed);
            }
        }
    };
    const flush = ()=>lastArgs && invoke(lastArgs);
    return [
        throttled,
        flush
    ];
}
const __TURBOPACK__default__export__ = throttle;
}}),
"[project]/node_modules/axios/lib/helpers/progressEventReducer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "asyncDecorator": (()=>asyncDecorator),
    "progressEventDecorator": (()=>progressEventDecorator),
    "progressEventReducer": (()=>progressEventReducer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$speedometer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/speedometer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/throttle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
;
;
;
const progressEventReducer = (listener, isDownloadStream, freq = 3)=>{
    let bytesNotified = 0;
    const _speedometer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$speedometer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(50, 250);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])((e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e,
            lengthComputable: total != null,
            [isDownloadStream ? 'download' : 'upload']: true
        };
        listener(data);
    }, freq);
};
const progressEventDecorator = (total, throttled)=>{
    const lengthComputable = total != null;
    return [
        (loaded)=>throttled[0]({
                lengthComputable,
                total,
                loaded
            }),
        throttled[1]
    ];
};
const asyncDecorator = (fn)=>(...args)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].asap(()=>fn(...args));
}}),
"[project]/node_modules/axios/lib/cancel/CanceledError.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
'use strict';
;
;
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].call(this, message == null ? 'canceled' : message, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_CANCELED, config, request);
    this.name = 'CanceledError';
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inherits(CanceledError, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], {
    __CANCEL__: true
});
const __TURBOPACK__default__export__ = CanceledError;
}}),
"[project]/node_modules/axios/lib/helpers/parseProtocol.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>parseProtocol)
});
'use strict';
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || '';
}
}}),
"[project]/node_modules/axios/lib/helpers/buildURL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>buildURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$AxiosURLSearchParams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/AxiosURLSearchParams.js [app-client] (ecmascript)");
'use strict';
;
;
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) {
        return url;
    }
    const _encode = options && options.encode || encode;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(options)) {
        options = {
            serialize: options
        };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
        serializedParams = serializeFn(params, options);
    } else {
        serializedParams = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isURLSearchParams(params) ? params.toString() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$AxiosURLSearchParams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](params, options).toString(_encode);
    }
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url;
}
}}),
"[project]/node_modules/axios/lib/helpers/isAbsoluteURL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>isAbsoluteURL)
});
'use strict';
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
}}),
"[project]/node_modules/axios/lib/helpers/combineURLs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>combineURLs)
});
'use strict';
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}
}}),
"[project]/node_modules/axios/lib/core/buildFullPath.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>buildFullPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$isAbsoluteURL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/isAbsoluteURL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$combineURLs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/combineURLs.js [app-client] (ecmascript)");
'use strict';
;
;
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$isAbsoluteURL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(requestedURL)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$combineURLs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(baseURL, requestedURL);
    }
    return requestedURL;
}
}}),
"[project]/node_modules/axios/lib/helpers/isURLSameOrigin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasStandardBrowserEnv ? ((origin, isMSIE)=>(url)=>{
        url = new URL(url, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].origin);
        return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);
    })(new URL(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].origin), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].navigator && /(msie|trident)/i.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].navigator.userAgent)) : ()=>true;
}}),
"[project]/node_modules/axios/lib/helpers/cookies.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (name, value, expires, path, domain, secure) {
        const cookie = [
            name + '=' + encodeURIComponent(value)
        ];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(path) && cookie.push('path=' + path);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(domain) && cookie.push('domain=' + domain);
        secure === true && cookie.push('secure');
        document.cookie = cookie.join('; ');
    },
    read (name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove (name) {
        this.write(name, '', Date.now() - 86400000);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};
}}),
"[project]/node_modules/axios/lib/helpers/resolveConfig.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/mergeConfig.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$buildURL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/buildURL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$buildFullPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/buildFullPath.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$isURLSameOrigin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/isURLSameOrigin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$cookies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/cookies.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const __TURBOPACK__default__export__ = (config)=>{
    const newConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(headers);
    newConfig.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$buildURL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$buildFullPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
    // HTTP basic authentication
    if (auth) {
        headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
    }
    let contentType;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFormData(data)) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasStandardBrowserEnv || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasStandardBrowserWebWorkerEnv) {
            headers.setContentType(undefined); // Let the browser set it
        } else if ((contentType = headers.getContentType()) !== false) {
            // fix semicolon duplication issue for ReactNative FormData implementation
            const [type, ...tokens] = contentType ? contentType.split(';').map((token)=>token.trim()).filter(Boolean) : [];
            headers.setContentType([
                type || 'multipart/form-data',
                ...tokens
            ].join('; '));
        }
    }
    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasStandardBrowserEnv) {
        withXSRFToken && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$isURLSameOrigin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(newConfig.url)) {
            // Add xsrf header
            const xsrfValue = xsrfHeaderName && xsrfCookieName && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$cookies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].read(xsrfCookieName);
            if (xsrfValue) {
                headers.set(xsrfHeaderName, xsrfValue);
            }
        }
    }
    return newConfig;
};
}}),
"[project]/node_modules/axios/lib/core/settle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>settle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
'use strict';
;
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
    } else {
        reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Request failed with status code ' + response.status, [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_REQUEST,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_RESPONSE
        ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
    }
}
}}),
"[project]/node_modules/axios/lib/adapters/xhr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$transitional$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/defaults/transitional.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/progressEventReducer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/CanceledError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$parseProtocol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/parseProtocol.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$resolveConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/resolveConfig.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$settle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/settle.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
const __TURBOPACK__default__export__ = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$resolveConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config);
        let requestData = _config.data;
        const requestHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
            flushUpload && flushUpload(); // flush events
            flushDownload && flushDownload(); // flush events
            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
            _config.signal && _config.signal.removeEventListener('abort', onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        // Set the request timeout in MS
        request.timeout = _config.timeout;
        function onloadend() {
            if (!request) {
                return;
            }
            // Prepare the response
            const responseHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$settle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ('onloadend' in request) {
            // Use onloadend if available
            request.onloadend = onloadend;
        } else {
            // Listen for ready state to emulate onloadend
            request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                    return;
                }
                // The request errored out and we didn't get a response, this will be
                // handled by onerror instead
                // With one exception: request that using file: protocol, most browsers
                // will return status as 0 even though it's a successful request
                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                    return;
                }
                // readystate handler is calling before onerror or ontimeout handlers,
                // so we should call onloadend on the next 'tick'
                setTimeout(onloadend);
            };
        }
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) {
                return;
            }
            reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Request aborted', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Network Error', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
            const transitional = _config.transitional || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$transitional$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
            if (_config.timeoutErrorMessage) {
                timeoutErrorMessage = _config.timeoutErrorMessage;
            }
            reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](timeoutErrorMessage, transitional.clarifyTimeoutError ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ETIMEDOUT : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ('setRequestHeader' in request) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
                request.setRequestHeader(key, val);
            });
        }
        // Add withCredentials to request if needed
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isUndefined(_config.withCredentials)) {
            request.withCredentials = !!_config.withCredentials;
        }
        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
            request.responseType = _config.responseType;
        }
        // Handle progress if needed
        if (onDownloadProgress) {
            [downloadThrottled, flushDownload] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["progressEventReducer"])(onDownloadProgress, true);
            request.addEventListener('progress', downloadThrottled);
        }
        // Not all browsers support upload events
        if (onUploadProgress && request.upload) {
            [uploadThrottled, flushUpload] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["progressEventReducer"])(onUploadProgress);
            request.upload.addEventListener('progress', uploadThrottled);
            request.upload.addEventListener('loadend', flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) {
                    return;
                }
                reject(!cancel || cancel.type ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](null, config, request) : cancel);
                request.abort();
                request = null;
            };
            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
            if (_config.signal) {
                _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
            }
        }
        const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$parseProtocol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(_config.url);
        if (protocol && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].protocols.indexOf(protocol) === -1) {
            reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Unsupported protocol ' + protocol + ':', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};
}}),
"[project]/node_modules/axios/lib/helpers/composeSignals.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/CanceledError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
;
;
;
const composeSignals = (signals, timeout)=>{
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
            if (!aborted) {
                aborted = true;
                unsubscribe();
                const err = reason instanceof Error ? reason : this.reason;
                controller.abort(err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? err : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](err instanceof Error ? err.message : err));
            }
        };
        let timer = timeout && setTimeout(()=>{
            timer = null;
            onabort(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`timeout ${timeout} of ms exceeded`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ETIMEDOUT));
        }, timeout);
        const unsubscribe = ()=>{
            if (signals) {
                timer && clearTimeout(timer);
                timer = null;
                signals.forEach((signal)=>{
                    signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
                });
                signals = null;
            }
        };
        signals.forEach((signal)=>signal.addEventListener('abort', onabort));
        const { signal } = controller;
        signal.unsubscribe = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].asap(unsubscribe);
        return signal;
    }
};
const __TURBOPACK__default__export__ = composeSignals;
}}),
"[project]/node_modules/axios/lib/helpers/trackStream.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "readBytes": (()=>readBytes),
    "streamChunk": (()=>streamChunk),
    "trackStream": (()=>trackStream)
});
const streamChunk = function*(chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
    }
    let pos = 0;
    let end;
    while(pos < len){
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
    }
};
const readBytes = async function*(iterable, chunkSize) {
    for await (const chunk of readStream(iterable)){
        yield* streamChunk(chunk, chunkSize);
    }
};
const readStream = async function*(stream) {
    if (stream[Symbol.asyncIterator]) {
        yield* stream;
        return;
    }
    const reader = stream.getReader();
    try {
        for(;;){
            const { done, value } = await reader.read();
            if (done) {
                break;
            }
            yield value;
        }
    } finally{
        await reader.cancel();
    }
};
const trackStream = (stream, chunkSize, onProgress, onFinish)=>{
    const iterator = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e)=>{
        if (!done) {
            done = true;
            onFinish && onFinish(e);
        }
    };
    return new ReadableStream({
        async pull (controller) {
            try {
                const { done, value } = await iterator.next();
                if (done) {
                    _onFinish();
                    controller.close();
                    return;
                }
                let len = value.byteLength;
                if (onProgress) {
                    let loadedBytes = bytes += len;
                    onProgress(loadedBytes);
                }
                controller.enqueue(new Uint8Array(value));
            } catch (err) {
                _onFinish(err);
                throw err;
            }
        },
        cancel (reason) {
            _onFinish(reason);
            return iterator.return();
        }
    }, {
        highWaterMark: 2
    });
};
}}),
"[project]/node_modules/axios/lib/adapters/fetch.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/platform/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$resolveConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/resolveConfig.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$composeSignals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/composeSignals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/progressEventReducer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$trackStream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/trackStream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$settle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/settle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';
// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? ((encoder)=>(str)=>encoder.encode(str))(new TextEncoder()) : async (str)=>new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args)=>{
    try {
        return !!fn(...args);
    } catch (e) {
        return false;
    }
};
const supportsRequestStream = isReadableStreamSupported && test(()=>{
    let duplexAccessed = false;
    const hasContentType = new Request(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].origin, {
        body: new ReadableStream(),
        method: 'POST',
        get duplex () {
            duplexAccessed = true;
            return 'half';
        }
    }).headers.has('Content-Type');
    return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isReadableStream(new Response('').body));
const resolvers = {
    stream: supportsResponseStream && ((res)=>res.body)
};
isFetchSupported && ((res)=>{
    [
        'text',
        'arrayBuffer',
        'blob',
        'formData',
        'stream'
    ].forEach((type)=>{
        !resolvers[type] && (resolvers[type] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(res[type]) ? (res)=>res[type]() : (_, config)=>{
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Response type '${type}' is not supported`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_NOT_SUPPORT, config);
        });
    });
})(new Response);
const getBodyLength = async (body)=>{
    if (body == null) {
        return 0;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isBlob(body)) {
        return body.size;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isSpecCompliantForm(body)) {
        const _request = new Request(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$platform$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].origin, {
            method: 'POST',
            body
        });
        return (await _request.arrayBuffer()).byteLength;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArrayBufferView(body) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArrayBuffer(body)) {
        return body.byteLength;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isURLSearchParams(body)) {
        body = body + '';
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(body)) {
        return (await encodeText(body)).byteLength;
    }
};
const resolveBodyLength = async (headers, body)=>{
    const length = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
};
const __TURBOPACK__default__export__ = isFetchSupported && (async (config)=>{
    let { url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = 'same-origin', fetchOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$resolveConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config);
    responseType = responseType ? (responseType + '').toLowerCase() : 'text';
    let composedSignal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$composeSignals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])([
        signal,
        cancelToken && cancelToken.toAbortSignal()
    ], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (()=>{
        composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
        if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url, {
                method: 'POST',
                body: data,
                duplex: "half"
            });
            let contentTypeHeader;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
                headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
                const [onProgress, flush] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["progressEventDecorator"])(requestContentLength, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["progressEventReducer"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncDecorator"])(onUploadProgress)));
                data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$trackStream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trackStream"])(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isString(withCredentials)) {
            withCredentials = withCredentials ? 'include' : 'omit';
        }
        // Cloudflare Workers throws when credentials are defined
        // see https://github.com/cloudflare/workerd/issues/902
        const isCredentialsSupported = "credentials" in Request.prototype;
        request = new Request(url, {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : undefined
        });
        let response = await fetch(request);
        const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            [
                'status',
                'statusText',
                'headers'
            ].forEach((prop)=>{
                options[prop] = response[prop];
            });
            const responseContentLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toFiniteNumber(response.headers.get('content-length'));
            const [onProgress, flush] = onDownloadProgress && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["progressEventDecorator"])(responseContentLength, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["progressEventReducer"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$progressEventReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncDecorator"])(onDownloadProgress), true)) || [];
            response = new Response((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$trackStream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trackStream"])(response.body, DEFAULT_CHUNK_SIZE, onProgress, ()=>{
                flush && flush();
                unsubscribe && unsubscribe();
            }), options);
        }
        responseType = responseType || 'text';
        let responseData = await resolvers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].findKey(resolvers, responseType) || 'text'](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$settle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(resolve, reject, {
                data: responseData,
                headers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(response.headers),
                status: response.status,
                statusText: response.statusText,
                config,
                request
            });
        });
    } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
            throw Object.assign(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('Network Error', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ERR_NETWORK, config, request), {
                cause: err.cause || err
            });
        }
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(err, err && err.code, config, request);
    }
});
}}),
"[project]/node_modules/axios/lib/adapters/adapters.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$null$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/null.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$xhr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/adapters/xhr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/adapters/fetch.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
;
;
;
;
;
const knownAdapters = {
    http: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$null$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    xhr: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$xhr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    fetch: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, 'name', {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, 'adapterName', {
            value
        });
    }
});
const renderReason = (reason)=>`- ${reason}`;
const isResolvedHandle = (adapter)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(adapter) || adapter === null || adapter === false;
const __TURBOPACK__default__export__ = {
    getAdapter: (adapters)=>{
        adapters = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(adapters) ? adapters : [
            adapters
        ];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Unknown adapter '${id}'`);
                }
            }
            if (adapter) {
                break;
            }
            rejectedReasons[id || '#' + i] = adapter;
        }
        if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
            let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
        }
        return adapter;
    },
    adapters: knownAdapters
};
}}),
"[project]/node_modules/axios/lib/cancel/isCancel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>isCancel)
});
'use strict';
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}
}}),
"[project]/node_modules/axios/lib/core/dispatchRequest.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>dispatchRequest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$transformData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/transformData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$adapters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/adapters/adapters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/defaults/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$isCancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/isCancel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/CanceledError.js [app-client] (ecmascript)");
'use strict';
;
;
;
;
;
;
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](null, config);
    }
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(config.headers);
    // Transform request data
    config.data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$transformData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].call(config, config.transformRequest);
    if ([
        'post',
        'put',
        'patch'
    ].indexOf(config.method) !== -1) {
        config.headers.setContentType('application/x-www-form-urlencoded', false);
    }
    const adapter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$adapters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getAdapter(config.adapter || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$transformData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].call(config, config.transformResponse, response);
        response.headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$isCancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$transformData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].call(config, config.transformResponse, reason.response);
                reason.response.headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}
}}),
"[project]/node_modules/axios/lib/core/Axios.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/validator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$InterceptorManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/InterceptorManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/mergeConfig.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$dispatchRequest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/dispatchRequest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$buildFullPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/buildFullPath.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$buildURL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/buildURL.js [app-client] (ecmascript)");
'use strict';
;
;
;
;
;
;
;
;
const validators = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$InterceptorManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
            response: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$InterceptorManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(configOrUrl, config) {
        try {
            return await this._request(configOrUrl, config);
        } catch (err) {
            if (err instanceof Error) {
                let dummy = {};
                Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
                // slice off the Error: ... line
                const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
                try {
                    if (!err.stack) {
                        err.stack = stack;
                    // match without the 2 top stack lines
                    } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
                        err.stack += '\n' + stack;
                    }
                } catch (e) {
                // ignore the case where "stack" is an un-writable property
                }
            }
            throw err;
        }
    }
    _request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === 'string') {
            config = config || {};
            config.url = configOrUrl;
        } else {
            config = configOrUrl || {};
        }
        config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== undefined) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].assertOptions(transitional, {
                silentJSONParsing: validators.transitional(validators.boolean),
                forcedJSONParsing: validators.transitional(validators.boolean),
                clarifyTimeoutError: validators.transitional(validators.boolean)
            }, false);
        }
        if (paramsSerializer != null) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isFunction(paramsSerializer)) {
                config.paramsSerializer = {
                    serialize: paramsSerializer
                };
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].assertOptions(paramsSerializer, {
                    encode: validators.function,
                    serialize: validators.function
                }, true);
            }
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].assertOptions(config, {
            baseUrl: validators.spelling('baseURL'),
            withXsrfToken: validators.spelling('withXSRFToken')
        }, true);
        // Set config.method
        config.method = (config.method || this.defaults.method || 'get').toLowerCase();
        // Flatten headers
        let contextHeaders = headers && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].merge(headers.common, headers[config.method]);
        headers && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach([
            'delete',
            'get',
            'head',
            'post',
            'put',
            'patch',
            'common'
        ], (method)=>{
            delete headers[method];
        });
        config.headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
                return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$dispatchRequest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len){
                promise = promise.then(chain[i++], chain[i++]);
            }
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$dispatchRequest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len){
            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
    }
    getUri(config) {
        config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.defaults, config);
        const fullPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$buildFullPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config.baseURL, config.url);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$buildURL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach([
    'delete',
    'get',
    'head',
    'options'
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config || {}, {
            method,
            url,
            data: (config || {}).data
        }));
    };
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config || {}, {
                method,
                headers: isForm ? {
                    'Content-Type': 'multipart/form-data'
                } : {},
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
const __TURBOPACK__default__export__ = Axios;
}}),
"[project]/node_modules/axios/lib/cancel/CancelToken.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/CanceledError.js [app-client] (ecmascript)");
'use strict';
;
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== 'function') {
            throw new TypeError('executor must be a function.');
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0){
                token._listeners[i](cancel);
            }
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) {
                // Cancellation has already been requested
                return;
            }
            token.reason = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) {
            throw this.reason;
        }
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) {
            this._listeners.push(listener);
        } else {
            this._listeners = [
                listener
            ];
        }
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) {
            return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
            this._listeners.splice(index, 1);
        }
    }
    toAbortSignal() {
        const controller = new AbortController();
        const abort = (err)=>{
            controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = ()=>this.unsubscribe(abort);
        return controller.signal;
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel
        };
    }
}
const __TURBOPACK__default__export__ = CancelToken;
}}),
"[project]/node_modules/axios/lib/helpers/spread.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>spread)
});
'use strict';
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}
}}),
"[project]/node_modules/axios/lib/helpers/isAxiosError.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>isAxiosError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
'use strict';
;
function isAxiosError(payload) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isObject(payload) && payload.isAxiosError === true;
}
}}),
"[project]/node_modules/axios/lib/helpers/HttpStatusCode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
const __TURBOPACK__default__export__ = HttpStatusCode;
}}),
"[project]/node_modules/axios/lib/axios.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/defaults/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$Axios$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/Axios.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/CanceledError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CancelToken$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/CancelToken.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$isCancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/cancel/isCancel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$env$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/env/data.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/toFormData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$isAxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/isAxiosError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/mergeConfig.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/core/AxiosHeaders.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$formDataToJSON$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/formDataToJSON.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$adapters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/adapters/adapters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$HttpStatusCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/HttpStatusCode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/helpers/bind.js [app-client] (ecmascript)");
'use strict';
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$Axios$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](defaultConfig);
    const instance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$Axios$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.request, context);
    // Copy axios.prototype to instance
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(instance, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$Axios$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$defaults$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
// Expose Axios class to allow class inheritance
axios.Axios = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$Axios$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// Expose Cancel & CancelToken
axios.CanceledError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CanceledError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
axios.CancelToken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$CancelToken$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
axios.isCancel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$cancel$2f$isCancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
axios.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$env$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"];
axios.toFormData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$toFormData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// Expose AxiosError class
axios.AxiosError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// Expose isAxiosError
axios.isAxiosError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$isAxiosError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// Expose mergeConfig
axios.mergeConfig = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$mergeConfig$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
axios.AxiosHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$core$2f$AxiosHeaders$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
axios.formToJSON = (thing)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$formDataToJSON$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$adapters$2f$adapters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getAdapter;
axios.HttpStatusCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$helpers$2f$HttpStatusCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
axios.default = axios;
const __TURBOPACK__default__export__ = axios;
}}),
}]);

//# sourceMappingURL=node_modules_e38fa7._.js.map